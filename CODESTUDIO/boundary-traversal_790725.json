{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 7846,
            "title": "Boundary Traversal",
            "titleSlug": "boundary-traversal_790725",
            "content": "<h4 id=\"you-are-given-a-binary-tree-having-n-nodes\">You are given a binary tree having <em><strong>&#39;n&#39;</strong></em> nodes.</h4>\n\n<p><br/></p>\n\n<h4 id=\"the-boundary-nodes-of-a-binary-tree-include-the-nodes-from-the-left-and-right-boundaries-and-the-leaf-nodes-each-node-considered-once\">The boundary nodes of a binary tree include the nodes from the left and right boundaries and the leaf nodes, each node considered once.</h4>\n\n<p><br/></p>\n\n<h4 id=\"figure-out-the-boundary-nodes-of-this-binary-tree-in-an-anti-clockwise-direction-starting-from-the-root-node\">Figure out the boundary nodes of this binary tree in an Anti-Clockwise direction starting from the root node.</h4>\n\n<p><br/></p>\n\n<h5 id=\"example\">Example :</h5>\n\n<pre><code>Input: Consider the binary tree A as shown in the figure:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/boundarytraversal-5149.png\" alt=\"alt text\"></p>\n\n<pre><code>Output: [10, 5, 3, 7, 18, 25, 20]\n\nExplanation: As shown in the figure\n\nThe nodes on the left boundary are [10, 5, 3]\n\nThe nodes on the right boundary are [10, 20, 25]\n\nThe leaf nodes are [3, 7, 18, 25].\n\nPlease note that nodes 3 and 25 appear in two places but are considered once.\n</code></pre>\n\n<h5 id=\"input-format\">Input Format:</h5>\n\n<pre><code>The only line contains elements in the level order form. The line consists of values of nodes separated by a single space. In case a node is null, we take -1 in its place.\n\nFor example, the input for the tree depicted in the below image will be:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/0000000000004189.png\" alt=\"alt text\"></p>\n\n<pre><code>1\n2 3\n4 -1 5 6\n-1 7 -1 -1 -1 -1\n-1 -1\n\nExplanation :\nLevel 1 :\nThe root node of the tree is 1\n\nLevel 2 :\nLeft child of 1 = 2\nRight child of 1 = 3\n\nLevel 3 :\nLeft child of 2 = 4\nRight child of 2 = null (-1)\nLeft child of 3 = 5\nRight child of 3 = 6\n\nLevel 4 :\nLeft child of 4 = null (-1)\nRight child of 4 = 7\nLeft child of 5 = null (-1)\nRight child of 5 = null (-1)\nLeft child of 6 = null (-1)\nRight child of 6 = null (-1)\n\nLevel 5 :\nLeft child of 7 = null (-1)\nRight child of 7 = null (-1)\n\nThe first not-null node(of the previous level) is treated as the parent of the first two nodes of the current level. The second not-null node (of the previous level) is treated as the parent node for the next two nodes of the current level and so on.\n\nThe input ends when all nodes at the last level are null(-1).\n\nThe sequence will be put together in a single line separated by a single space. Hence, for the above-depicted tree, the input will be given as:\n\n1 2 3 4 -1 5 6 -1 7 -1 -1 -1 -1 -1 -1\n</code></pre>\n\n<p><br/></p>\n\n<h5 id=\"output-format\">Output Format:</h5>\n\n<pre><code>Print the boundary nodes of the given binary tree separated by single spaces.\n</code></pre>\n\n<p><br/></p>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>You do not need to print anything; it has already been taken care of. Just implement the given function.\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1:</h5>\n\n<pre><code>10 5 20 3 8 18 25 -1 -1 7 -1 -1 -1 -1 -1 -1 -1\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1:</h5>\n\n<pre><code>10 5 3 7 18 25 20\n</code></pre>\n\n<h5 id=\"explanation-of-sample-input-1\">Explanation of Sample Input 1:</h5>\n\n<pre><code>The nodes on the left boundary are [10, 5, 3]\n\nThe nodes on the right boundary are [10, 20, 25]\n\nThe leaf nodes are [3, 7, 18, 25].\n\nPlease note that nodes 3 and 25 appear in two places but are considered once.\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2:</h5>\n\n<pre><code>100 50 150 25 75 140 200 -1 30 70 80 -1 -1 -1 -1 -1 35 -1 -1 -1 -1 -1 -1\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2:</h5>\n\n<pre><code>100 50 25 30 35 70 80 140 200 150\n</code></pre>\n\n<h5 id=\"constraints\">Constraints:</h5>\n\n<pre><code>1 &lt;= n &lt;= 10000\n\nWhere &#39;n&#39; is the total number of nodes in the binary tree.\n\nTime Limit: 1 sec\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 488,
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a binary tree with 'n' nodes, find and return the boundary nodes in an anti-clockwise direction, starting from the root. The boundary includes the left boundary, leaf nodes, and the right boundary, with each node appearing only once in the final result.",
                "constraints": [
                    "1 <= n <= 10000",
                    "Where 'n' is the total number of nodes in the binary tree.",
                    "Time Limit: 1 sec"
                ],
                "testcases": [
                    {
                        "input": "10 5 20 3 8 18 25 -1 -1 7 -1 -1 -1 -1 -1 -1 -1",
                        "output": "10 5 3 7 18 25 20",
                        "explanation": "The left boundary nodes are [10, 5, 3]. The right boundary nodes are [10, 20, 25]. The leaf nodes are [3, 7, 18, 25].  Combining these (without duplicates and in anti-clockwise order) gives [10, 5, 3, 7, 18, 25, 20]."
                    },
                    {
                        "input": "100 50 150 25 75 140 200 -1 30 70 80 -1 -1 -1 -1 -1 35 -1 -1 -1 -1 -1 -1",
                        "output": "100 50 25 30 35 70 80 140 200 150",
                        "explanation": null
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Traverse those three boundaries separately and then combine the result.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Binary Trees",
                "slug": "binary-trees"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "cpp",
                "full_func": "/*\r\n    Time Complexity: O(n)\r\n    Space Complexity: O(n)\r\n\r\n    Where 'n' is the number of nodes in the Binary Tree.\r\n*/\r\n\r\n/************************************************************\r\n\r\n    Following is the Binary Tree node structure:\r\n\r\n    template <typename T>\r\n    class TreeNode\r\n    {\r\n    public:\r\n        T data;\r\n        TreeNode<T> *left;\r\n        TreeNode<T> *right;\r\n\r\n        TreeNode(T data)\r\n        {\r\n            this -> data = data;\r\n            left = NULL;\r\n            right = NULL;\r\n        }\r\n\r\n        ~TreeNode()\r\n        {\r\n            if(left)\r\n                delete left;\r\n            if(right)\r\n                delete right;\r\n        }\r\n    };\r\n\r\n************************************************************/\r\n\r\n// Functions to traverse on each part\r\nvoid leftBoundary(TreeNode<int>* root, vector<int>& ans);\r\nvoid rightBoundary(TreeNode<int>* root, vector<int>& ans);\r\nvoid leafNodes(TreeNode<int>* root, vector<int>& ans);\r\n\r\nvector<int> traverseBoundary(TreeNode<int>* root)\r\n{\r\n    vector<int> ans;\r\n\r\n    if (root == NULL)\r\n    {\r\n        return ans;\r\n    }\r\n\r\n    ans.push_back(root -> data);\r\n\r\n    // Traverse left boundary\r\n    leftBoundary(root -> left, ans);\r\n\r\n    // Traverse for leaf nodes\r\n    leafNodes(root -> left, ans);\r\n    leafNodes(root -> right, ans);\r\n\r\n    // Traverse right boundary\r\n    rightBoundary(root -> right, ans);\r\n\r\n    return ans;\r\n}\r\n\r\nvoid leftBoundary(TreeNode<int>* root, vector<int>& ans)\r\n{\r\n    if (root == NULL || (root -> left == NULL && root -> right == NULL))\r\n    {\r\n        return;\r\n    }\r\n\r\n    ans.push_back(root -> data);\r\n\r\n    if (root -> left != NULL)\r\n    {\r\n        leftBoundary(root -> left, ans);\r\n    }\r\n    else\r\n    {\r\n        leftBoundary(root -> right, ans);\r\n    }\r\n}\r\n\r\nvoid rightBoundary(TreeNode<int>* root, vector<int>& ans)\r\n{\r\n    if (root == NULL || (root -> left == NULL && root -> right == NULL))\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (root -> right != NULL)\r\n    {\r\n        rightBoundary(root -> right, ans);\r\n    }\r\n    else\r\n    {\r\n        rightBoundary(root -> left, ans);\r\n    }\r\n\r\n    ans.push_back(root -> data);\r\n}\r\n\r\nvoid leafNodes(TreeNode<int>* root, vector<int>& ans)\r\n{\r\n    if (root == NULL)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (root -> left == NULL && root -> right == NULL)\r\n    {\r\n        ans.push_back(root -> data);\r\n        return;\r\n    }\r\n\r\n    leafNodes(root -> left, ans);\r\n    leafNodes(root -> right, ans);\r\n}",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "java",
                "full_func": "/*\r\n    Time Complexity: O(N)\r\n    Space Complexity: O(N)\r\n\r\n    Where 'N' is the number of nodes in the Binary Tree.\r\n*/\r\n\r\nimport java.util.List;\r\nimport java.util.ArrayList;\r\n\r\npublic class Solution {\r\n    // Functions to traverse on each part.\r\n    public static List<Integer> traverseBoundary(TreeNode root) {\r\n        List<Integer> ans = new ArrayList<>();\r\n\r\n        if (root == null) {\r\n            return ans;\r\n        }\r\n\r\n        ans.add(root.data);\r\n\r\n        // Traverse left boundary.\r\n        leftBoundary(root.left, ans);\r\n\r\n        // Traverse for leaf nodes.\r\n        leafNodes(root.left, ans);\r\n        leafNodes(root.right, ans);\r\n\r\n        // Traverse right boundary.\r\n        rightBoundary(root.right, ans);\r\n\r\n        return ans;\r\n    }\r\n\r\n    public static void leftBoundary(TreeNode root, List<Integer> ans) {\r\n        if (root == null || (root.left == null && root.right == null)) {\r\n            return;\r\n        }\r\n\r\n        ans.add(root.data);\r\n\r\n        if (root.left != null) {\r\n            leftBoundary(root.left, ans);\r\n        }\r\n\r\n        else {\r\n            leftBoundary(root.right, ans);\r\n        }\r\n    }\r\n\r\n    public static void rightBoundary(TreeNode root, List<Integer> ans) {\r\n        if (root == null || (root.left == null && root.right == null)) {\r\n            return;\r\n        }\r\n\r\n        if (root.right != null) {\r\n            rightBoundary(root.right, ans);\r\n        }\r\n\r\n        else {\r\n            rightBoundary(root.left, ans);\r\n        }\r\n\r\n        ans.add(root.data);\r\n    }\r\n\r\n    public static void leafNodes(TreeNode root, List<Integer> ans) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n\r\n        if (root.left == null && root.right == null) {\r\n            ans.add(root.data);\r\n            return;\r\n        }\r\n\r\n        leafNodes(root.left, ans);\r\n        leafNodes(root.right, ans);\r\n    }\r\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "python",
                "full_func": "'''\n    Time Complexity: O(N)\n    Space Complexity: O(N)\n\n    Where N is the number of nodes in the Binary Tree.\n'''\n\nfrom queue import Queue\n\n# Binary tree node class for reference.\nclass BinaryTreeNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\ndef leftBoundary(root, ans):\n    if(root == None or (root.left == None and root.right == None)):\n        return\n\n    ans.append(root.data)\n\n    if(root.left != None):\n        leftBoundary(root.left, ans)\n    else:\n        leftBoundary(root.right, ans)\n\n\ndef rightBoundary(root, ans):\n    if(root == None or (root.left == None and root.right == None)):\n        return\n\n    if(root.right != None):\n        rightBoundary(root.right, ans)\n    else:\n        rightBoundary(root.left, ans)\n\n    ans.append(root.data)\n\n\ndef leafNodes(root, ans):\n    if(root == None):\n        return\n\n    if(root.left == None and root.right == None):\n        ans.append(root.data)\n        return\n\n    leafNodes(root.left, ans)\n    leafNodes(root.right, ans)\n\n# Functions to traverse on each part.\ndef traverseBoundary(root):\n    ans = []\n\n    if(root == None):\n        return ans\n\n    ans.append(root.data)\n\n    # Traverse left boundary.\n    leftBoundary(root.left, ans)\n\n    # Traverse for leaf nodes.\n    leafNodes(root.left, ans)\n    leafNodes(root.right, ans)\n\n    # Traverse right boundary.\n    rightBoundary(root.right, ans)\n\n    return ans",
                "lang_text": "py"
            }
        },
        "platform": "CODESTUDIO"
    }
}