{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 10139,
            "title": "Deque",
            "titleSlug": "deque_1170059",
            "content": "<h4 id=\"design-a-data-structure-to-implement-deque-of-size-n-it-should-support-the-following-operations\">Design a data structure to implement deque of size \u2018N\u2019. It should support the following operations:</h4>\n\n<pre><code>pushFront(X): Inserts an element X in the front of the deque. Returns true if the element is inserted, otherwise false.\n\npushRear(X): Inserts an element X in the back of the deque. Returns true if the element is inserted, otherwise false.\n\npopFront(): Pops an element from the front of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.\n\npopRear(): Pops an element from the back of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.\n\ngetFront(): Returns the first element of the deque. If the deque is empty, it returns -1.\n\ngetRear(): Returns the last element of the deque. If the deque is empty, it returns -1.\n\nisEmpty(): Returns true if the deque is empty, otherwise false.\n\nisFull(): Returns true if the deque is full, otherwise false.\n</code></pre>\n\n<h4 id=\"following-types-of-queries-denote-these-operations\">Following types of queries denote these operations:</h4>\n\n<pre><code>Type 1: for pushFront(X) operation.\nType 2: for pushRear(X) operation.\nType 3: for popFront() operation.\nType 4: for popRear() operation.\nType 5: for getFront() operation.\nType 6: for getRear() operation.\nType 7: for isEmpty() operation.\nType 8: for isFull() operation.\n</code></pre>\n\n<h5 id=\"input-format\">Input format:</h5>\n\n<pre><code>The first line of input contains two space-separated integers \u2018N\u2019 and \u2018Q\u2019 denoting the size of the deque and the number of queries to be performed, respectively. \n\nThe next \u2018Q\u2019 lines specify the type of operation/query to be performed on the data structure.\n\nEach query contains an integer \u2018P\u2019 denoting the type of query.\n\nFor the query of type 1 and 2, the integer \u2018P\u2019 is followed by a single integer \u2018X\u2019 denoting the element on which operation is to be performed.\n\nFor the queries of type 3 to 8, a single integer \u2018P\u2019 is given, denoting the type of query.\n</code></pre>\n\n<h5 id=\"output-format\">Output format:</h5>\n\n<pre><code>For each query, print the output returned after performing the corresponding operation on the data structure. \n</code></pre>\n\n<h5 id=\"note\">Note:</h5>\n\n<pre><code>You do not need to print anything, it has already been taken care of. Just implement the given functions.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints:</h5>\n\n<pre><code>1 &lt;= N &lt;= 1000\n1 &lt;= Q &lt;= 10^5 \n1 &lt;= P &lt;= 8\n1 &lt;= X &lt;= 10^5\n\nTime Limit: 1 sec\n\nWhere \u2018N\u2019 represents the size of the deque, \u2018Q\u2019 represents the number of queries, \u2018P\u2019 represents the type of operation and \u2018X\u2019 represents the element.\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1:</h5>\n\n<pre><code>5 7\n7\n1 10\n1 20\n2 30\n5\n4\n4\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1:</h5>\n\n<pre><code>True \nTrue \nTrue\nTrue\n20\n30\n10\n</code></pre>\n\n<h5 id=\"explanation-1\">Explanation 1:</h5>\n\n<pre><code>For the given input, we have the number of queries, Q = 7.\nOperations performed on the deque are as follows:\n\nisEmpty(): Deque is initially empty. So, this returns true.\npushFront(10): Insert the element \u201810\u2019 in the front of the deque. This returns true.\npushFront(20): Insert the element \u201820\u2019 in the front of the deque. This returns true.\npushRear(30): Insert the element \u201830\u2019 in the back of the deque. This returns true.\ngetFront(): Returns the front element of the deque i.e. 20\npopRear(): Pop an element from the back of the deque. This returns 30.\npopRear(): Pop an element from the back of the deque. This returns 10.\n\nThe following image shows the snapshots of the deque after each operation:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/10139-sample-1-7965.PNG\" alt=\"Deque Snapshot\"></p>\n\n<h5 id=\"sample-input-2\">Sample Input 2:</h5>\n\n<pre><code>2 5\n1 15\n2 25\n1 20\n8\n6\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2:</h5>\n\n<pre><code>True\nTrue\nFalse\nTrue\n25\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": 127,
            "dislikes": "NA",
            "rephrased": {
                "body": "Design a data structure to implement a deque of size 'N'. The deque should support the following operations:\n\n*   `pushFront(X)`: Inserts an element X at the front of the deque. Returns `true` if insertion is successful, `false` otherwise (deque is full).\n*   `pushRear(X)`: Inserts an element X at the rear of the deque. Returns `true` if insertion is successful, `false` otherwise (deque is full).\n*   `popFront()`: Removes and returns the element at the front of the deque. Returns `-1` if the deque is empty.\n*   `popRear()`: Removes and returns the element at the rear of the deque. Returns `-1` if the deque is empty.\n*   `getFront()`: Returns the element at the front of the deque without removing it. Returns `-1` if the deque is empty.\n*   `getRear()`: Returns the element at the rear of the deque without removing it. Returns `-1` if the deque is empty.\n*   `isEmpty()`: Returns `true` if the deque is empty, `false` otherwise.\n*   `isFull()`: Returns `true` if the deque is full, `false` otherwise.\n\nImplement the deque using the provided query types:\n\n*   `1 X`: `pushFront(X)`\n*   `2 X`: `pushRear(X)`\n*   `3`: `popFront()`\n*   `4`: `popRear()`\n*   `5`: `getFront()`\n*   `6`: `getRear()`\n*   `7`: `isEmpty()`\n*   `8`: `isFull()`",
                "constraints": [
                    "1 <= N <= 1000",
                    "1 <= Q <= 10^5",
                    "1 <= P <= 8",
                    "1 <= X <= 10^5",
                    "Time Limit: 1 sec"
                ],
                "testcases": [
                    {
                        "input": "5 7\n7\n1 10\n1 20\n2 30\n5\n4\n4",
                        "output": "True\nTrue\nTrue\nTrue\n20\n30\n10",
                        "explanation": "Initially, the deque is empty, so isEmpty() returns true. pushFront(10) and pushFront(20) insert 10 and 20 at the front. pushRear(30) inserts 30 at the rear. getFront() returns 20 (the front element). popRear() removes and returns 30, then 10."
                    },
                    {
                        "input": "2 5\n1 15\n2 25\n1 20\n8\n6",
                        "output": "True\nTrue\nFalse\nTrue\n25",
                        "explanation": "pushFront(15) and pushRear(25) are performed, then pushFront(20) returns false because the deque is full. isFull() returns true. getRear() returns 25."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Try using a circular array to implement the deque.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Stacks & Queues",
                "slug": "stacks-&-queues"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "cpp",
                "full_func": "/*\r\n\tTime complexity: O(1) for all operations.\r\n\tSpace Complexity: O(N)\r\n\t\r\n\tWhere N is the size of the deque.\r\n*/\r\n\r\nclass Deque\r\n{\r\n    vector<int> dq;\r\n    int front, rear;\r\n    int n;\r\n\r\npublic:\r\n    // Initialize your data structure.\r\n    Deque(int size)\r\n    {\r\n        n = size;\r\n        dq = vector<int>(n);\r\n        front = rear = -1;\r\n    }\r\n\r\n    // Pushes 'X' in the front of the deque. Returns true if it gets pushed into the deque, and false otherwise.\r\n    bool pushFront(int x)\r\n    {\r\n        if (isFull() == true)\r\n        {\r\n            // Deque is full.\r\n            return false;\r\n        }\r\n\r\n        if (isEmpty() == true)\r\n        {\r\n            // Deque is empty.\r\n            front = rear = 0;\r\n        }\r\n        else\r\n        {\r\n            // Deque is NOT empty. So, decrement 'front' by 1.\r\n            if (front == 0)\r\n            {\r\n                front = n - 1;\r\n            }\r\n            else\r\n            {\r\n                --front;\r\n            }\r\n        }\r\n\r\n        // Insert the element at the front of deque.\r\n        dq[front] = x;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Pushes 'X' in the back of the deque. Returns true if it gets pushed into the deque, and false otherwise.\r\n    bool pushRear(int x)\r\n    {\r\n        if (isFull() == true)\r\n        {\r\n            // Deque is full.\r\n            return false;\r\n        }\r\n\r\n        if (isEmpty() == true)\r\n        {\r\n            // Deque is empty.\r\n            front = rear = 0;\r\n        }\r\n        else\r\n        {\r\n            // Deque is NOT empty. So, increment 'rear' by 1.\r\n            if (rear == n - 1)\r\n            {\r\n                rear = 0;\r\n            }\r\n            else\r\n            {\r\n                ++rear;\r\n            }\r\n        }\r\n\r\n        // Insert the element at the end of deque.\r\n        dq[rear] = x;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Pops an element from the front of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.\r\n    int popFront()\r\n    {\r\n        if (isEmpty() == true)\r\n        {\r\n            // Deque is empty.\r\n            return -1;\r\n        }\r\n\r\n        int item = dq[front];\r\n\r\n        if (front == rear)\r\n        {\r\n            // Deque has only one element.\r\n            front = rear = -1;\r\n        }\r\n        else\r\n        {\r\n            // Increment 'front' by 1.\r\n            if (front == n - 1)\r\n            {\r\n                front = 0;\r\n            }\r\n            else\r\n            {\r\n                ++front;\r\n            }\r\n        }\r\n\r\n        return item;\r\n    }\r\n\r\n    // Pops an element from the back of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.\r\n    int popRear()\r\n    {\r\n        if (isEmpty() == true)\r\n        {\r\n            // Deque is empty.\r\n            return -1;\r\n        }\r\n\r\n        int item = dq[rear];\r\n\r\n        if (front == rear)\r\n        {\r\n            // Deque has only one element.\r\n            front = rear = -1;\r\n        }\r\n        else\r\n        {\r\n            // Decrement 'rear' by 1.\r\n            if (rear == 0)\r\n            {\r\n                rear = n - 1;\r\n            }\r\n            else\r\n            {\r\n                --rear;\r\n            }\r\n        }\r\n\r\n        return item;\r\n    }\r\n\r\n    // Returns the first element of the deque. If the deque is empty, it returns -1.\r\n    int getFront()\r\n    {\r\n        if (isEmpty() == true)\r\n        {\r\n            // Deque is empty.\r\n            return -1;\r\n        }\r\n\r\n        return dq[front];\r\n    }\r\n\r\n    // Returns the last element of the deque. If the deque is empty, it returns -1.\r\n    int getRear()\r\n    {\r\n        if (isEmpty() == true)\r\n        {\r\n            // Deque is empty.\r\n            return -1;\r\n        }\r\n\r\n        return dq[rear];\r\n    }\r\n\r\n    // Returns true if the deque is empty. Otherwise returns false.\r\n    bool isEmpty()\r\n    {\r\n        if (front == -1)\r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Returns true if the deque is full. Otherwise returns false.\r\n    bool isFull()\r\n    {\r\n        if ((front == 0 && rear == n - 1) || (front == rear + 1))\r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "java",
                "full_func": "import java.util.*;\r\npublic class Deque \r\n{\r\n    int[] dq;\r\n    int front, rear;\r\n    int n;\r\n \r\n    // Initialize your data structure.\r\n    public Deque(int size) \r\n    {\r\n        n = size;\r\n        dq = new int[n];\r\n        front = rear = -1;\r\n    }\r\n\r\n    // Pushes 'X' in the front of the deque. Returns true if it gets pushed into the deque, and false otherwise.\r\n    public boolean pushFront(int x) \r\n    {\r\n        if (isFull() == true)\r\n        {\r\n            // Deque is full.\r\n            return false;\r\n        }\r\n\r\n        if (isEmpty() == true)\r\n        {\r\n            // Deque is empty.\r\n            front = rear = 0;\r\n        }\r\n        else\r\n        {\r\n            // Deque is NOT empty. So, decrement 'front' by 1.\r\n            if (front == 0)\r\n            {\r\n                front = n - 1;\r\n            }\r\n            else\r\n            {\r\n                --front;\r\n            }\r\n        }\r\n\r\n        // Insert the element at the front of deque.\r\n        dq[front] = x;\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Pushes 'X' in the back of the deque. Returns true if it gets pushed into the deque, and false otherwise.\r\n    public boolean pushRear(int x) \r\n    {\r\n        if (isFull() == true)\r\n        {\r\n            // Deque is full.\r\n            return false;\r\n        }\r\n\r\n        if (isEmpty() == true)\r\n        {\r\n            // Deque is empty.\r\n            front = rear = 0;\r\n        }\r\n        else\r\n        {\r\n            // Deque is NOT empty. So, increment 'rear' by 1.\r\n            if (rear == n - 1)\r\n            {\r\n                rear = 0;\r\n            }\r\n            else\r\n            {\r\n                ++rear;\r\n            }\r\n        }\r\n\r\n        // Insert the element at the end of deque.\r\n        dq[rear] = x;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Pops an element from the front of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.\r\n    public int popFront() \r\n    {\r\n        if (isEmpty() == true)\r\n        {\r\n            // Deque is empty.\r\n            return -1;\r\n        }\r\n\r\n        int item = dq[front];\r\n\r\n        if (front == rear)\r\n        {\r\n            // Deque has only one element.\r\n            front = rear = -1;\r\n        }\r\n        else\r\n        {\r\n            // Increment 'front' by 1.\r\n            if (front == n - 1)\r\n            {\r\n                front = 0;\r\n            }\r\n            else\r\n            {\r\n                ++front;\r\n            }\r\n        }\r\n\r\n        return item;\r\n    }\r\n\r\n    // Pops an element from the back of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.\r\n    public int popRear() \r\n    {\r\n        if (isEmpty() == true)\r\n        {\r\n            // Deque is empty.\r\n            return -1;\r\n        }\r\n\r\n        int item = dq[rear];\r\n\r\n        if (front == rear)\r\n        {\r\n            // Deque has only one element.\r\n            front = rear = -1;\r\n        }\r\n        else\r\n        {\r\n            // Decrement 'rear' by 1.\r\n            if (rear == 0)\r\n            {\r\n                rear = n - 1;\r\n            }\r\n            else\r\n            {\r\n                rear--;\r\n            }\r\n        }\r\n\r\n        return item;\r\n    }\r\n\r\n    // Returns the first element of the deque. If the deque is empty, it returns -1.\r\n    public int getFront() \r\n    {\r\n        if (isEmpty() == true)\r\n        {\r\n            // Deque is empty.\r\n            return -1;\r\n        }\r\n\r\n        return dq[front];\r\n    }\r\n\r\n    // Returns the last element of the deque. If the deque is empty, it returns -1.\r\n    public int getRear() \r\n    {\r\n         if (isEmpty() == true)\r\n        {\r\n            // Deque is empty.\r\n            return -1;\r\n        }\r\n\r\n        return dq[rear];\r\n    }\r\n    \r\n    // Returns true if the deque is empty. Otherwise returns false.\r\n    public boolean isEmpty() \r\n    {\r\n        if (front == -1)\r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Returns true if the deque is full. Otherwise returns false.\r\n    public boolean isFull() \r\n    {\r\n        if ((front == 0 && rear == n - 1) || (front == rear + 1))\r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "python",
                "full_func": "'''\n    Time complexity: O(1) for all operations.\n\tSpace Complexity: O(N)\n\t\n\tWhere N is the size of the deque.\n'''\n\n\nclass Deque:\n    def __init__(self, size):\n        self.dq = [0 for i in range(size)]\n        self.n = size\n        self.front = -1\n        self.rear = -1\n\n    # Pushes 'X' in the front of the deque. Returns true if it gets pushed into the deque, and false otherwise.\n    def pushFront(self, x):\n        if(self.isFull() == True):\n            # Deque is full.\n            return False\n        if(self.isEmpty() == True):\n            # Deque is empty.\n            self.front = self.rear = 0\n        else:\n            # Deque is NOT empty. So, decrement 'front' by 1.\n            if (self.front == 0):\n                self.front = self.n-1\n            else:\n                self.front -= 1\n\n        # Insert the element at the front of deque.\n        self.dq[self.front] = x\n        return True\n\n    # Pushes 'X' in the back of the deque. Returns true if it gets pushed into the deque, and false otherwise.\n    def pushRear(self, x):\n        if(self.isFull() == True):\n            # Deque is full.\n            return False\n        if(self.isEmpty() == True):\n            # Deque is empty.\n            self.front = self.rear = 0\n        else:\n            # Deque is NOT empty. So, increment 'rear' by 1.\n            if (self.rear == self.n-1):\n                self.rear = 0\n            else:\n                self.rear += 1\n\n        # Insert the element at the end of deque.\n        self.dq[self.rear] = x\n        return True\n\n    # Pops an element from the front of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.\n    def popFront(self):\n        if(self.isEmpty() == True):\n            # Deque is empty.\n            return -1\n\n        item = self.dq[self.front]\n\n        if(self.front == self.rear):\n            # Deque has only one element.\n            self.front = self.rear = -1\n        else:\n            # Increment 'front' by 1.\n            if (self.front == self.n-1):\n                self.front = 0\n            else:\n                self.front += 1\n\n        return item\n\n    # Pops an element from the back of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.\n    def popRear(self):\n        if(self.isEmpty() == True):\n            # Deque is empty.\n            return -1\n\n        item = self.dq[self.rear]\n\n        if(self.front == self.rear):\n            # Deque has only one element.\n            self.front = self.rear = -1\n        else:\n            # Decrement 'rear' by 1.\n            if (self.rear == 0):\n                self.rear = self.n-1\n            else:\n                self.rear -= 1\n\n        return item\n\n    # Returns the first element of the deque. If the deque is empty, it returns -1.\n    def getFront(self):\n        if(self.isEmpty() == True):\n            # Deque is empty.\n            return -1\n        return self.dq[self.front]\n\n    # Returns the last element of the deque. If the deque is empty, it returns -1.\n    def getRear(self):\n        if(self.isEmpty() == True):\n            # Deque is empty.\n            return -1\n        return self.dq[self.rear]\n\n    # Returns true if the deque is empty. Otherwise returns false.\n    def isEmpty(self):\n        if(self.front == -1):\n            return True\n        return False\n\n    # Returns true if the deque is full. Otherwise returns false.\n    def isFull(self):\n        if ((self.front == 0 and self.rear == self.n - 1) or (self.front == self.rear + 1)):\n            return True\n        return False\n",
                "lang_text": "py"
            }
        },
        "platform": "CODESTUDIO"
    }
}