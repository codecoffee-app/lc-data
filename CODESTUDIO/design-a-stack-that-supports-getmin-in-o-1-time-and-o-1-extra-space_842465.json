{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 8265,
            "title": "Design a stack that supports getMin() in O(1) time and O(1) extra space",
            "titleSlug": "design-a-stack-that-supports-getmin-in-o-1-time-and-o-1-extra-space_842465",
            "content": "<h4 id=\"create-a-stack-data-structure-that-allows-operations-such-as-push-adding-an-element-pop-removing-the-top-element-top-retrieving-the-top-element-and-also-provides-a-way-to-retrieve-the-minimum-element-in-constant-time\">Create a stack data structure that allows operations such as push (adding an element), pop (removing the top element), top (retrieving the top element), and also provides a way to retrieve the minimum element in constant time.</h4>\n\n<p><br></p>\n\n<h4 id=\"implement-the-following-public-functions\">Implement the following public functions :</h4>\n\n<pre><code>1. push(data) :\nThis function should take one argument of type integer. It pushes the element into the stack and returns nothing.\n\n2. pop() :\nIt pops the element from the top of the stack and returns nothing.\n\n3. top() :\nIt returns the element being kept at the top of the stack.\n\n4.  getMin() :\nIt returns the smallest element present in the stack.\n</code></pre>\n\n<h5 id=\"operations-performed-on-the-stack\">Operations Performed on the Stack:</h5>\n\n<pre><code>Query-1(Denoted by an integer 1): Pushes integer data to the stack. (push function)\n\nQuery-2(Denoted by an integer 2): Pops the data kept at the top of the stack. (pop function)\n\nQuery-3(Denoted by an integer 3): Fetches and returns the data being kept at the top of the stack. (top function)\n\nQuery-4(Denoted by an integer 4): Returns the smallest element present in the stack. (getMin() function)\n</code></pre>\n\n<h5 id=\"input-format\">Input Format:</h5>\n\n<pre><code>The first line contains an integer &#39;Q\u2019, which denotes the number of queries to be run against each operation in the stack. \n\nThe next &#39;Q&#39; lines represent an operation that needs to be performed.\n\nFor the push operation, the input line will contain two integers separated by a single space, representing the type of the operation in the integer and the integer data being pushed into the stack.\n\nFor the rest of the operations on the stack, the input line will contain only one integer value, representing the query being performed on the stack.\n</code></pre>\n\n<h5 id=\"output-format\">Output Format:</h5>\n\n<pre><code>For Query-1, you do not need to return anything.\n\nFor Query-2, you do not need to return anything.\n\nFor Query-3, print the data kept on the top of the stack.\n\nFor Query-4, print the smallest element present in the stack.\n\nOutput for every query will be printed in a separate line.\n</code></pre>\n\n<h5 id=\"note\">Note:</h5>\n\n<pre><code>You are not required to print anything explicitly. It has already been taken care of. Just implement the function.\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1:</h5>\n\n<pre><code>6\n1 13\n1 47\n3\n1 8\n2\n4\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1:</h5>\n\n<pre><code>47\n13\n</code></pre>\n\n<h5 id=\"explanation-of-input-1\">Explanation of Input 1:</h5>\n\n<pre><code>Here we have six queries in total.\n\nQuery 1: Integer 1 represents the push function. Hence we push element \u201813\u2019 onto the stack.\n\nQuery 2: Integer 1 represents the push function. Hence we push element \u201847\u2019 onto the stack.\n\nQuery 3: Integer 3 represents the top function. Hence we print the top element in stack i.e. &#39;47&#39;.\n\nQuery 4: Integer 1 represents the push function. Hence we push element \u20188\u2019 onto the stack.\n\nQuery 5: Integer 2 represents the pop function. The stack contains element \u20188\u2019 at the top. We remove/pop \u20188\u2019 from the stack and we have 13, 47 left in stack.\n\nQuery 6: Integer 4 represents the getMin function. Hence the min of current stack is &#39;13&#39;.\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2:</h5>\n\n<pre><code>8\n1 45\n2\n1 53\n4\n1 46\n4\n2\n4\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2:</h5>\n\n<pre><code>53\n46\n53\n</code></pre>\n\n<h5 id=\"constraints\">Constraints:</h5>\n\n<pre><code>1 &lt;= &#39;Q&#39; &lt;= 1000\n1 &lt;= query type &lt;= 4\n-10^9 &lt;= data &lt;= 10^9 and data != -1\n\nwhere &#39;Q&#39; is the total number of queries being performed on the stack and &#39;data&#39; represents the integer pushed into the stack.\n\nOperations like pop, top and getMin  will always be called on non-empty stacks.\n\nTime Limit: 1 sec\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 176,
            "dislikes": "NA",
            "rephrased": {
                "body": "Design a stack data structure, `SpecialStack`, that supports the standard stack operations: `push`, `pop`, and `top`, along with an additional operation `getMin` which retrieves the minimum element currently present in the stack, all in constant time. Implement the `SpecialStack` class with the specified methods.",
                "constraints": [
                    "1 <= 'Q' <= 1000, where 'Q' is the total number of queries.",
                    "1 <= query type <= 4",
                    "-10^9 <= data <= 10^9 and data != -1, where 'data' represents the integer pushed into the stack.",
                    "Operations like pop, top, and getMin will always be called on non-empty stacks."
                ],
                "testcases": [
                    {
                        "input": "Q = 6, queries = [[1, 13], [1, 47], [3], [1, 8], [2], [4]]",
                        "output": "47\n13",
                        "explanation": "Initially, the stack is empty.\nQuery 1: push(13), stack: [13]\nQuery 2: push(47), stack: [13, 47]\nQuery 3: top(), returns 47.\nQuery 4: push(8), stack: [13, 47, 8]\nQuery 5: pop(), stack: [13, 47]\nQuery 6: getMin(), returns 13."
                    },
                    {
                        "input": "Q = 8, queries = [[1, 45], [2], [1, 53], [4], [1, 46], [4], [2], [4]]",
                        "output": "53\n46\n53",
                        "explanation": "Initially, the stack is empty.\nQuery 1: push(45), stack: [45]\nQuery 2: pop(), stack: []\nQuery 3: push(53), stack: [53]\nQuery 4: getMin(), returns 53.\nQuery 5: push(46), stack: [53, 46]\nQuery 6: getMin(), returns 46.\nQuery 7: pop(), stack: [53]\nQuery 8: getMin(), returns 53."
                    },
                    {
                        "input": "Q = 5, queries = [[1, 5], [1, 2], [4], [2], [4]]",
                        "output": "2\n5",
                        "explanation": "Initially, stack is empty.\nQuery 1: push(5), stack: [5]\nQuery 2: push(2), stack: [5, 2]\nQuery 3: getMin(), returns 2.\nQuery 4: pop(), stack: [5]\nQuery 5: getMin(), returns 5."
                    },
                    {
                        "input": "Q = 4, queries = [[1, 10], [1, 5], [1, 15], [4]]",
                        "output": "5",
                        "explanation": "Initially, the stack is empty.\nQuery 1: push(10), stack: [10]\nQuery 2: push(5), stack: [10, 5]\nQuery 3: push(15), stack: [10, 5, 15]\nQuery 4: getMin(), returns 5."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Make two stacks</p>",
            "<p>Make two stacks - modified</p>",
            "<p>Can you store the minimum element in an integer variable?</p>"
        ],
        "relatedTopics": [
            {
                "name": "Stacks & Queues",
                "slug": "stacks-&-queues"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "cpp",
                "full_func": "/*\r\n    Time complexity: O(1)\r\n        For push(): O(1) - Constant extra space is required.\r\n        For pop(): O(1) - Constant extra space is required.\r\n        For top(): O(1) - Constant extra space is required.\r\n        For getMin(): O(1) - Constant extra space is required.\r\n        For isEmpty(): O(1) - Constant extra space is required.\r\n\r\n    Space complexity: O(1)\r\n*/\r\n\r\nclass SpecialStack {\r\n    stack<int> s;\r\n    int minEle; // Variable to store the minimum element in the stack.\r\n\r\npublic:\r\n    // Function to push an element onto the stack.\r\n    void push(int data) {\r\n        if (s.empty()) {\r\n            s.push(data);\r\n\r\n            // If the stack is empty, the first element becomes the minimum.\r\n            minEle = data; \r\n        } else {\r\n            if (data >= minEle) {\r\n                s.push(data);\r\n            } else {\r\n                // Push modified value to track previous minimum.\r\n                s.push(2 * data - minEle); \r\n\r\n                // Update the current minimum.\r\n                minEle = data; \r\n            }\r\n        }\r\n    }\r\n\r\n    // Function to pop an element from the stack.\r\n    void pop() {\r\n        int y = s.top();\r\n        s.pop();\r\n\r\n        if (y < minEle) {\r\n            // Restore previous minimum and update current minimum.\r\n            minEle = 2 * minEle - y; \r\n        } \r\n    }\r\n\r\n    // Function to get the top element of the stack.\r\n    int top() {\r\n\r\n        int y = s.top();\r\n\r\n        if (y < minEle) {\r\n            // If the top value is less than the current minimum, return the current minimum.\r\n            return minEle; \r\n        } else {\r\n            return y;\r\n        }\r\n    }\r\n\r\n    // Function to check if the stack is empty.\r\n    bool isEmpty() {\r\n        return s.empty();\r\n    }\r\n\r\n    // Function to get the current minimum element in the stack.\r\n    int getMin() {\r\n        return minEle;\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "java",
                "full_func": "/*\r\n    Time complexity: O(1)\r\n        For push(): O(1) - Constant extra space is required.\r\n        For pop(): O(1) - Constant extra space is required.\r\n        For top(): O(1) - Constant extra space is required.\r\n        For getMin(): O(1) - Constant extra space is required.\r\n        For isEmpty(): O(1) - Constant extra space is required.\r\n\r\n    Space complexity: O(1)\r\n*/\r\n\r\n\r\nimport java.util.Stack;\r\n\r\npublic class Solution {\r\n    static class SpecialStack {\r\n\r\n        // Two stacks, s1 is the main stack, and s2 stores the minimum elements.\r\n        Stack<Integer> s = new Stack<>();\r\n        int minEle; // Variable to store the minimum element in the stack.\r\n\r\n\r\n        // Function to push an element onto the stack.\r\n        void push(int data) {\r\n            if (s.isEmpty()) {\r\n                s.add(data);\r\n\r\n                // If the stack is empty, the first element becomes the minimum.\r\n                minEle = data;\r\n            } else {\r\n                if (data >= minEle) {\r\n                    s.add(data);\r\n                } else {\r\n                    // Push modified value to track previous minimum.\r\n                    s.add(2 * data - minEle);\r\n\r\n                    // Update the current minimum.\r\n                    minEle = data;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Function to pop an element from the stack.\r\n        void pop() {\r\n            int y = s.peek();\r\n            s.pop();\r\n\r\n            if (y < minEle) {\r\n                // Restore previous minimum and update current minimum.\r\n                minEle = 2 * minEle - y;\r\n            }\r\n        }\r\n\r\n        // Function to get the top element of the stack.\r\n        int top() {\r\n            int y = s.peek();\r\n\r\n            if (y < minEle) {\r\n                // If the top value is less than the current minimum, return the current minimum.\r\n                return minEle;\r\n            } else {\r\n                return y;\r\n            }\r\n        }\r\n\r\n        int getMin() {\r\n            // Return the top element of the minimum stack s2, which contains the minimum element.\r\n            return minEle;\r\n        }\r\n\r\n        // Function to check if the stack is empty.\r\n        boolean isEmpty() {\r\n            return s.isEmpty();\r\n        }\r\n\r\n    };\r\n}\r\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "python",
                "full_func": "'''\r\n    Time complexity: O(1)\r\n        For push(): O(1) - Constant extra space is required.\r\n        For pop(): O(1) - Constant extra space is required.\r\n        For top(): O(1) - Constant extra space is required.\r\n        For getMin(): O(1) - Constant extra space is required.\r\n        For isEmpty(): O(1) - Constant extra space is required.\r\n\r\n    Space complexity: O(1)\r\n'''\r\nimport sys\r\nfrom typing import List\r\n\r\nclass SpecialStack:\r\n    \"\"\"\r\n    A special stack implementation that supports getting the minimum element in O(1) time.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize the SpecialStack with a stack and a variable to track the minimum element.\r\n        \"\"\"\r\n        self.s = []\r\n        self.min_ele = None\r\n\r\n    def push(self, data: int) -> None:\r\n        \"\"\"\r\n        Push an element onto the stack.\r\n\r\n        Args:\r\n            data (int): The element to be pushed onto the stack.\r\n        \"\"\"\r\n        if not self.s:\r\n            self.s.append(data)\r\n            self.min_ele = data\r\n        else:\r\n            if data >= self.min_ele:\r\n                self.s.append(data)\r\n            else:\r\n                # Push modified value to track previous minimum.\r\n                self.s.append(2 * data - self.min_ele)\r\n                # Update the current minimum.\r\n                self.min_ele = data\r\n\r\n    def pop(self) -> None:\r\n        \"\"\"Pop an element from the stack.\"\"\"\r\n        if self.s:\r\n            y = self.s.pop()\r\n            if y < self.min_ele:\r\n                # Restore previous minimum and update current minimum.\r\n                self.min_ele = 2 * self.min_ele - y\r\n\r\n    def top(self) -> int:\r\n        \"\"\"\r\n        Get the top element of the stack.\r\n\r\n        Returns:\r\n            int: The top element of the stack.\r\n        \"\"\"\r\n        if self.s:\r\n            y = self.s[-1]\r\n            if y < self.min_ele:\r\n                # If the top value is less than the current minimum, return the current minimum.\r\n                return self.min_ele\r\n            else:\r\n                return y\r\n        else:\r\n            return -sys.maxsize\r\n\r\n    def is_empty(self) -> bool:\r\n        \"\"\"\r\n        Check if the stack is empty.\r\n\r\n        Returns:\r\n            bool: True if the stack is empty, False otherwise.\r\n        \"\"\"\r\n        return not self.s\r\n\r\n    def get_min(self) -> int:\r\n        \"\"\"\r\n        Get the current minimum element in the stack.\r\n\r\n        Returns:\r\n            int: The minimum element in the stack.\r\n        \"\"\"\r\n        return self.min_ele\r\n",
                "lang_text": "py"
            }
        },
        "platform": "CODESTUDIO"
    }
}