{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 10569,
            "title": "Flip equivalent binary tree.",
            "titleSlug": "flip-equivalent-binary-tree_1234687",
            "content": "<h4 id=\"you-have-been-given-the-root-of-two-binary-trees-root1-and-root2-you-need-to-find-if-the-two-trees-are-flip-equivalent-or-not-after-performing-some-flip-operations-on-tree1\">You have been given the root of two binary trees \u2018ROOT1\u2019 and \u2018ROOT2\u2019. You need to find if the two trees are flip equivalent or not after performing some flip operations on \u2018TREE1\u2019.</h4>\n\n<h4 id=\"a-flip-operation-is-defined-as-choose-any-node-and-swap-the-left-and-right-subtrees-of-that-node\">A flip operation is defined as: Choose any node and swap the left and right subtrees of that node.</h4>\n\n<h5 id=\"note\">Note:</h5>\n\n<pre><code>All the values of the tree are unique.\n</code></pre>\n\n<h5 id=\"for-example\">For Example:</h5>\n\n<pre><code>For the given binary trees\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/screenshot-8-8306.png\" alt=\"binarytree\"></p>\n\n<pre><code>Tree 1 can be made flip equivalent to Tree 2 by flipping the left and right sub trees of the node with value = 2. \n</code></pre>\n\n<h5 id=\"input-format\">Input Format:</h5>\n\n<pre><code>The first line contains an integer &#39;T&#39; which denotes the number of test cases. Then the test cases are as follows.\n\nThe first and second line of each test case contains elements of the tree in the level order form. The line consists of values of nodes separated by a single space. In case a node is null, we take -1 in its place.\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/graph-input-format-2-8282.png\" alt=\"tree\"></p>\n\n<pre><code>For example, the input for the tree depicted in the above image would be :\n\n1\n2 3\n4 -1 5 6\n-1 7 -1 -1 -1 -1\n-1 -1\n</code></pre>\n\n<h4 id=\"explanation\">Explanation :</h4>\n\n<pre><code>Level 1 :\nThe root node of the tree is 1\n\nLevel 2 :\nLeft child of 1 = 2\nRight child of 1 = 3\n\nLevel 3 :\nLeft child of 2 = 4\nRight child of 2 = null (-1)\nLeft child of 3 = 5\nRight child of 3 = 6\n\nLevel 4 :\nLeft child of 4 = null (-1)\nRight child of 4 = 7\nLeft child of 5 = null (-1)\nRight child of 5 = null (-1)\nLeft child of 6 = null (-1)\nRight child of 6 = null (-1)\n\nLevel 5 :\nLeft child of 7 = null (-1)\nRight child of 7 = null (-1)\n</code></pre>\n\n<h5 id=\"note\">Note:</h5>\n\n<pre><code>The above format was just to provide clarity on how the input is formed for a given tree. \nThe sequence will be put together in a single line separated by a single space. Hence, for the above-depicted tree, the input will be given as:\n\n1 2 3 4 -1 5 6 -1 7 -1 -1 -1 -1 -1 -1\n</code></pre>\n\n<h5 id=\"output-format\">Output Format:</h5>\n\n<pre><code>For each test, print \u201cYes\u201d if the two trees are flip equivalent. Otherwise, print \u201cNo\u201d.\n\nPrint the output of each test case in a separate line.\n</code></pre>\n\n<h5 id=\"note\">Note:</h5>\n\n<pre><code>You do not need to print anything, it has already been taken care of. Just implement the given function.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints:</h5>\n\n<pre><code>1 &lt;= T &lt;= 50\n0 &lt;= N &lt;= 10^3\n1 &lt;= DATA &lt;= 10^4\n\nWhere \u2018N\u2019 is the total number of nodes in the binary tree, and \u201cDATA\u201d is the value of the binary tree node.\n\nTime Limit: 1 sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1:</h5>\n\n<pre><code>2\n7 9 13 8 -1 4 2 -1 -1 -1 -1 -1 -1\n7 13 9 2 4 8 -1 -1 -1 -1 -1 -1 -1\n14 2 -1 5 -1 -1 -1\n16 -1 2 5 -1 -1 -1\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1:</h5>\n\n<pre><code>Yes\nNo\n</code></pre>\n\n<h5 id=\"explanation-of-sample-input-1\">Explanation Of Sample Input 1:</h5>\n\n<pre><code>Test Case 1: The binary tree in the first test case will be\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/screenshot-10-8307.png\" alt=\"Tree\">          </p>\n\n<pre><code>If we flip left and right subtrees of Tree1 having node values 7 and 13, the resulting tree will become equivalent to Tree2. Therefore given two trees are flip equivalent.\n\nTest Case 2: As the value of the root node in both the trees are different. So they can never be flip equivalent to each other.\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2:</h5>\n\n<pre><code>2\n8 21 17 -1 -1 -1 -1\n8 21 -1 17 -1 -1 -1\n5 10 -1 15 -1 -1 -1\n5 -1 10 15 -1 -1 -1\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2:</h5>\n\n<pre><code>No\nYes  \n</code></pre>\n\n<h5 id=\"explanation-of-sample-input-2\">Explanation Of Sample Input 2:</h5>\n\n<pre><code>Test Case 1: As the left subtree and right subtree of the root node in both the trees are different. So they can never be flip equivalent to each other.\n\nTest Case 2: If we flip right subtree of Tree1 to left subtree of root node, the resulting tree will become equivalent to Tree2. Therefore given two trees are flip equivalent.\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 5,
            "dislikes": "NA",
            "rephrased": {
                "body": "Given the roots of two binary trees, `root1` and `root2`, determine if they are flip-equivalent. Two trees are flip-equivalent if we can make `root1` identical to `root2` by performing any number of 'flip' operations. A flip operation on a node swaps its left and right subtrees. The values of all nodes in the trees are guaranteed to be unique.",
                "constraints": [
                    "1 <= T <= 50",
                    "0 <= N <= 10^3",
                    "1 <= DATA <= 10^4"
                ],
                "testcases": [
                    {
                        "input": "root1 = [7, 9, 13, 8, null, 4, 2, null, null, null, null, null, null], root2 = [7, 13, 9, 2, 4, 8, null, null, null, null, null, null, null]",
                        "output": "Yes",
                        "explanation": "Flipping the left and right subtrees of Tree1 with node values 7 and 13 makes it equivalent to Tree2."
                    },
                    {
                        "input": "root1 = [14, 2, null, 5, null, null, null], root2 = [16, null, 2, 5, null, null, null]",
                        "output": "No",
                        "explanation": "The root node values of the two trees are different, so they cannot be flip-equivalent."
                    },
                    {
                        "input": "root1 = [8, 21, 17, null, null, null, null], root2 = [8, 21, null, 17, null, null, null]",
                        "output": "No",
                        "explanation": "The left and right subtrees of the root node are different in both trees, and no single flip can make them equivalent in this example."
                    },
                    {
                        "input": "root1 = [5, 10, null, 15, null, null, null], root2 = [5, null, 10, 15, null, null, null]",
                        "output": "Yes",
                        "explanation": "Flipping the right subtree (10, 15, null, null, null) of Tree1 makes it equivalent to Tree2."
                    },
                    {
                        "input": "root1 = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15], root2 = [1,3,2,7,6,5,4,15,14,13,12,11,10,9,8]",
                        "output": "Yes",
                        "explanation": "Multiple flips are needed to transform root1 to root2."
                    },
                    {
                        "input": "root1 = [1], root2 = [2]",
                        "output": "No",
                        "explanation": "The root values are different."
                    },
                    {
                        "input": "root1 = [1], root2 = [1]",
                        "output": "Yes",
                        "explanation": "Trees are identical"
                    },
                    {
                        "input": "root1 = [1,2], root2 = [1,null,2]",
                        "output": "No",
                        "explanation": "Structures don't match even considering flipping."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Recursively check for every node of the tree.</p>",
            "<p>Can you think of traversing in depth to check for the entire subtree matching?</p>"
        ],
        "relatedTopics": [
            {
                "name": "Binary Trees",
                "slug": "binary-trees"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Recursion",
                "slug": "recursion"
            }
        ],
        "solutions": {},
        "platform": "CODESTUDIO"
    }
}