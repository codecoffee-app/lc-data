{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 9452,
            "title": "Fruits and Baskets",
            "titleSlug": "fruits-and-baskets_985356",
            "content": "<h4 id=\"there-are-n-fruit-trees-that-are-planted-along-a-road-the-trees-are-numbered-from-0-to-n-1-the-type-of-fruit-each-tree-bears-is-represented-by-an-integer-from-1-to-n\">There are <em><strong>\u2018n\u2019</strong></em> fruit trees that are planted along a road. The trees are numbered from 0 to n-1. The type of fruit each tree bears is represented by an integer from 1 to &#39;n&#39;.</h4>\n\n<p><br></p>\n\n<h4 id=\"a-ninja-is-walking-along-that-road-he-has-two-baskets-and-wants-to-put-the-maximum-number-of-fruits-in-them-the-restriction-is-that-each-basket-can-have-only-one-type-of-fruit\">A Ninja is walking along that road. He has two baskets and wants to put the maximum number of fruits in them. The restriction is that each basket can have only one type of fruit.</h4>\n\n<p><br></p>\n\n<h4 id=\"ninja-can-start-with-any-tree-and-end-at-any-tree-but-once-he-has-started-he-cannot-skip-a-tree-i-e-if-he-picks-fruit-from-the-tree-i-then-he-has-to-pick-fruit-from-tree-i-1-before-going-to-the-tree-i-2-he-will-pick-one-fruit-from-each-tree-until-he-cannot-i-e-he-will-stop-when-he-has-to-pick-a-fruit-of-the-third-type-because-only-two-different-fruits-can-fill-both-baskets\">Ninja can start with any tree and end at any tree, but once he has started, he cannot skip a tree i.e if he picks fruit from the tree <em><strong>\u2018i\u2019</strong></em>, then he has to pick fruit from tree \u2018i+1\u2019 before going to the tree \u2018i+2\u2019. He will pick one fruit from each tree until he cannot, i.e, he will stop when he has to pick a fruit of the third type because only two different fruits can fill both baskets.</h4>\n\n<p><br></p>\n\n<h4 id=\"you-are-given-an-array-arr-the-i-th-integer-in-this-array-represents-the-type-of-fruit-tree-i-bears-return-the-maximum-number-of-fruits-ninja-can-put-in-both-baskets-after-satisfying-all-the-conditions\">You are given an array <em><strong>\u2018arr\u2019</strong></em>. The \u2018i\u2019th integer in this array represents the type of fruit tree \u2018i\u2019 bears. Return the maximum number of fruits Ninja can put in both baskets after satisfying all the conditions.</h4>\n\n<p><br></p>\n\n<h5 id=\"for-example\">For Example:</h5>\n\n<pre><code> &#39;arr&#39; = [1, 2, 3]\n\n Here, we have three different types of fruits. We can pick [1, 2] or [2, 3]. We can pick a maximum of two fruits.\n\nHence, we return 2.\n</code></pre>\n\n<h5 id=\"input-format\">Input format:</h5>\n\n<pre><code>The first line contains an integer \u2018n\u2019 representing the number of trees.\n\nThe second line has \u2018n\u2019 elements of array &#39;arr&#39; that represent the type of fruit in each tree.\n</code></pre>\n\n<h5 id=\"output-format\">Output format :</h5>\n\n<pre><code>Output is the maximum number of fruits Ninja can put in both baskets after satisfying all the conditions.\n</code></pre>\n\n<h5 id=\"note\">Note:</h5>\n\n<pre><code>You do not need to print anything. It has already been taken care of. Just implement the given function.\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1:</h5>\n\n<pre><code>4\n1 1 2 3\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1:</h5>\n\n<pre><code>3 \n</code></pre>\n\n<h5 id=\"explanation-of-sample-input-1\">Explanation of Sample Input 1:</h5>\n\n<pre><code>There are four trees and the type of fruits in them are 1, 1, 2, 3 respectively.\n\nOne way is that Ninja can start picking fruits from tree 0. He picks one fruit from tree 0 and put it in the first basket, then he picks one fruit from tree 1 and put it in the first basket, then he picks one fruit from tree 2 and put it in the second basket, he cannot pick fruit from tree 3 because the first basket has the fruit of type 1 and second has the fruit of type 2 and type of fruit in tree-3 is 3. \n\nThus he has to stop there. The number of fruits he picks in this way is 3. We can show that this is the maximum possible number of fruits ninjas can pick.\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2:</h5>\n\n<pre><code>4\n1 2 3 4\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2:</h5>\n\n<pre><code>2\n</code></pre>\n\n<h5 id=\"explanation-of-sample-input-2\">Explanation of Sample Input 2:</h5>\n\n<pre><code>There are four trees, and each of them has different types of fruit. No matter from which tree Ninja starts picking fruits he can only collect 2 fruits.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints:</h5>\n\n<pre><code>1 &lt;= n &lt;= 10^4\n1 &lt;= arr[I] &lt;= n\nWhere \u2018n\u2019 represents the number of trees.\n\n\nTime limit: 1 sec\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": 129,
            "dislikes": "NA",
            "rephrased": {
                "body": "A ninja is walking along a road with 'n' fruit trees. Each tree bears a specific type of fruit, represented by integers from 1 to 'n'. The ninja has two baskets, each of which can hold only one type of fruit.  The ninja wants to maximize the number of fruits collected, starting from any tree and proceeding sequentially. The ninja cannot skip trees; if they pick from tree 'i', they must pick from tree 'i+1' before 'i+2'. The ninja stops when encountering a third fruit type. Given an array 'arr' where arr[i] is the fruit type of tree 'i', determine the maximum number of fruits the ninja can collect.",
                "constraints": [
                    "1 <= n <= 10^4",
                    "1 <= arr[i] <= n",
                    "Where \u2018n\u2019 represents the number of trees.",
                    "Time limit: 1 sec"
                ],
                "testcases": [
                    {
                        "input": "4\n1 1 2 3",
                        "output": "3",
                        "explanation": "The ninja can start picking fruits from tree 0. They pick type 1 (tree 0), type 1 (tree 1), and type 2 (tree 2). They cannot pick from tree 3 as it's a different type (3) and they already have two types in their baskets. Thus, they collect 3 fruits."
                    },
                    {
                        "input": "4\n1 2 3 4",
                        "output": "2",
                        "explanation": "Since all trees have different fruit types, the ninja can only pick a maximum of two fruits, regardless of the starting point."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>The problem is the same as finding the maximum length of the substring that has at most two different elements.</p>",
            "<p>Can we use the sliding window technique to optimize run time?</p>"
        ],
        "relatedTopics": [
            {
                "name": "Strings",
                "slug": "strings"
            }
        ],
        "solutions": [
            {
                "lang": "cpp",
                "full_func": "/*\r\n    Time complexity: O(n)\r\n    Space complexity: O(c)\r\n\r\n    Where 'n' is the number of fruit trees and 'c' is constant.\r\n*/\r\n\r\n#include <unordered_map>\r\n\r\nint findMaxFruits(vector<int> &arr, int n) {\r\n    // Start and End of sliding window\r\n    int start = 0, end = 0;\r\n    int maxFruits = 0;\r\n\r\n    // Contain unique elements in the current window mapped with their frequency in that window\r\n    unordered_map<int, int> elements;\r\n\r\n    // Finding maximum length of array having atmost 2 distinct element.\r\n    while (end < n) {\r\n        if (elements.count(arr[end]) or elements.size() < 2) {\r\n            elements[arr[end]]++;\r\n            end++;\r\n            maxFruits = max(maxFruits, end - start);\r\n        }\r\n        else {\r\n            elements[arr[start]]--;\r\n            if (elements[arr[start]] == 0) {\r\n                elements.erase(arr[start]);\r\n            }\r\n            start++;\r\n        }\r\n    }\r\n\r\n    return maxFruits;\r\n}",
                "lang_text": "cpp"
            },
            {
                "lang": "python",
                "full_func": "\"\"\"\r\nTime complexity: O(n)\r\nSpace complexity: O(c)\r\n\r\nWhere 'n' is the number of fruit trees and 'c' is constant.\r\n\"\"\"\r\nfrom typing import List\r\n\r\ndef findMaxFruits(arr: List[int], n:int ) -> int:\r\n\r\n    # Start and End of sliding window\r\n    start = 0\r\n    end = 0\r\n    maxFruits = 0\r\n\r\n    # Contain unique elements in the current window mapped with their frequency in that window\r\n    elements = {}\r\n\r\n    # Finding the maximum length of an array having at most 2 distinct elements.\r\n    while end < len(arr):\r\n        if arr[end] in elements or len(elements) < 2:\r\n            elements[arr[end]] = elements.get(arr[end], 0) + 1\r\n            end += 1\r\n            maxFruits = max(maxFruits, end - start)\r\n        else:\r\n            elements[arr[start]] -= 1\r\n            if elements[arr[start]] == 0:\r\n                del elements[arr[start]]\r\n            start += 1\r\n\r\n    return maxFruits\r\n",
                "lang_text": "py"
            },
            {
                "lang": "java",
                "full_func": "/*\r\n    Time complexity: O(n)\r\n    Space complexity: O(c)\r\n\r\n    Where 'n' is the number of fruit trees and 'c' is constant.\r\n*/\r\n\r\nimport java.util.HashMap;\r\npublic class Solution {\r\n    public static int findMaxFruits(int []arr, int n) {\r\n        // Start and End of sliding window\r\n        int start = 0, end = 0;\r\n        int maxFruits = 0;\r\n\r\n        // Contain unique elements in the current window mapped with their frequency in that window\r\n        HashMap<Integer, Integer> elements = new HashMap<>();\r\n\r\n        // Finding maximum length of array having atmost 2 distinct element.\r\n        while (end < n) {\r\n            if (elements.containsKey(arr[end]) || elements.size() < 2) {\r\n                elements.put(arr[end], elements.getOrDefault(arr[end], 0) + 1);\r\n                end++;\r\n                maxFruits = Math.max(maxFruits, end - start);\r\n            }\r\n            else {\r\n                elements.put(arr[start], elements.get(arr[start]) - 1);\r\n                if (elements.get(arr[start]) == 0) {\r\n                    elements.remove(arr[start]);\r\n                }\r\n                start++;\r\n            }\r\n        }\r\n\r\n        return maxFruits;\r\n    }\r\n}",
                "lang_text": "java"
            }
        ],
        "platform": "CODESTUDIO"
    }
}