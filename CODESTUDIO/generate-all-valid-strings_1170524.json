{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 10161,
            "title": "Generate all valid strings",
            "titleSlug": "generate-all-valid-strings_1170524",
            "content": "<h4 id=\"ninja-has-been-given-a-string-str-containing-and-str-may-also-contain-lower-case-alphabets-in-order-to-make-str-valid-ninja-can-remove-either-or-from-str\">Ninja has been given a string \u2018STR\u2019 containing \u2018(\u2018 and \u2018)\u2019. \u2018STR\u2019 may also contain lower case alphabets. In order to make \u2018STR\u2019 valid Ninja can remove either \u2018)\u2019 or \u2018(\u2019 from \u2018STR\u2019.</h4>\n\n<h4 id=\"here-are-some-examples-of-valid-str-a-g-an-empty-string-is-also-a-valid-string\">Here are some examples of valid \u2018STR\u2019 \u201c((a))\u201d, \u201c(g)()\u201d, \u201c(())()\u201d, &quot;&quot; (an empty string is also a valid string).</h4>\n\n<h4 id=\"ninja-wants-to-know-all-the-possible-valid-strings-that-can-be-formed-from-str-by-minimum-possible-removals-possibly-zero\">Ninja wants to know all the possible valid strings that can be formed from \u2018STR\u2019 by minimum possible removals (possibly zero).</h4>\n\n<h4 id=\"can-you-help-ninja-to-generate-all-valid-strings-from-str-by-minimum-removals\">Can you help Ninja to generate all valid strings from \u2018STR\u2019 by minimum removals?</h4>\n\n<h5 id=\"for-example\">For Example :</h5>\n\n<pre><code>For the given \u2018STR\u2019 =  \u201c()(()\u201d, we can form a valid string \u201c()()\u201d by removing \u2018(\u2018 at index 2 or 3.\n</code></pre>\n\n<h5 id=\"input-format\">Input Format :</h5>\n\n<pre><code>The first line of input contains an integer &#39;T&#39; which denotes the number of test cases or queries to be run. Then the test cases follow.\n\nThe first and the only line of each test case contains a string \u2018STR\u2019\n</code></pre>\n\n<h5 id=\"output-format\">Output Format :</h5>\n\n<pre><code>For each test case, print all possible unique valid strings that can be formed from \u2018STR\u2019 in a separate line.\n\nPrint the output of each test case in a separate line.\n</code></pre>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>You do not need to print anything; it has already been taken care of. Just implement the given function.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints :</h5>\n\n<pre><code>1 &lt;= \u2018T\u2019 &lt;= 100\n\u2018STR[i]\u2019 = \u2018(\u2018, \u2018)\u2019 or Lower case english alphabet\n1 &lt;= |STR| &lt;= 2000\n\nWhere |STR| denotes the length of the given string.\n\nTime Limit: 1 sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1 :</h5>\n\n<pre><code>2\n()())\n()(x))()\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1 :</h5>\n\n<pre><code>()() (())\n()(x)() ((x))()\n</code></pre>\n\n<h5 id=\"explanation-for-sample-output-1\">Explanation for Sample Output 1 :</h5>\n\n<pre><code>For the first test case:\nAll the valid unique strings that can be formed from \u201c()())\u201d are \u201c()()\u201d, \u201d()\u201d, \u201d(())\u201d, \u201d \u201d among which \u201c()()\u201d, \u201c(())\u201d are formed from only 1 \u2018)\u2019 removal which is the minimum among all.   \n\nFor the second test case:\nAll the valid unique strings that can be formed from \u201c()(x))()\u201d are \u201c()(x)()\u201d, \u201d()()\u201d, \u201d(())\u201d, \u201d((x))\u201d, \u201d(x)\u201d, \u201d(x)()\u201d, \u201d((x))()\u201d, \u201d \u201d among which \u201d((x))()\u201d and  \u201c()(x)()\u201d are formed from only 1 \u2018)\u2019 removal at index 1 and 5 respectively which takes the minimum removals among all possible valid strings.   \n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2 :</h5>\n\n<pre><code>2   \n))a((\n(()s())\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2 :</h5>\n\n<pre><code>a\n(()s())\n</code></pre>\n\n<h5 id=\"explanation-for-sample-output-2\">Explanation for Sample Output 2 :</h5>\n\n<pre><code>For the first test case:\nAll the valid unique strings that can be formed from \u201c))a((\u201d are \u201ca\u201d and \u201c\u201d (empty string is also a valid string) in which \u201ca\u201d is formed from 2 \u2018)\u2019 removals at index 0 and 1 and 2 \u2018(\u2019 removal at index 3 and 4. which is the minimum among all possible valid strings.   \n\nFor the second test case:\nAll the valid unique strings that can be formed from \u201c (()s())\u201d are \u201c()(s)()\u201d, \u201d((())\u201d, \u201d(s)\u201d, \u201d(()s)\u201d, \u201d(s())\u201d, \u201d(()s())\u201d, \u201d \u201d, \u201ds\u201d, \u201d((s)), &quot;()s()\u201d among which &quot;(()s())\u201d is formed from 0 removals which is the minimum possible removals.   \n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": 31,
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a string 'STR' consisting of parentheses '(' and ')' and lowercase alphabets, the task is to find all unique valid strings that can be formed from 'STR' by removing the minimum number of parentheses. A valid string follows these rules:  it can be empty, it can contain only lowercase alphabets, or it can have properly balanced parentheses (e.g., \"((a))\", \"(g)()\", \"(())()\").",
                "constraints": [
                    "1 <= T <= 100",
                    "STR[i] = '(', ')' or Lower case english alphabet",
                    "1 <= |STR| <= 2000",
                    "Where |STR| denotes the length of the given string.",
                    "Time Limit: 1 sec"
                ],
                "testcases": [
                    {
                        "input": "()())",
                        "output": "()() (())",
                        "explanation": "The given string is \"()())\". Removing the last ')' results in \"()()\", and removing the first parenthesis at index 0 makes the string valid \"(())\". Both require only one removal, which is minimal."
                    },
                    {
                        "input": "()(x))()",
                        "output": "()(x)() ((x))()",
                        "explanation": "The given string is \"()(x))()\". To obtain valid strings with minimal removals, removing the ')' at index 5 yields \"()(x)()\", while removing the opening parenthesis at index 0 and closing parethesis at index 5 yields \"((x))()\". Both require only one removal, which is minimal."
                    },
                    {
                        "input": "))a((",
                        "output": "a",
                        "explanation": "To make \"))a((\" a valid string, we remove the leading two ')' and trailing two '(', resulting in \"a\". This requires four removals, which is the minimum to create a valid string other than \"\"."
                    },
                    {
                        "input": "(()s())",
                        "output": "(()s())",
                        "explanation": "The input string \"(()s())\" is already a valid string. No removals are needed."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Try to use BFS to generate all valid strings&nbsp;</p>",
            "<p>Try to use DFS to generate all valid strings&nbsp;</p>"
        ],
        "relatedTopics": [
            {
                "name": "Strings",
                "slug": "strings"
            }
        ],
        "solutions": {},
        "platform": "CODESTUDIO"
    }
}