{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 10161,
            "title": "Generate all valid strings",
            "titleSlug": "generate-all-valid-strings_1170524",
            "content": "<h4 id=\"ninja-has-been-given-a-string-str-containing-and-str-may-also-contain-lower-case-alphabets-in-order-to-make-str-valid-ninja-can-remove-either-or-from-str\">Ninja has been given a string \u2018STR\u2019 containing \u2018(\u2018 and \u2018)\u2019. \u2018STR\u2019 may also contain lower case alphabets. In order to make \u2018STR\u2019 valid Ninja can remove either \u2018)\u2019 or \u2018(\u2019 from \u2018STR\u2019.</h4>\n\n<h4 id=\"here-are-some-examples-of-valid-str-a-g-an-empty-string-is-also-a-valid-string\">Here are some examples of valid \u2018STR\u2019 \u201c((a))\u201d, \u201c(g)()\u201d, \u201c(())()\u201d, &quot;&quot; (an empty string is also a valid string).</h4>\n\n<h4 id=\"ninja-wants-to-know-all-the-possible-valid-strings-that-can-be-formed-from-str-by-minimum-possible-removals-possibly-zero\">Ninja wants to know all the possible valid strings that can be formed from \u2018STR\u2019 by minimum possible removals (possibly zero).</h4>\n\n<h4 id=\"can-you-help-ninja-to-generate-all-valid-strings-from-str-by-minimum-removals\">Can you help Ninja to generate all valid strings from \u2018STR\u2019 by minimum removals?</h4>\n\n<h5 id=\"for-example\">For Example :</h5>\n\n<pre><code>For the given \u2018STR\u2019 =  \u201c()(()\u201d, we can form a valid string \u201c()()\u201d by removing \u2018(\u2018 at index 2 or 3.\n</code></pre>\n\n<h5 id=\"input-format\">Input Format :</h5>\n\n<pre><code>The first line of input contains an integer &#39;T&#39; which denotes the number of test cases or queries to be run. Then the test cases follow.\n\nThe first and the only line of each test case contains a string \u2018STR\u2019\n</code></pre>\n\n<h5 id=\"output-format\">Output Format :</h5>\n\n<pre><code>For each test case, print all possible unique valid strings that can be formed from \u2018STR\u2019 in a separate line.\n\nPrint the output of each test case in a separate line.\n</code></pre>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>You do not need to print anything; it has already been taken care of. Just implement the given function.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints :</h5>\n\n<pre><code>1 &lt;= \u2018T\u2019 &lt;= 100\n\u2018STR[i]\u2019 = \u2018(\u2018, \u2018)\u2019 or Lower case english alphabet\n1 &lt;= |STR| &lt;= 2000\n\nWhere |STR| denotes the length of the given string.\n\nTime Limit: 1 sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1 :</h5>\n\n<pre><code>2\n()())\n()(x))()\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1 :</h5>\n\n<pre><code>()() (())\n()(x)() ((x))()\n</code></pre>\n\n<h5 id=\"explanation-for-sample-output-1\">Explanation for Sample Output 1 :</h5>\n\n<pre><code>For the first test case:\nAll the valid unique strings that can be formed from \u201c()())\u201d are \u201c()()\u201d, \u201d()\u201d, \u201d(())\u201d, \u201d \u201d among which \u201c()()\u201d, \u201c(())\u201d are formed from only 1 \u2018)\u2019 removal which is the minimum among all.   \n\nFor the second test case:\nAll the valid unique strings that can be formed from \u201c()(x))()\u201d are \u201c()(x)()\u201d, \u201d()()\u201d, \u201d(())\u201d, \u201d((x))\u201d, \u201d(x)\u201d, \u201d(x)()\u201d, \u201d((x))()\u201d, \u201d \u201d among which \u201d((x))()\u201d and  \u201c()(x)()\u201d are formed from only 1 \u2018)\u2019 removal at index 1 and 5 respectively which takes the minimum removals among all possible valid strings.   \n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2 :</h5>\n\n<pre><code>2   \n))a((\n(()s())\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2 :</h5>\n\n<pre><code>a\n(()s())\n</code></pre>\n\n<h5 id=\"explanation-for-sample-output-2\">Explanation for Sample Output 2 :</h5>\n\n<pre><code>For the first test case:\nAll the valid unique strings that can be formed from \u201c))a((\u201d are \u201ca\u201d and \u201c\u201d (empty string is also a valid string) in which \u201ca\u201d is formed from 2 \u2018)\u2019 removals at index 0 and 1 and 2 \u2018(\u2019 removal at index 3 and 4. which is the minimum among all possible valid strings.   \n\nFor the second test case:\nAll the valid unique strings that can be formed from \u201c (()s())\u201d are \u201c()(s)()\u201d, \u201d((())\u201d, \u201d(s)\u201d, \u201d(()s)\u201d, \u201d(s())\u201d, \u201d(()s())\u201d, \u201d \u201d, \u201ds\u201d, \u201d((s)), &quot;()s()\u201d among which &quot;(()s())\u201d is formed from 0 removals which is the minimum possible removals.   \n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": 31,
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a string `str` containing parentheses '(' and ')' and lowercase English alphabets, determine all possible unique valid strings that can be formed from `str` by removing the minimum number of parentheses. A valid string is defined as one where all parentheses are balanced (e.g., \"(())\", \"(a)()\", \"\" (empty string)). You can only remove '(' or ')' characters.  The order of the output strings does not matter.",
                "constraints": [
                    "1 <= \u2018T\u2019 <= 100",
                    "\u2018STR[i]\u2019 = \u2018(\u2018, \u2018)\u2019 or Lower case english alphabet",
                    "1 <= |STR| <= 2000, where |STR| denotes the length of the given string."
                ],
                "testcases": [
                    {
                        "input": "str = \"()())\"",
                        "output": "()(), (())",
                        "explanation": "The valid strings with the minimum removals are \"()()\" and \"(())\". Removing the last ')' from \"()())\" results in \"()()\", and removing the second ')' results in \"(())\"."
                    },
                    {
                        "input": "str = \"()(x))()\"",
                        "output": "()(x)(), ((x))()",
                        "explanation": "The valid strings with the minimum removals are \"()(x)()\" and \"((x))()\".  These are formed by removing the extra closing parenthesis, one at a time, to maintain validity and minimize removals."
                    },
                    {
                        "input": "str = \"))a((\"",
                        "output": "a",
                        "explanation": "Removing both closing parentheses at the beginning and both opening parentheses at the end gives the valid string \"a\" with the minimum number of removals (4)."
                    },
                    {
                        "input": "str = \"(()s())\"",
                        "output": "(()s())",
                        "explanation": "The input string \"(()s())\" is already a valid string, hence no removals are necessary. The minimum removals is 0, and the resulting valid string is \"(()s())\"."
                    },
                    {
                        "input": "str = \"()(()\"",
                        "output": "()(), (())",
                        "explanation": "The valid strings with the minimum removals are \"()()\" and \"(())\". Removing the '(' at index 2 results in \"()()\", and removing the '(' at index 3 results in \"(())\"."
                    },
                    {
                        "input": "str = \"abc\"",
                        "output": "abc",
                        "explanation": "The input string contains no parentheses. Therefore the original string is a valid string with 0 removals"
                    },
                    {
                        "input": "str = \"\"",
                        "output": "",
                        "explanation": "Empty string is always a valid string, hence the output is empty string."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Try to use BFS to generate all valid strings&nbsp;</p>",
            "<p>Try to use DFS to generate all valid strings&nbsp;</p>"
        ],
        "relatedTopics": [
            {
                "name": "Strings",
                "slug": "strings"
            }
        ],
        "solutions": {},
        "platform": "CODESTUDIO"
    }
}