{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 9574,
            "title": "Implement a phone directory",
            "titleSlug": "implement-a-phone-directory_1062666",
            "content": "<h4 id=\"you-are-given-a-list-array-of-strings-which-denotes-the-contacts-that-exist-in-your-phone-directory-the-search-query-on-a-string-str-which-is-a-query-string-displays-all-the-contacts-which-are-present-in-the-given-directory-with-the-prefix-as-str-one-special-property-of-the-search-function-is-that-when-a-user-searches-for-a-contact-from-the-contact-list-then-suggestions-contacts-with-prefix-as-the-string-entered-so-for-are-shown-after-the-user-enters-each-character\">You are given a list/array of strings which denotes the contacts that exist in your phone directory. The search query on a string \u2018str\u2019 which is a query string displays all the contacts which are present in the given directory with the prefix as \u2018str\u2019. One special property of the search function is that when a user searches for a contact from the contact list then suggestions (contacts with prefix as the string entered so for) are shown after the user enters each character.</h4>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>If no suggestions are found, return an empty 2D array.\n</code></pre>\n\n<h5 id=\"for-example\">For Example :</h5>\n\n<p><img src=\"https://files.codingninjas.in/auto_complete-6792.jpg\" alt=\"alt text\"></p>\n\n<pre><code>In the above example everytime we enter a character, a few suggestions display the strings which contain the entered string as prefixes.\n</code></pre>\n\n<h5 id=\"input-format\">Input format :</h5>\n\n<pre><code>The first line contains a single integer \u2018T\u2019 denoting the number of test cases.\n\nThe first line of each test case contains a single integer \u2018N\u2019 denoting the number of elements in the array/list.\n\nThe second line contains \u2018N\u2019 single space-separated strings denoting the contacts of the given array/list or contact list.\n\nThe third line contains a single string denoting the query string.\n</code></pre>\n\n<h5 id=\"output-format\">Output format :</h5>\n\n<pre><code>For each test case, for the given query string you need to print all the possible contacts or suggestions that are present in the given directory corresponding to each entered character in the given query string. \nIf no suggestions are found then the message \u201cNo suggestions found\u201d is printed.\n</code></pre>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>You do not need to print anything; It has already been taken care of.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints :</h5>\n\n<pre><code>1 &lt;= T &lt;= 50\n1 &lt;= N &lt;= 100\n1 &lt;= len &lt;= 10\nARR[i] contains lowercase English alphabets.\n\nAll the given strings contain lowercase English alphabets.\n\nTime Limit: 1 sec.\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1 :</h5>\n\n<pre><code>2\n5\ncod coding codding code coly\ncoding\n2\nninjas coding\nninja\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1 :</h5>\n\n<pre><code>cod coding codding code coly\ncod coding codding code coly\ncod coding codding code coly\ncoding\ncoding\ncoding\nninjas\nninjas\nninjas\nninjas\nninjas\n</code></pre>\n\n<h5 id=\"explanation-to-sample-input-1\">Explanation to Sample Input 1 :</h5>\n\n<pre><code>In the first test case, \nThe suggestions for \u201cc\u201d is {\u201ccod\u201d, \u201ccoding\u201d, \u201ccodding\u201d, \u201ccode\u201d, \u201ccoly\u201d}.\nThe suggestions for \u201cco\u201d is {\u201ccod\u201d, \u201ccoding\u201d, \u201ccodding\u201d, \u201ccode\u201d, \u201ccoly\u201d}.\nThe suggestions for \u201ccod\u201d is {\u201ccod\u201d, \u201ccoding\u201d, \u201ccodding\u201d, \u201ccode\u201d, \u201ccoly\u201d}.\nThe suggestion for \u201ccodi\u201d is {\u201ccoding\u201d}.\nThe suggestion for \u201ccodin\u201d is {\u201ccoding\u201d}.\nThe suggestion for \u201ccoding\u201d is {\u201ccoding\u201d}.\n\nIn the second test case, \nThe suggestion for \u201cn\u201d is {\u201cninjas\u201d}.\nThe suggestion for \u201cni\u201d is {\u201cninjas\u201d}.\nThe suggestion for \u201cnin\u201d is {\u201cninjas\u201d}.\nThe suggestion for \u201cninj\u201d is {\u201cninjas\u201d}.\nThe suggestion for \u201cninja\u201d is {\u201cninjas\u201d}.\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2 :</h5>\n\n<pre><code>3\n2\ncoding ninjas\ncell\n2\nab abc\na\n2\nab abc\nb\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2 :</h5>\n\n<pre><code>coding\nab abc\nNo suggestions found\n</code></pre>\n\n<h5 id=\"explanation-to-sample-input-2\">Explanation to Sample Input 2 :</h5>\n\n<pre><code>In the first test case, \nThe suggestion for \u201cc\u201d is {\u201ccoding\u201d}.\nFor the rest of the letters, there are no suggestions.\n\nIn the second test case,\nThe suggestion for \u201ca\u201d is {\u201cab\u201d, \u201cabc\u201d}.\n\nIn the third test case, no suggestions are found.\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 87,
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a list of contact strings representing a phone directory, implement an auto-complete search functionality. As the user types a query string, provide suggestions from the contact list that have the typed string as a prefix. Display suggestions after each character is entered.\n\nIf no suggestions are found for a given prefix, return an empty array for that prefix.",
                "constraints": [
                    "1 <= T <= 50 (Number of test cases)",
                    "1 <= N <= 100 (Number of contacts in the directory)",
                    "1 <= len <= 10 (Length of each contact string)",
                    "Contacts contain lowercase English alphabets only.",
                    "Query string contains lowercase English alphabets only.",
                    "Time Limit: 1 sec."
                ],
                "testcases": [
                    {
                        "input": "5\ncod coding codding code coly\ncoding",
                        "output": "cod coding codding code coly\ncod coding codding code coly\ncod coding codding code coly\ncoding\ncoding\ncoding",
                        "explanation": "The suggestions for 'c' are {'cod', 'coding', 'codding', 'code', 'coly'}.\nThe suggestions for 'co' are {'cod', 'coding', 'codding', 'code', 'coly'}.\nThe suggestions for 'cod' are {'cod', 'coding', 'codding', 'code', 'coly'}.\nThe suggestion for 'codi' is {'coding'}.\nThe suggestion for 'codin' is {'coding'}.\nThe suggestion for 'coding' is {'coding'}."
                    },
                    {
                        "input": "2\nninjas coding\nninja",
                        "output": "ninjas\nninjas\nninjas\nninjas\nninjas",
                        "explanation": "The suggestion for 'n' is {'ninjas'}.\nThe suggestion for 'ni' is {'ninjas'}.\nThe suggestion for 'nin' is {'ninjas'}.\nThe suggestion for 'ninj' is {'ninjas'}.\nThe suggestion for 'ninja' is {'ninjas'}."
                    },
                    {
                        "input": "2\ncoding ninjas\ncell",
                        "output": "coding",
                        "explanation": "The suggestion for 'c' is {'coding'}.\nFor the rest of the letters, there are no suggestions."
                    },
                    {
                        "input": "2\nab abc\na",
                        "output": "ab abc",
                        "explanation": "The suggestion for 'a' is {'ab', 'abc'}."
                    },
                    {
                        "input": "2\nab abc\nb",
                        "output": "No suggestions found",
                        "explanation": "No suggestions are found."
                    },
                    {
                        "input": "1\nphonebook\nphi",
                        "output": "phonebook\nphonebook\nphonebook",
                        "explanation": "The suggestions for 'p' is {'phonebook'}.\nThe suggestions for 'ph' is {'phonebook'}.\nThe suggestions for 'phi' is {'phonebook'}."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Think of a data structure that can be used to search a string.</p>",
            "<p>Think of a data structure that can be used to search a string.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Strings",
                "slug": "strings"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Tries",
                "slug": "tries"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "cpp",
                "full_func": "/*\r\n    Time Complexity = O(N * (W ^ 2))\r\n    Space Complexity = O(N * W)\r\n    \r\n    Where N is the number of elements in the given array/list and W is the maximum length of a string.\r\n*/\r\n\r\nclass TrieNode\r\n{\r\npublic:\r\n    \r\n    //    Each Trie Node contains a static array 'children' where each alphabet points to a Trie Node.\r\n    TrieNode *children[26];\r\n\r\n    //    'isEnd' is true if the node represents end of a contact.\r\n    bool isEnd;\r\n\r\n    //    Constructor\r\n    TrieNode()\r\n    {\r\n        \r\n        //    Initialize all the Trie nodes with NULL\r\n        for (char i = 'a'; i <= 'z'; i++)\r\n        {\r\n            children[i - 'a'] = NULL;\r\n        }\r\n\r\n        isEnd = false;\r\n    }\r\n    ~TrieNode()\r\n    {\r\n        for (int i = 0; i < 26; i++)\r\n        {\r\n            if (children[i] != NULL)\r\n            {\r\n                delete children[i];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvoid insertContact(string &str, TrieNode *root)\r\n{\r\n    int n = str.length();\r\n\r\n    //    'itr' is used to iterate the Trie Nodes\r\n    TrieNode *itr = root;\r\n\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        \r\n        //    Check if the str[i] is already present in our Trie.\r\n\r\n        TrieNode *next = itr->children[str[i] - 'a'];\r\n\r\n        if (next == NULL)\r\n        {\r\n            \r\n            //   If not found then create a new TrieNode\r\n            next = new TrieNode();\r\n\r\n            //    Insert into the array.\r\n            itr->children[str[i] - 'a'] = next;\r\n        }\r\n\r\n        //    Move the iterator('itr') to point to next Trie Node.\r\n        itr = next;\r\n\r\n        //    If its the last character of the string 'str' then mark 'isEnd' as true\r\n        if (i == n - 1)\r\n        {\r\n            itr->isEnd = true;\r\n        }\r\n    }\r\n}\r\n\r\nvoid viewSuggestionsHelper(TrieNode *curr, string prefix, vector<string> &temp)\r\n{\r\n    \r\n    //    Check if the string 'prefix' ends at this Node If yes then display the string found so far\r\n    if (curr->isEnd)\r\n    {\r\n        temp.push_back(prefix);\r\n    }\r\n\r\n    //    Find all the adjacent Nodes to the current Node and then call the function recursively.\r\n    for (char c = 'a'; c <= 'z'; c++)\r\n    {\r\n        TrieNode *next = curr->children[c - 'a'];\r\n\r\n        if (next != NULL)\r\n        {\r\n            prefix.push_back(c);\r\n            viewSuggestionsHelper(next, prefix, temp);\r\n            prefix.pop_back();\r\n        }\r\n    }\r\n}\r\n\r\nvector<vector<string>> viewSuggestions(string &str, TrieNode *root)\r\n{\r\n    TrieNode *prev = root;\r\n\r\n    string prefix = \"\";\r\n\r\n    int n = str.length();\r\n\r\n    vector<vector<string>> result;\r\n\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        \r\n        //    'prefix' stores the string formed so far.\r\n        prefix.push_back(str[i]);\r\n\r\n        //    Get the last character entered.\r\n        char lastCharacter = prefix[i];\r\n\r\n        //    Find the Node corresponding to the last character of 'prefix' which is pointed by prev of the Trie.\r\n        TrieNode *curr = prev->children[lastCharacter - 'a'];\r\n\r\n        //    If nothing found, then break the loop as no more prefixes are going to be present.\r\n        if (curr == NULL)\r\n        {\r\n            i++;\r\n            break;\r\n        }\r\n\r\n        //    If present in trie then insert all the contacts with given prefix in the result.\r\n        vector<string> temp;\r\n\r\n        viewSuggestionsHelper(curr, prefix, temp);\r\n\r\n        result.push_back(temp);\r\n\r\n        temp.clear();\r\n\r\n        //    Change prev for next prefix\r\n        prev = curr;\r\n    }\r\n\r\n    delete root;\r\n\r\n    return result;\r\n}\r\n\r\nvoid insertContactList(vector<string> &contactList, TrieNode *root)\r\n{\r\n\r\n    int n = contactList.size();\r\n\r\n    //    Insert each contact into the trie.\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        insertContact(contactList[i], root);\r\n    }\r\n}\r\n\r\nvector<vector<string>> phoneDirectory(vector<string> &contactList, string &queryStr)\r\n{\r\n    TrieNode *root = new TrieNode();\r\n\r\n    //    Insert all the Contacts into Trie.\r\n    insertContactList(contactList, root);\r\n\r\n    //    Return the corresponding suggestions.\r\n    return viewSuggestions(queryStr, root);\r\n}",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "java",
                "full_func": "/*\r\n    Time Complexity = O(N*(W^2))\r\n    Space Complexity = O(N*W)\r\n\r\n    Where N is the number of elements in the given array/list and W is the maximum length of a String.\r\n*/\r\n\r\nimport java.util.ArrayList;\r\n\r\nclass TrieNode \r\n{\r\n    //    Each Trie Node contains a static array 'children' where each alphabet points to a Trie Node.\r\n    public TrieNode children[];\r\n\r\n    //    'isEnd' is true if the node represents end of a contact.\r\n    public boolean isEnd;\r\n\r\n    //    Constructor\r\n    TrieNode() \r\n    {\r\n        children = new TrieNode[26];\r\n\r\n        //    Initialize all the Trie nodes with null\r\n        for (char i = 'a'; i <= 'z'; i++) \r\n        {\r\n            children[i - 'a'] = null;\r\n        }\r\n\r\n        isEnd = false;\r\n    }\r\n}\r\n\r\npublic class Solution \r\n{\r\n    private static void insertContact(String str, TrieNode root) \r\n    {\r\n        int n = str.length();\r\n\r\n        //    'itr' is used to iterate the Trie Nodes\r\n        TrieNode itr = root;\r\n\r\n        for (int i = 0; i < n; i++) \r\n        {\r\n        \t\r\n            //    Check if the str[i] is already present in our Trie.\r\n\t\t\tTrieNode next = itr.children[str.charAt(i) - 'a'];\r\n\r\n            if (next == null) \r\n            {\r\n                //   If not found then create a new TrieNode\r\n                next = new TrieNode();\r\n\r\n                //    Insert\r\n                itr.children[str.charAt(i) - 'a'] = next;\r\n            }\r\n\r\n            //    Move the iterator('itr') to point to next Trie Node.\r\n            itr = next;\r\n\r\n            //    If its the last character of the String 'str' then mark 'isEnd' as true\r\n            if (i == n - 1) \r\n            {\r\n                itr.isEnd = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void viewSuggestionsHelper(TrieNode curr, String prefix, ArrayList<String> temp) \r\n    {\r\n    \t\r\n        //    Check if the String 'prefix' ends at this Node If yes then display the String found so far\r\n        if (curr.isEnd) \r\n        {\r\n            temp.add(prefix);\r\n        }\r\n\r\n        //    Find all the adjacent Nodes to the current Node and then call the function recursively.\r\n        for (char c = 'a'; c <= 'z'; c++) \r\n        {\r\n            TrieNode next = curr.children[c - 'a'];\r\n\r\n            if (next != null) \r\n            {\r\n                viewSuggestionsHelper(next, prefix + c, temp);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static ArrayList<ArrayList<String>> viewSuggestions(String str, TrieNode root) \r\n    {\r\n        TrieNode prev = root;\r\n\r\n        StringBuilder prefix = new StringBuilder();\r\n\r\n        int n = str.length();\r\n\r\n        ArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();\r\n\r\n        for (int i = 0; i < n; i++) \r\n        {\r\n        \t\r\n            //    'prefix' stores the String formed so far.\r\n            prefix.append(str.charAt(i));\r\n\r\n            //    Get the last character entered.\r\n            char lastCharacter = prefix.charAt(i);\r\n\r\n            //    Find the Node corresponding to the last character of 'prefix' which is pointed by prev of the Trie.\r\n            TrieNode curr = prev.children[lastCharacter - 'a'];\r\n\r\n            //    If nothing found, then break the loop as no more prefixes are going to be present.\r\n            if (curr == null) \r\n            {\r\n                i++;\r\n                break;\r\n            }\r\n\r\n            //    If present in trie then insert all the contacts with given prefix in the result.\r\n            ArrayList<String> temp = new ArrayList<String>();\r\n\r\n            viewSuggestionsHelper(curr, prefix.toString(), temp);\r\n\r\n            result.add(temp);\r\n\r\n            //    Change prev for next prefix\r\n            prev = curr;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private static void insertContactList(ArrayList<String> contactList, TrieNode root) \r\n    {\r\n\r\n        int n = contactList.size();\r\n\r\n        //    Insert each contact into the trie.\r\n        for (int i = 0; i < n; i++) \r\n        {\r\n            insertContact(contactList.get(i), root);\r\n        }\r\n    }\r\n\r\n    public static ArrayList<ArrayList<String>> phoneDirectory(ArrayList<String> contactList, String queryStr) \r\n    {\r\n        TrieNode root = new TrieNode();\r\n\r\n        //    Insert all the Contacts into Trie.\r\n        insertContactList(contactList, root);\r\n\r\n        //    Return the corresponding suggestions.\r\n        return viewSuggestions(queryStr, root);\r\n    }\r\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "python",
                "full_func": "'''\r\n    Time Complexity = O(N * (W ^ 2))\r\n    Space Complexity = O(N * W)\r\n    \r\n    Where N is the number of elements in the given array/list and W is the maximum length of a string.\r\n'''\r\n\r\nclass TrieNode:\r\n  \r\n    #    Constructor\r\n    def __init__(self):\r\n        \r\n        #    Each Trie Node contains a static array 'children' where each alphabet points to a Trie Node.\r\n        self.children = [None] * 26\r\n            \r\n        #    Initialize all the Trie nodes with None\r\n        i = ord('a')\r\n        while i <= ord('z'):\r\n            self.children[i - ord('a')] = None;\r\n            i += 1\r\n            \r\n        #    'isEnd' is true if the node represents end of a contact.\r\n        self.isEnd = False\r\n        \r\n\r\ndef insertContact(str, root):\r\n    n = len(str)\r\n\r\n    #    'itr' is used to iterate the Trie Nodes\r\n    itr = root\r\n\r\n    for i in range(n):\r\n        \r\n        #    Check if the str[i] is already present in our Trie.\r\n        if itr.children[ord(str[i]) - ord('a')] == None:\r\n            \r\n            #   If not found then create a new TrieNode\r\n            itr.children[ord(str[i]) - ord('a')] = TrieNode()\r\n            \r\n        nextNode = itr.children[ord(str[i]) - ord('a')]\r\n        \r\n        #    Move the iterator('itr') to point to next Trie Node.\r\n        itr = nextNode \r\n\r\n        #    If its the last character of the string 'str' then mark 'isEnd' as true\r\n        if (i == n - 1):\r\n            itr.isEnd = True\r\n\r\ndef viewSuggestionsHelper(curr, prefix, temp):\r\n    \r\n    #    Check if the string 'prefix' ends at this Node If yes then display the string found so far\r\n    if (curr.isEnd == True):\r\n        temp.append(prefix)\r\n\r\n    #    Find all the adjacent Nodes to the current Node and then call the function recursively.\r\n    c = ord('a')\r\n    while c <= ord('z'):\r\n        if curr.children[c - ord('a')] != None:\r\n            prefix += chr(c)\r\n            viewSuggestionsHelper(curr.children[c - ord('a')], prefix, temp)\r\n            prefix = prefix[:-1]\r\n        c += 1\r\n\r\ndef viewSuggestions(str, root):\r\n    \r\n    prev = root\r\n\r\n    prefix = \"\"\r\n\r\n    n = len(str)\r\n    \r\n    result = []\r\n\r\n    for i in range(n):\r\n        \r\n        #    'prefix' stores the string formed so far.\r\n        prefix += str[i]\r\n\r\n        #    Get the last character entered.\r\n        lastCharacter = prefix[i]\r\n        \r\n        #    Find the Node corresponding to the last character of 'prefix' which is pointed by prev of the Trie.\r\n        if ord(lastCharacter) - ord('a') >= 0 and prev.children[ord(lastCharacter) - ord('a')] != None:\r\n            curr = prev.children[ord(lastCharacter) - ord('a')]\r\n        else:\r\n            \r\n            #    If nothing found, then break the loop as no more prefixes are going to be present.\r\n            break\r\n        \r\n        \r\n        #    If present in trie then insert all the contacts with given prefix in the result.\r\n        temp = []\r\n\r\n        viewSuggestionsHelper(curr, prefix, temp)\r\n\r\n        result.append(temp)\r\n\r\n        #    Change prev for next prefix\r\n        prev = curr\r\n    \r\n    return result\r\n\r\ndef insertContactList(contactList, root):\r\n\r\n    n = len(contactList)\r\n\r\n    #    Insert each contact into the trie.\r\n    for i in range(n):\r\n        insertContact(contactList[i], root)\r\n\r\ndef phoneDirectory(contactList, queryStr):\r\n\r\n    root = TrieNode()\r\n\r\n    #    Insert all the Contacts into Trie.\r\n    insertContactList(contactList, root)\r\n\r\n    #    Return the corresponding suggestions.\r\n    return viewSuggestions(queryStr, root)",
                "lang_text": "py"
            }
        },
        "platform": "CODESTUDIO"
    }
}