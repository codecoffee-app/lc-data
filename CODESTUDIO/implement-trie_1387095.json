{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 11836,
            "title": " Implement Trie",
            "titleSlug": "implement-trie_1387095",
            "content": "<h4 id=\"ninja-has-to-implement-a-data-structure-trie-from-scratch-ninja-has-to-complete-some-functions\">Ninja has to implement a data structure \u201dTRIE\u201d from scratch. Ninja has to complete some functions.</h4>\n\n<pre><code>1) Trie(): Ninja has to initialize the object of this \u201cTRIE\u201d data structure.\n\n2) insert(\u201cWORD\u201d): Ninja has to insert the string \u201cWORD\u201d  into this \u201cTRIE\u201d data structure.\n\n3) countWordsEqualTo(\u201cWORD\u201d): Ninja has to return how many times this \u201cWORD\u201d is present in this \u201cTRIE\u201d.\n\n4) countWordsStartingWith(\u201cPREFIX\u201d): Ninjas have to return how many words are there in this \u201cTRIE\u201d that have the string \u201cPREFIX\u201d as a prefix.\n\n5) erase(\u201cWORD\u201d): Ninja has to delete one occurrence of the string \u201cWORD\u201d from the \u201cTRIE\u201d.\n</code></pre>\n\n<h4 id=\"note\">Note:</h4>\n\n<pre><code>1. If erase(\u201cWORD\u201d) function is called then it is guaranteed that the \u201cWORD\u201d is present in the \u201cTRIE\u201d.\n\n2. If you are going to use variables with dynamic memory allocation then you need to release the memory associated with them at the end of your solution.\n</code></pre>\n\n<h4 id=\"can-you-help-ninja-implement-the-trie-data-structure\">Can you help Ninja implement the &quot;TRIE&quot; data structure?</h4>\n\n<h5 id=\"input-format\">Input Format:</h5>\n\n<pre><code>The first line contains a single integer \u201cT\u201d representing the number of test cases. \n\nThe first line of each test case will contain a single integer \u201cN\u201d which denotes how many times the functions(as discussed above) will be called.\n\nThe next \u201cN\u201d lines contain the two space-separated strings, the first one is the name of the function and the second one is a \u201cWORD\u201d.\n</code></pre>\n\n<h5 id=\"output-format\">Output Format:</h5>\n\n<pre><code>For each test case, complete all the functions as we discussed above.\n\nThe output for every test case will be printed in a separate line.\n</code></pre>\n\n<h4 id=\"note\">Note:</h4>\n\n<pre><code>You do not need to print anything; it has already been taken care of. Just implement the given function.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints:</h5>\n\n<pre><code>1 &lt;= \u201cT\u201d &lt;= 50\n1 &lt;= \u201cN\u201d &lt;= 10000\n \u201cWORD\u201d = {a to z}\n1 &lt;= | \u201cWORD\u201d | &lt;= 1000\n\nWhere \u201cT\u201d is the number of test cases, \u201cN\u201d denotes how many times the functions(as discussed above) we call, \u201cWORD\u201d denotes the string on which we have to perform all the operations as we discussed above, and | \u201cWORD\u201d | denotes the length of the string \u201cWORD\u201d.\n\nTime limit: 1 sec.\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1:</h5>\n\n<pre><code>1\n5\ninsert coding\ninsert ninja\ncountWordsEqualTo coding\ncountWordsStartingWith nin\nerase coding\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1:</h5>\n\n<pre><code>1\n1   \n</code></pre>\n\n<h5 id=\"explanation-of-sample-input-1\">Explanation of sample input 1:</h5>\n\n<pre><code>After insertion of \u201ccoding\u201d in \u201cTRIE\u201d:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/trieex1-8873.png\" alt=\"\"></p>\n\n<pre><code>After insertion of \u201cninja\u201d in \u201cTRIE\u201d:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/trieex1_2-8872.png\" alt=\"\"></p>\n\n<pre><code>Count words equal to \u201ccoding\u201d :\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/trieex3-8871.png\" alt=\"\"></p>\n\n<pre><code>Count words those prefix is \u201cnin\u201d:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/trieex4-8870.png\" alt=\"\"></p>\n\n<pre><code>After deletion of the word \u201ccoding\u201d, \u201cTRIE\u201d is:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/trieex1-5-8869.png\" alt=\"\"></p>\n\n<h5 id=\"sample-input-2\">Sample Input 2:</h5>\n\n<pre><code>1\n6\ninsert samsung\ninsert samsung\ninsert vivo\nerase vivo\ncountWordsEqualTo samsung\ncountWordsStartingWith vi\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2:</h5>\n\n<pre><code>2\n0\n</code></pre>\n\n<h5 id=\"explanation-for-sample-input-2\">Explanation for sample input 2:</h5>\n\n<pre><code>insert \u201csamsung\u201d: we are going to insert the word \u201csamsung\u201d into the \u201cTRIE\u201d.\n\ninsert \u201csamsung\u201d: we are going to insert another \u201csamsung\u201d word into the \u201cTRIE\u201d.\n\ninsert \u201cvivo\u201d: we are going to insert the word \u201cvivo\u201d into the \u201cTRIE\u201d.\n\nerase \u201cvivo\u201d: we are going to delete the word \u201cvivo\u201d from the \u201cTRIE\u201d.\n\ncountWordsEqualTo \u201csamsung\u201d: There are two instances of \u201csumsung\u201d is present in \u201cTRIE\u201d.\n\ncountWordsStartingWith \u201cvi\u201d: There is not a single word in the \u201cTRIE\u201d that starts from the prefix \u201cvi\u201d.\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 230,
            "dislikes": "NA",
            "rephrased": {
                "body": "Implement a Trie data structure from scratch with the following functionalities:\n\n1.  **Trie():** Initialize an empty Trie.\n2.  **insert(\"WORD\"):** Insert the string \"WORD\" into the Trie.\n3.  **countWordsEqualTo(\"WORD\"):** Return the number of times \"WORD\" appears in the Trie.\n4.  **countWordsStartingWith(\"PREFIX\"):** Return the number of words in the Trie that have \"PREFIX\" as a prefix.\n5.  **erase(\"WORD\"):** Delete one occurrence of \"WORD\" from the Trie.  It's guaranteed that \"WORD\" exists in the Trie before calling erase.\n\nIf dynamic memory allocation is used, remember to release the memory.",
                "constraints": [
                    "1 <= T <= 50 (Number of test cases)",
                    "1 <= N <= 10000 (Number of function calls per test case)",
                    "\"WORD\" consists of lowercase English letters (a-z)",
                    "1 <= |\"WORD\"| <= 1000 (Length of the string \"WORD\")",
                    "Time limit: 1 second"
                ],
                "testcases": [
                    {
                        "input": "5\ninsert coding\ninsert ninja\ncountWordsEqualTo coding\ncountWordsStartingWith nin\nerase coding",
                        "output": "1\n1",
                        "explanation": "After inserting 'coding' and 'ninja', 'countWordsEqualTo coding' returns 1 because 'coding' appears once. 'countWordsStartingWith nin' returns 1 because 'ninja' starts with 'nin'. Finally, erasing 'coding' removes one instance of it."
                    },
                    {
                        "input": "6\ninsert samsung\ninsert samsung\ninsert vivo\nerase vivo\ncountWordsEqualTo samsung\ncountWordsStartingWith vi",
                        "output": "2\n0",
                        "explanation": "After inserting 'samsung' twice and 'vivo' once, erasing 'vivo' removes it from the Trie.  'countWordsEqualTo samsung' returns 2 because 'samsung' appears twice. 'countWordsStartingWith vi' returns 0 because no words in the Trie start with 'vi'."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Can you think of a brute force approach?</p>"
        ],
        "relatedTopics": [
            {
                "name": "Tries",
                "slug": "tries"
            }
        ],
        "solutions": [
            {
                "lang": "cpp",
                "full_func": "/*\r\n\r\n\tTime complexity: O(N * L) \r\n        insert - O(N)\r\n        countWordsEqualTo - O(N)\r\n        countWordsStartingWith - O(N)\r\n        erase - O(N)\r\n\tSpace complexity: O(N * L) \r\n\r\n\tWhere 'N' and 'L' represents the numbers of words \r\n\tand the longest word in words.\r\n\r\n*/\r\n\r\nstruct TrieNode\r\n{\r\n\tTrieNode *childern[26];\r\n\tint wordCount;\r\n\tint prefixCount;\r\n\r\n\tTrieNode()\r\n\t{\r\n\t\tfor (int i = 0; i < 26; i++)\r\n\t\t{\r\n\t\t\tchildern[i] = NULL;\r\n\t\t}\r\n\t\twordCount = 0;\r\n\t\tprefixCount = 0;\r\n\t}\r\n\t~TrieNode()\r\n    {\r\n        for (int i = 0; i < 26; i++)\r\n        {\r\n            if (childern[i] != NULL)\r\n            {\r\n                delete childern[i];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nclass Trie{\r\n\tpublic:\r\n\r\n\t// Declare a variable root that denotes the root of the Trie.\r\n\tTrieNode *root;\r\n\r\n\t// Initialize the Trie.\r\n\tTrie()\r\n\t{\r\n\t\troot = new TrieNode();\r\n\t}\r\n\t~Trie()\r\n\t{\r\n\t\tdelete root;\r\n\t}\r\n\r\n\t// In this function we are inserting the word into our Trie.\r\n\tvoid insert(string &word)\r\n\t{\r\n\t\tTrieNode *curr = root;\r\n\r\n\t\t// Iterating through the string word.\r\n\t\tfor (int i = 0; i < word.length(); i++)\r\n\t\t{\r\n\t\t\tint index = word[i] - 'a';\r\n\r\n\t\t\tif (curr->childern[index] == NULL)\r\n\t\t\t{\r\n\t\t\t\tcurr->childern[index] = new TrieNode();\r\n\t\t\t}\r\n\t\t\tcurr = curr->childern[index];\r\n\t\t\tcurr->prefixCount++;\r\n\t\t}\r\n\t\tcurr->wordCount++;\r\n\t}\r\n\r\n\tint countWordsEqualTo(string &word)\r\n\t{\r\n\t\tTrieNode *curr = root;\r\n\r\n\t\t// Iterating through the string word.\r\n\t\tfor (int i = 0; i < word.length(); i++)\r\n\t\t{\r\n\t\t\tint index = word[i] - 'a';\r\n\r\n\t\t\tif (curr->childern[index] == NULL)\r\n\t\t\t{\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\tcurr = curr->childern[index];\r\n\t\t}\r\n\t\treturn curr->wordCount;\r\n\t}\r\n\r\n\tint countWordsStartingWith(string &word)\r\n\t{\r\n\t\tTrieNode *curr = root;\r\n\r\n\t\t// Iterating through the string word.\r\n\t\tfor (int i = 0; i < word.length(); i++)\r\n\t\t{\r\n\t\t\tint index = word[i] - 'a';\r\n\r\n\t\t\tif (curr->childern[index] == NULL)\r\n\t\t\t{\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\tcurr = curr->childern[index];\r\n\t\t}\r\n\t\treturn curr->prefixCount;\r\n\t}\r\n\r\n\t// In this function we are removing the word from \"TRIE\".\r\n\tvoid erase(string &word)\r\n\t{\r\n\t\tTrieNode *curr = root;\r\n\t\tTrieNode *toBeDeleted = NULL;\r\n\r\n\t\t// Iterating through the string word.\r\n\t\tfor (int i = 0; i < word.length(); i++)\r\n\t\t{\r\n\t\t\tint index = word[i] - 'a';\r\n\r\n\t\t\t// Store the parent of current character.\r\n\t\t\tTrieNode *parent = curr;\r\n\t\t\tcurr = curr->childern[index];\r\n\r\n\t\t\t// If we are removing the given word then subtract 1 from the prefixCount.\r\n\t\t\tcurr->prefixCount--;\r\n\r\n\t\t\tif (toBeDeleted != NULL)\r\n\t\t\t{\r\n\t\t\t\ttoBeDeleted = NULL;\r\n\t\t\t}\r\n\r\n\t\t\tif (curr->prefixCount == 0)\r\n\t\t\t{\r\n\t\t\t\tif (toBeDeleted == NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tparent->childern[index] = NULL;\r\n\t\t\t\t}\r\n\t\t\t\ttoBeDeleted = curr;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcurr->wordCount--;\r\n\t\tif (toBeDeleted != NULL)\r\n\t\t{\r\n\t\t\ttoBeDeleted = NULL;\r\n\t\t}\r\n\t}\r\n};\r\n\r\n",
                "lang_text": "cpp"
            },
            {
                "lang": "python",
                "full_func": "'''\r\n\tTime complexity: O(N * L) \r\n        insert - O(N)\r\n        countWordsEqualTo - O(N)\r\n        countWordsStartingWith - O(N)\r\n        erase - O(N)\r\n\tSpace complexity: O(N * L) \r\n\r\n\tWhere 'N' and 'L' represents the numbers of words \r\n\tand the longest word in words.\r\n'''\r\n \r\nclass TrieNode():\r\n    \r\n    def __init__(self):\r\n        self.children = [None] * 26\r\n        self.wordCount = 0\r\n        self.prefixCount = 0\r\n        \r\nclass Trie():\r\n    \r\n    # Declare a variable root that denotes the root of the Trie.\r\n    def __init__(self):\r\n        self.root = TrieNode()\r\n        \r\n    # In this function we are inserting the word into our Trie.\r\n    def insert(self, word):\r\n        curr = self.root\r\n        \r\n        for i in range (len(word)):\r\n            index = ord(word[i]) - 97\r\n            \r\n            if curr.children[index] == None:\r\n                curr.children[index] = TrieNode()\r\n                \r\n            curr = curr.children[index]\r\n            curr.prefixCount += 1\r\n            \r\n        curr.wordCount += 1\r\n        \r\n    def countWordsEqualTo(self, word):\r\n        curr = self.root\r\n        \r\n        # Iterating through the starting word.\r\n        for i in range (len(word)):\r\n            index = ord(word[i]) - 97\r\n            \r\n            if curr.children[index] == None:\r\n                return 0\r\n                \r\n            curr = curr.children[index]\r\n            \r\n        return curr.wordCount\r\n    \r\n    def countWordsStartingWith(self, word):\r\n        curr = self.root\r\n        \r\n        # Iterating through the starting word.\r\n        for i in range (len(word)):\r\n            index = ord(word[i]) - 97\r\n            \r\n            if curr.children[index] == None:\r\n                return 0\r\n                \r\n            curr = curr.children[index]\r\n            \r\n        return curr.prefixCount\r\n    \r\n    # In this function we are removing the word from \"TRIE\".\r\n    def erase(self, word):\r\n        \r\n        curr = self.root\r\n        toBeDeleted = None\r\n        \r\n        # Iterating through the starting word.\r\n        for i in range (len(word)):\r\n            index = ord(word[i]) - 97\r\n            \r\n            parent = curr\r\n            curr = curr.children[index]\r\n            \r\n            # If we are removing the given word then subtract 1 from the prefixCount.\r\n            curr.prefixCount -= 1\r\n            \r\n            if toBeDeleted:\r\n                toBeDeleted = None\r\n                \r\n            if curr.prefixCount == 0:\r\n                if not toBeDeleted:\r\n                    parent.children[index] = None\r\n                    \r\n                toBeDeleted = curr\r\n            \r\n            curr.wordCount -= 1\r\n            \r\n            if toBeDeleted:\r\n                toBeDeleted = None\r\n",
                "lang_text": "python"
            },
            {
                "lang": "java",
                "full_func": "/*\r\n\r\n\tTime complexity: O(N * L) \r\n        insert - O(N)\r\n        countWordsEqualTo - O(N)\r\n        countWordsStartingWith - O(N)\r\n        erase - O(N)\r\n\tSpace complexity: O(N * L) \r\n\r\n\tWhere 'N' and 'L' represents the numbers of words \r\n\tand the longest word in words.\r\n\r\n*/\r\n\r\n\r\nclass TrieNode{\r\n\tpublic TrieNode childern[];\r\n\tpublic int wordCount;\r\n\tpublic int prefixCount;\r\n\t\r\n\tTrieNode(){\r\n\t\tchildern = new TrieNode[26];\r\n\t\twordCount = 0;\r\n\t\tprefixCount = 0;\r\n\t}\r\n};\r\n\r\n\r\npublic class Trie {\r\n\r\n    // Declare a variable root that denotes the root of the Trie.\r\n    public TrieNode root;\r\n    \r\n    // Initialize the Trie.\r\n    public Trie() {\r\n        root = new TrieNode();\r\n    }\r\n    \r\n    \r\n    // In this function we are inserting the word into our Trie.\r\n    public void insert(String word){\r\n    \t TrieNode curr = root;\r\n    \t \r\n    \t // Iterating through the string word.\r\n    \t for(int i=0;i<word.length();i++){\r\n    \t \tint index = word.charAt(i) - 'a';\r\n    \t \t\r\n    \t \tif(curr.childern[index] == null){\r\n    \t \t\tcurr.childern[index] = new TrieNode();\r\n    \t \t}\r\n    \t \tcurr = curr.childern[index];\r\n    \t \tcurr.prefixCount++;\r\n    \t }\r\n    \t curr.wordCount++;\r\n    }\r\n      \r\n     public int countWordsEqualTo(String word){\r\n    \t TrieNode curr = root;\r\n    \t \r\n    \t // Iterating through the string word.\r\n    \t for(int i=0;i<word.length();i++){\r\n    \t \tint index = word.charAt(i) - 'a';\r\n    \t \t\r\n    \t \tif(curr.childern[index] == null){\r\n    \t \t\treturn 0;\r\n    \t \t}\r\n    \t \tcurr = curr.childern[index];\r\n    \t }\r\n    \t return curr.wordCount;\r\n    }\r\n    \r\n    public int countWordsStartingWith(String word){\r\n    \t  TrieNode curr = root;\r\n    \t  \r\n    \t // Iterating through the string word.  \r\n    \t for(int i=0;i<word.length();i++){\r\n    \t \tint index = word.charAt(i) - 'a';\r\n    \t \t\r\n    \t \tif(curr.childern[index] == null){\r\n    \t \t\treturn 0;\r\n    \t \t}\r\n    \t \tcurr = curr.childern[index];\r\n    \t }\r\n    \t return curr.prefixCount;\r\n    }\r\n    \r\n    // In this function we are removing the word from \"TRIE\".\r\n    public void erase(String word){\r\n    \t TrieNode curr = root;\r\n    \t TrieNode toBeDeleted = null;\r\n    \t \r\n    \t  // Iterating through the string word.   \r\n    \t  for(int i=0;i<word.length();i++){\r\n    \t \tint index = word.charAt(i) - 'a';\r\n    \t \t\r\n    \t \t// Store the parent of current character.\r\n    \t \tTrieNode parent = curr;\r\n    \t \tcurr = curr.childern[index];\r\n    \t \tcurr.prefixCount--;\r\n    \t \t\r\n    \t \t\r\n    \t \tif(toBeDeleted != null){\r\n    \t \t\ttoBeDeleted = null;\r\n    \t \t}\r\n    \t \t\r\n    \t \t\r\n\t\t\t// If the prefixCount of current node is 0 that means we have reached at the end of the word that has to be deleted.\r\n    \t \tif(curr.prefixCount == 0){\r\n    \t \t\tif(toBeDeleted == null){\r\n    \t \t\t\tparent.childern[index] = null;\r\n    \t \t\t}\r\n    \t \t\ttoBeDeleted = curr;\r\n    \t \t}\r\n    \t }\r\n    \t \r\n    \t curr.wordCount--;\r\n    \t if(toBeDeleted != null){\r\n    \t \ttoBeDeleted = null;\r\n    \t }\r\n    }\r\n    \r\n}\r\n",
                "lang_text": "java"
            }
        ],
        "platform": "CODESTUDIO"
    }
}