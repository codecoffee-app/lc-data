{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 7109,
            "title": "Implementation: HashMap",
            "titleSlug": "implementation-hashmap_630343",
            "content": "<h4 id=\"design-a-data-structure-that-stores-a-mapping-of-a-key-to-a-given-value-and-supports-the-following-operations-in-constant-time\">Design a data structure that stores a mapping of a key to a given value and supports the following operations in constant time.</h4>\n\n<pre><code>1. INSERT(key, value): Inserts an integer value to the data structure against a string type key if not already present. If already present, it updates the value of the key with the new one. This function will not return anything.\n\n2. DELETE(key): Removes the key from the data structure if present. It doesn&#39;t return anything.\n\n3. SEARCH(key): It searches for the key in the data structure. In case it is present, return true. Otherwise, return false.\n\n4. GET(key): It returns the integer value stored against the given key. If the key is not present, return -1. \n\n5. GET_SIZE(): It returns an integer value denoting the size of the data structure. \n\n6. IS_EMPTY(): It returns a boolean value, denoting whether the data structure is empty or not. \n</code></pre>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>1. Key is always a string value.\n2. Value can never be -1.\n</code></pre>\n\n<h5 id=\"operations-performed\">Operations Performed :</h5>\n\n<pre><code>First(Denoted by integer value 1):  Insertion to the Data Structure. It is done in a pair of (key, value).\n\nSecond(Denoted by integer value 2):  Deletion of a key from the Data Structure.\n\nThird(Denoted by integer value 3): Search a given key in the Data Structure.\n\nFourth(Denoted by integer value 4): Retrieve the value for a given key from the Data Structure.\n\nFifth(Denoted by integer value 5): Retrieve the size of the Data Structure.\n\nSixth(Denoted by integer value 6): Retrieve whether the Data Structure is empty or not.\n</code></pre>\n\n<h5 id=\"input-format\">Input format :</h5>\n\n<pre><code>The first line contains an integer &#39;N&#39; which denotes the number of operations to be performed. Then the operations follow.\n\nEvery &#39;N&#39; lines represent an operation that needs to be performed.\n\nFor the &#39;INSERT&#39; operation, the input line will have three input values separated by a single space, representing the type of the operation in integer, the key inserted as a string, and the value against the key as an integer respectively.\n\nFor the rest of the operations except fifth and sixth, the input line will have two values separated by a single space, representing the type of the operation in integer and the key to be inserted as a string respectively. \n\nFor the last two operations(fifth and sixth), the input will contain a single integer, denoting only the type of operation in the integer.\n</code></pre>\n\n<h5 id=\"output-format\">Output Format :</h5>\n\n<pre><code>For type 1 operation, you do not need to return anything.\n\nFor type 2 operation, remove the element from the data structure and don&#39;t return anything.\n\nFor type 3 operation, return true if the key is present in the data structure. Else, return false.\n\nFor type 4 operation, return the value stored against the key. If the key is not present, return -1.\n\nFor type 5 operation, return the size.\n\nFor type 6 operation, return the boolean denoting whether the data structure is empty or not.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints :</h5>\n\n<pre><code>1 &lt;= N &lt;= 10 ^ 5\n1 &lt;= T &lt;= 3\n1 &lt;= V &lt;= 10 ^ 5\n\nWhere &#39;T&#39; is the type of operation and &#39;V&#39; is the value of the operand.\n\nTime Limit: 3 sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1 :</h5>\n\n<pre><code>3\n1 qwerty 35\n1 qwerty 50\n5\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1 :</h5>\n\n<pre><code>1\n</code></pre>\n\n<h5 id=\"explanation-of-sample-input-1\">Explanation Of Sample Input 1 :</h5>\n\n<pre><code>1 operation: We need to insert &#39;qwerty&#39; with a value of 35.\n\n2 operation: We need to insert &#39;qwerty&#39; with a value of 50.\n\n3 operation: We need to return the size of HashMap. So, We will return 1.\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2 :</h5>\n\n<pre><code>6\n1 code 9\n3 code\n2 code\n3 code\n5\n6\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2 :</h5>\n\n<pre><code>true\nfalse\n0\ntrue\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": 212,
            "dislikes": "NA",
            "rephrased": {
                "body": "Design a data structure that implements a key-value mapping with the following operations, all with a time complexity of O(1): INSERT, DELETE, SEARCH, GET, GET_SIZE, and IS_EMPTY.\n\n1.  **INSERT(key, value):** Inserts a new key-value pair into the data structure. If the key already exists, updates the associated value.\n2.  **DELETE(key):** Removes a key-value pair from the data structure, if the key exists.\n3.  **SEARCH(key):** Determines if a key exists in the data structure.\n4.  **GET(key):** Retrieves the value associated with a key. Returns -1 if the key does not exist.\n5.  **GET_SIZE():** Returns the number of key-value pairs in the data structure.\n6.  **IS_EMPTY():** Checks if the data structure contains any key-value pairs.\n\n**Note:**\n*   Keys are always strings.\n*   Values are integers and are never equal to -1.",
                "constraints": [
                    "1 <= N <= 10^5",
                    "1 <= T <= 6",
                    "1 <= V <= 10^5",
                    "Where 'N' is the number of operations, 'T' is the operation type, and 'V' is the value."
                ],
                "testcases": [
                    {
                        "input": "3\n1 qwerty 35\n1 qwerty 50\n5",
                        "output": "1",
                        "explanation": "First, 'qwerty' is inserted with a value of 35. Then, it's updated to 50. Finally, the size of the data structure (which is 1) is returned."
                    },
                    {
                        "input": "6\n1 code 9\n3 code\n2 code\n3 code\n5\n6",
                        "output": "true\nfalse\n0\ntrue",
                        "explanation": "First, 'code' is inserted with a value of 9. SEARCH('code') returns true. Then, 'code' is deleted. SEARCH('code') now returns false. GET_SIZE() returns 0. IS_EMPTY() returns true."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Can you think of a data structure that does this already? How is it implemented?</p>"
        ],
        "relatedTopics": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "cpp",
                "full_func": "/*\n    Time complexity : O(1) [for all operations]\n    Space complexity : O(N)\n\n    where 'N' is the number of elements in the HashMap.\n*/\n\n#include <vector>\n#include <list>\n\nclass myHashMap \n{\n    vector<list<pair<string, int>>> buckets;\n    int size;\n\n   public:\n    myHashMap() \n    {\n        buckets.resize(32);\n        size = 0;\n    }\n\n   private:\n    \n    // This function find the hash code for the string key.\n    int getHashCode(string key) \n    {\n        hash<string> hashCode;\n        int ret = hashCode(key) % buckets.size();\n        \n        return ret;\n    }\n    \n    // This function doubles the size of HashMap.\n    void rehash() \n    {\n        vector<list<pair<string, int>>> tmpBuckets = buckets;\n\n        buckets.clear();\n        \n        // Increasing the size of buckets.\n        buckets.resize(2 * tmpBuckets.size());\n        \n        // Insert all key from tmpBuckets into buckets.\n        for (int i = 0; i < tmpBuckets.size(); ++i) \n        {\n            for (auto it = tmpBuckets[i].begin(); it != tmpBuckets[i].end(); ++it) \n            {   \n                // Finding the hash code.\n                int hashCode = getHashCode(it->first);\n                buckets[hashCode].push_back(*it);\n            }\n        }\n    }\n\n   public:\n    void insert(string key, int value) \n    {   \n        // Find the hash code for the key.\n        int hashCode = getHashCode(key);\n        \n        // Check if key is already present in HashMap by traversing through the buckets[hashCode]. \n        for (auto it = buckets[hashCode].begin(); it != buckets[hashCode].end(); ++it) \n        {\n            if (it->first == key) \n            {\n                it->second = value;\n                return;\n            }\n        }\n\n        ++size;\n\n        buckets[hashCode].push_back(make_pair(key, value));\n                \n        // Find the load factor of the HashMap. \n        double loadFactor = (size * 1.0) / buckets.size();\n        \n        // Check if loadFactor is greater than 0.75.\n        if (loadFactor >= 0.75) \n        {\n            rehash();\n        }\n    }\n\n    bool search(string key) \n    {   \n        // Find the hash code for the key.\n        int hashCode = getHashCode(key);\n        \n        // Traverse through the buckets[hashCode].\n        for (auto it = buckets[hashCode].begin(); it != buckets[hashCode].end(); ++it)\n        {\n            if (it->first == key) \n            {   \n                // Key is present in the HashMap.\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    int get(string key) \n    {   \n        // Find the hash code for the key.\n        int hashCode = getHashCode(key);\n        \n        // Traverse through the buckets[hashCode].\n        for (auto it = buckets[hashCode].begin(); it != buckets[hashCode].end(); ++it) \n        {\n            if (it->first == key) \n            {   \n                // Returns the integer value stored against the given key.\n                return it->second;\n            }\n        }\n\n        return -1;\n    }\n\n    void remove(string key) \n    {\n        // Find the hash code for the key.\n        int hashCode = getHashCode(key);\n        \n        // Traverse through the buckets[hashCode].\n        for (auto it = buckets[hashCode].begin(); it != buckets[hashCode].end(); ++it) \n        {       \n            if (it->first == key) \n            {   \n                // Delete the key from the HashMap and decrement size by 1.\n                buckets[hashCode].erase(it);\n                --size;\n                return;\n            }\n        }\n    }\n\n    int getSize() \n    {   \n        // Return the size of HashMap.\n        return size; \n    }\n\n    bool isEmpty() \n    { \n        // Check if the size of HashMap is equal to 0.\n        return size == 0; \n    }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "java",
                "full_func": "/*\n    Time complexity : O(1) [for all operations]\n    Space complexity : O(N)\n\n    where 'N' is the number of elements in the HashMap.\n*/\n\nimport java.util.ArrayList;\n\nclass Entry \n{\n    String key;\n    int value;\n    Entry next;\n\n    public Entry(String key, int value) \n    {\n        this.key = key;\n        this.value = value;\n    }\n\n    public Entry() \n    {\n        this.key = new String();\n        this.value = 0;\n    }\n}\n\npublic class myHashMap \n{\n    private ArrayList<Entry> buckets;\n    private int size;\n\n    public myHashMap() \n    {\n        this.buckets = new ArrayList<>();\n        this.size = 0;\n\n        // Initialise bucket list with 3 elements.\n        for (int i = 0; i < 3; i++) \n        {\n            this.buckets.add(null);\n        }\n    }\n\n    // This function find the bucket index for the string key.\n    private int getBucketIndex(String key) \n    {  \n        int hashcode = key.hashCode();\n        int bucketIndex = ((hashcode % this.buckets.size()) + this.buckets.size()) % this.buckets.size();\n        return bucketIndex;\n    }\n    \n    // This function doubles the size of HashMap.\n    private void rehash() \n    {\n        ArrayList<Entry> temp = this.buckets;\n        this.buckets = new ArrayList<>();\n        \n        // Increasing the size of buckets.\n        for (int i = 0; i < temp.size() * 2; i++) \n        {\n            this.buckets.add(null);\n        }\n\n        this.size = 0;\n        \n        // Insert all key from temp into buckets.\n        for (int i = 0; i < temp.size(); i++) \n        {\n            Entry head = temp.get(i);\n            Entry current = head;\n\n            while (current != null) \n            {\n                this.insert(current.key, current.value);\n                current = current.next;\n            }\n        }\n    }\n\n    public int get(String key) \n    {   \n        // Finding the bucket index for the key.\n        int bucketIndex = this.getBucketIndex(key);\n        \n        Entry head = this.buckets.get(bucketIndex);\n        Entry temp = head;\n        \n        // Traverse through the buckets[bucketIndex].\n        while (temp != null) \n        {\n            if (temp.key.equals(key)) \n            {   \n                // Returns the integer value stored against the given key.\n                return temp.value;\n            }\n\n            temp = temp.next;\n        }\n\n        return -1;\n    }\n\n    public void insert(String key, int value) \n    {\n        // Finding the bucket index for the key.\n        int bucketIndex = this.getBucketIndex(key);\n        \n        Entry head = this.buckets.get(bucketIndex);\n        Entry newNode = new Entry();\n\n        newNode.key = key;\n        newNode.value = value;\n\n        if (head == null) \n        {\n            this.buckets.set(bucketIndex, newNode);\n            this.size += 1;\n        } \n        else \n        {\n            Entry temp = head;\n            Entry prev = null;\n            \n            // Check if key is already present in HashMap by traversing through the buckets[bucketIndex].\n            while (temp != null) \n            {\n                if (temp.key.equals(key)) \n                {\n                    temp.value = value;\n                    return;\n                }\n\n                prev = temp;\n                temp = temp.next;\n            }\n\n            prev.next = newNode;\n            this.size += 1;\n        }\n        \n        // Find the load factor of the HashMap.\n        double loadFactor = (size * 1.0) / buckets.size();\n        \n        // Check if loadFactor is greater than 0.75.\n        if (loadFactor >= 0.75) \n        {\n            this.rehash();\n        }\n    }\n\n    public void remove(String key) \n    {   \n        // Finding the bucket index for the key.\n        int bucketIndex = this.getBucketIndex(key);\n        Entry head = this.buckets.get(bucketIndex);\n\n        if (head == null) \n        {\n            return;\n        }\n\n        Entry temp = head;\n        Entry prev = null;\n        \n        // Traverse through the buckets[bucketIndex].\n        while (temp != null) \n        {\n            if (temp.key.equals(key)) \n            {   \n                // Delete the key from the HashMap and decrement size by 1.\n                if (prev == null) \n                {\n                    this.buckets.set(bucketIndex, head.next);\n                } \n                else \n                {\n                    prev.next = temp.next;\n                }\n\n                this.size -= 1;\n\n                return;\n            }\n\n            prev = temp;\n            temp = temp.next;\n        }\n    }\n\n    public boolean search(String key) \n    {    \n        // Check if key is not present in the HashMap.\n        if (this.get(key) == -1) \n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    public int getSize() \n    {\n        // Return the size of HashMap.\n        return this.size;\n    }\n\n    public boolean isEmpty()\n    {\n        // Check if the size of HashMap is equal to 0.\n        return this.getSize() == 0;\n    }\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "python",
                "full_func": "'''\n    Time complexity : O(1) [for all operations]\n    Space complexity : O(N)\n\n    where 'N' is the number of elements in the HashMap.\n'''\n\nclass Entry :\n    \n    def __init__(self, key, value) :    \n        self.key = key\n        self.value = value\n        self.next = None\n        \n    def __init__(self) :\n        self.key = str()\n        self.value = int()\n        self.next = None\n        \nclass myHashMap :\n    \n    def __init__(self) :\n        self.buckets = [None] * 3\n        self.size = 0\n    \n    # This function find the bucket index for the string key.\n    def __getBucketIndex(self, key) :\n        \n        hashcode = hash(key)\n        bucketIndex = hashcode % len(self.buckets)\n        return bucketIndex\n\n    # This function doubles the size of HashMap.\n    def __rehash(self) :     \n        \n        temp = self.buckets\n        currSize = len(self.buckets)\n        self.buckets = list()\n        \n        # Increasing the size of buckets.\n        self.buckets = [None] * (currSize * 2)\n        self.size = 0\n        \n        # Insert all key from temp into buckets.\n        for head in temp :\n            \n            while head is not None :\n                \n                self.insert(head.key, head.value)\n                head = head.next\n          \n    def get(self, key) :\n        \n        # Finding the bucket index for the key.\n        bucketIndex = self.__getBucketIndex(key)\n        \n        head = self.buckets[bucketIndex]\n        temp = head\n        \n        # Traverse through the buckets[bucketIndex].\n        while temp is not None : \n            \n            if (temp.key == key):\n                \n                # Returns the integer value stored against the given key.\n                return temp.value\n\n            temp = temp.next\n\n        return -1\n    \n    def insert(self, key, value) :\n        \n        # Finding the bucket index for the key.\n        bucketIndex = self.__getBucketIndex(key)\n        \n        head = self.buckets[bucketIndex]\n        newNode = Entry()\n        newNode.key = key\n        newNode.value = value\n\n        if head is None :\n            self.buckets[bucketIndex] = newNode\n        else :\n            temp = head\n            prev = None\n            \n            # Check if key is already present in HashMap by traversing through the buckets[bucketIndex]. \n            while temp is not None :\n                \n                if (temp.key == key):\n                    temp.value = value\n                    return\n\n                prev = temp\n                temp = temp.next\n\n            prev.next = newNode\n            \n        self.size += 1\n        \n        # Find the load factor of the HashMap.\n        loadFactor = self.size  / len(self.buckets)\n        \n        # Check if loadFactor is greater than 0.75.\n        if (loadFactor >= 0.75):\n            self.__rehash()\n            \n    def remove(self, key) :\n        \n        # Finding the bucket index for the key.\n        bucketIndex = self.__getBucketIndex(key)\n        head = self.buckets[bucketIndex]\n                                          \n        if (head is None):\n            return\n\n        temp = head\n        prev = None\n        \n        # Traverse through the buckets[bucketIndex].\n        while temp is not None :\n            \n            if (temp.key == key):\n                \n                # Delete the key from the HashMap and decrement size by 1.\n                if (prev is None): \n                    self.buckets[bucketIndex] = head.next\n                else :\n                    prev.next = temp.next\n\n                self.size -= 1\n                return\n\n            prev = temp\n            temp = temp.next      \n                        \n    def search(self, key) :\n        \n        # Check if key is not present in the HashMap.\n        if (self.get(key) == -1):\n            return False\n\n        return True\n\n    def getSize(self) :\n        \n        # Return the size of HashMap.\n        return self.size\n    \n    def isEmpty(self) :\n        \n        # Check if the size of HashMap is equal to 0.\n        return self.getSize() == 0\n \n# Main.\nmyMap = myHashMap()\n\nn = int(input().strip())\n\nfor i in range(n) :\n\n    li = input().strip().split(\" \")\n    typ = int(li[0])\n \n    if (typ == 1):\n        key = li[1]\n        value = int(li[2])\n        myMap.insert(key, value)\n        \n    elif (typ == 2):\n        key = li[1]\n        myMap.remove(key)\n        \n    elif (typ == 3):\n        key = li[1]\n        if (myMap.search(key)):\n            print('true')\n        else :\n            print('false')\n            \n    elif (typ == 4):\n        key = li[1]\n        print(myMap.get(key))\n    \n    elif (typ == 5):\n        print(myMap.getSize())\n    \n    else :\n        if(myMap.isEmpty()) :\n            print(\"true\")\n        else :\n            print(\"false\")\n    ",
                "lang_text": "py"
            }
        },
        "platform": "CODESTUDIO"
    }
}