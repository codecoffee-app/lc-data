{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 9310,
            "title": "Linear Probing",
            "titleSlug": "linear-probing_982799",
            "content": "<h4 id=\"hashing-is-a-technique-in-which-a-large-non-negative-integer-is-mapped-with-a-smaller-non-negative-integer-using-a-function-called-hash-function-hash-table-is-the-table-in-which-we-store-large-numbers-corresponding-to-mapped-indices\">\u2018Hashing\u2019 is a technique in which a large non-negative integer is mapped with a smaller non-negative integer using a function called \u2018hash function\u2019. Hash Table is the table in which we store large numbers corresponding to mapped indices.</h4>\n\n<h4 id=\"while-hashing-a-list-of-elements-we-define-collision-as-a-situation-when-the-hash-function-for-a-large-integer-in-list-returns-an-index-which-is-already-mapped-with-some-other-large-integer-in-a-list\">While hashing a list of elements, we define \u2018Collision\u2019 as a situation when the hash function for a large integer in list returns an index which is already mapped with some other large integer in a list.</h4>\n\n<h4 id=\"linear-probing-is-a-collision-handling-technique-in-which-we-find-the-next-vacant-place-in-the-hash-table-for-mapping-what-we-do-is-that-we-take-the-original-hash-value-and-successively-add-1-in-each-iteration-until-an-unmapped-index-is-found-in-the-hash-table\">\u2018Linear Probing\u2019 is a collision handling technique in which we find the next vacant place in the hash table for mapping. What we do is that we take the original hash value and successively add 1 in each iteration until an unmapped index is found in the hash table.</h4>\n\n<h4 id=\"given-an-array-keys-consisting-of-n-non-negative-integers-for-each-element-in-a-given-array-you-need-to-determine-the-index-by-which-this-element-is-mapped-in-the-hash-table-if-the-linear-probing-technique-is-used-to-handle-collision\">Given an array KEYS consisting of N non-negative integers. For each element in a given array, you need to determine the index by which this element is mapped in the hash table if the \u2018Linear Probing\u2019 technique is used to handle collision.</h4>\n\n<h4 id=\"the-hash-function-you-need-to-consider-is-h-x-x-mod-n-i-e-index-x-mod-n\">The hash function you need to consider is H(X) = X mod N i.e. index = X mod N.</h4>\n\n<h4 id=\"return-an-array-hash_table-of-size-n-in-which\">Return an array \u2018HASH_TABLE\u2019 of size N in which:</h4>\n\n<h4 id=\"hash_table-i-keys-j-where-i-keys-j-mod-n\">HASH_TABLE[ i ] = KEYS[ j ] where, i = KEYS[ j ] mod N.</h4>\n\n<h4 id=\"in-short-an-element-at-index-i-is-the-element-from-the-given-array-keys-which-is-mapped-to-that-index\">In short, an element at index \u2018i\u2019 is the element from the given array KEYS which is mapped to that index.</h4>\n\n<h4 id=\"you-can-refer-to-the-example-given-below\">You can refer to the example given below:</h4>\n\n<p><img src=\"https://files.codingninjas.in/hashing-final-6736.png\" alt=\"alt\"></p>\n\n<h4 id=\"the-answer-for-the-above-example-will-be-18-21-6-15\">The answer for the above example will be [18, 21, 6, 15].</h4>\n\n<h4 id=\"note\">Note:</h4>\n\n<pre><code>1. Consider \u20180\u2019 based indexing.\n</code></pre>\n\n<h5 id=\"input-format\">Input format:</h5>\n\n<pre><code>The first line of input contains an integer \u2018T\u2019 denoting the number of test cases.\n\nThe first line of each test case contains a positive integer \u2018N\u2019 representing the size of array KEYS.\n\nThe second line of each test case contains \u2018N\u2019 space-separated non-negative integers representing elements of the array KEYS.\n</code></pre>\n\n<h5 id=\"output-format\">Output format :</h5>\n\n<pre><code>For each test case, return an array &#39;HASH_TABLE\u2019 of size \u2018N\u2019 where HASH_TABLE[ i ] is the element from the given array KEYS which is mapped to the index i.\n</code></pre>\n\n<h5 id=\"note\">Note:</h5>\n\n<pre><code>You do not need to print anything, it has already been taken care of. Just implement the given function.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints:</h5>\n\n<pre><code>1 &lt;= T &lt;= 10\n1 &lt;= N &lt;= 500\n0 &lt;= KEYS[ i ] &lt;= 10^9\n\nTime limit: 1 sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1:</h5>\n\n<pre><code>2\n5\n5 3 2 6 4\n4\n1 5 3 7\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1:</h5>\n\n<pre><code>5 6 2 3 4\n7 1 5 3\n</code></pre>\n\n<h5 id=\"explanation\">Explanation</h5>\n\n<pre><code>For test case 1:\nH(X) = X mod 5\nAll the numbers have unique hash values so there is no collision. Just map each index to its hash index.\n\nFor test case 2:\nH(1) = 1L index 1 is unoccupied so we will map index 1 with 1.\nH(5) = 1: but, index 1 is occupied, so, we will use index 2 which is unoccupied, and will map index 2 with 5.\nH(3) = 3: index 3 is unoccupied so we will map index 3 with 3.\nH(7) = 3, but index 3 is occupied so we will use index 0 which is unoccupied and will map index 0 with 7.\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2:</h5>\n\n<pre><code>2\n6\n4 7 8 1 2 5\n3\n6 7 10\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2:</h5>\n\n<pre><code>5 7 8 1 4 2\n6 7 10\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": 28,
            "dislikes": "NA",
            "rephrased": {
                "body": "Implement a hash table using linear probing to handle collisions. Given an array `keys` of non-negative integers, determine the index where each element is mapped in the hash table. The hash function is H(X) = X mod N, where N is the size of the `keys` array. Resolve collisions using linear probing, finding the next available index by incrementing by 1 until an empty slot is found.",
                "constraints": [
                    "1 <= T <= 10",
                    "1 <= N <= 500",
                    "0 <= KEYS[i] <= 10^9"
                ],
                "testcases": [
                    {
                        "input": "keys=[5, 3, 2, 6, 4], n=5",
                        "output": "[5, 6, 2, 3, 4]",
                        "explanation": "H(5) = 0, H(3) = 3, H(2) = 2, H(6) = 1, H(4) = 4. All numbers have unique hash values, so there is no collision. Just map each index to its hash index."
                    },
                    {
                        "input": "keys=[1, 5, 3, 7], n=4",
                        "output": "[7, 1, 5, 3]",
                        "explanation": "H(1) = 1, index 1 is unoccupied, so map index 1 with 1.\nH(5) = 1, index 1 is occupied, so use index 2, which is unoccupied, and map index 2 with 5.\nH(3) = 3, index 3 is unoccupied, so map index 3 with 3.\nH(7) = 3, index 3 is occupied, so use index 0, which is unoccupied, and map index 0 with 7."
                    },
                    {
                        "input": "keys=[4, 7, 8, 1, 2, 5], n=6",
                        "output": "[5, 7, 8, 1, 4, 2]",
                        "explanation": "H(4) = 4, H(7) = 1, H(8) = 2, H(1) = 1 (collision), so it goes to 3, H(2) = 2 (collision), so it goes to 4(collision), so it goes to 5, H(5)=5(collision) so it goes to 0. Result should be [5, 7, 8, 1, 4, 2]"
                    },
                    {
                        "input": "keys=[6, 7, 10], n=3",
                        "output": "[6, 7, 10]",
                        "explanation": "H(6) = 0, H(7) = 1, H(10) = 1 (collision), so it goes to 2. The result should be [6, 7, 10]"
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>The approach is simple, just find the mapping index and if occupied, find the next available index.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Arrays",
                "slug": "arrays"
            }
        ],
        "solutions": {},
        "platform": "CODESTUDIO"
    }
}