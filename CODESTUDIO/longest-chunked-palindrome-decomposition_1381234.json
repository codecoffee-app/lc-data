{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 11346,
            "title": "Longest Chunked Palindrome Decomposition",
            "titleSlug": "longest-chunked-palindrome-decomposition_1381234",
            "content": "<h4 id=\"you-are-given-a-string-s-your-task-is-to-find-the-length-of-it-s-longest-possible-chunked-palindrome-in-other-words-you-have-to-split-the-string-s-into-k-substrings-sub-1-sub-2-sub-3-sub-k-such-that\">You are given a string \u2018S\u2019. Your task is to find the length of it\u2019s longest possible chunked palindrome. In other words, you have to split the string \u2018S\u2019 into \u2018K\u2019 substrings ((Sub)1, (Sub)2, (Sub)3, ..., (Sub)K) such that:</h4>\n\n<pre><code>1. The substring \u2018(Sub)i\u2019 is a non-empty string, for all 1 &lt;= i &lt;= K.\n2. (Sub)1 + (Sub)2 + (Sub)3 + \u2026 + (Sub)K = \u2018S\u2019, which means the concatenation of all the substrings is equal to \u2018S\u2019.\n3. (Sub)i = (Sub)(K-i+1), for all 1 &lt;= i &lt;= \u2018K\u2019.\n</code></pre>\n\n<h4 id=\"you-have-to-find-the-largest-possible-value-of-k\">You have to find the largest possible value of \u2018K\u2019</h4>\n\n<h4 id=\"note\">Note :</h4>\n\n<pre><code>1. The string \u2018S\u2019 consists of only lowercase English alphabets.\n2. A \u2018substring\u2019 is a contiguous sequence of characters within a string.\n</code></pre>\n\n<h5 id=\"input-format\">Input Format :</h5>\n\n<pre><code>The first line contains an integer \u2018T\u2019, which denotes the number of test cases to be run. Then, the \u2018T\u2019 test cases follow. \n\nThe first and only line of each test case contains a string \u2018S\u2019 of lowercase English alphabets.\n</code></pre>\n\n<h5 id=\"output-format\">Output Format :</h5>\n\n<pre><code>For each test case, print in a new line an integer denoting the length of the longest possible chunked palindrome of string \u2018S\u2019.\n\nOutput for each test case will be printed in a separate line.\n</code></pre>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>You do not need to print anything. It has already been taken care of. Just implement the given function.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints :</h5>\n\n<pre><code>1 &lt;= T &lt;= 10\n1 &lt;= |S| &lt;= 1000\n\nwhere &#39;T&#39; denotes the number of test cases and |S| denotes the size of the string.\n\nTime Limit: 1 sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1 :</h5>\n\n<pre><code>1\nabcdefgdefabc\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1 :</h5>\n\n<pre><code>5\n</code></pre>\n\n<h5 id=\"explanation-for-sample-input-1\">Explanation for sample input 1 :</h5>\n\n<pre><code>We can split the string into \u201c(abc)(def)(g)(def)(abc)\u201d.\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2 :</h5>\n\n<pre><code>1\nninjas\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2 :</h5>\n\n<pre><code>1\n</code></pre>\n\n<h5 id=\"explanation-for-sample-input-2\">Explanation for sample input 2 :</h5>\n\n<pre><code>We can split the string into \u201c(ninjas)\u201d.\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 7,
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a string 'S' consisting of lowercase English alphabets, determine the maximum number of chunks 'K' into which 'S' can be divided such that the substrings (Sub)1, (Sub)2, ..., (Sub)K satisfy the following conditions:\n\n1.  Each substring (Sub)i is non-empty.\n2.  The concatenation of all substrings equals 'S': (Sub)1 + (Sub)2 + ... + (Sub)K = 'S'.\n3.  The substrings form a palindrome: (Sub)i = (Sub)(K-i+1) for all 1 <= i <= K.\n\nIn essence, find the largest 'K' for which 'S' can be represented as a chunked palindrome.",
                "constraints": [
                    "1 <= T <= 10",
                    "1 <= |S| <= 1000",
                    "The string 'S' consists of only lowercase English alphabets."
                ],
                "testcases": [
                    {
                        "input": "s = abcdefgdefabc",
                        "output": "5",
                        "explanation": "We can split the string into '(abc)(def)(g)(def)(abc)'."
                    },
                    {
                        "input": "s = ninjas",
                        "output": "1",
                        "explanation": "We can split the string into '(ninjas)'."
                    },
                    {
                        "input": "s = aaa",
                        "output": "3",
                        "explanation": "We can split the string into '(a)(a)(a)'."
                    },
                    {
                        "input": "s = qwq",
                        "output": "3",
                        "explanation": "We can split the string into '(q)(w)(q)'."
                    },
                    {
                        "input": "s = merchant",
                        "output": "1",
                        "explanation": "We can only split the string into '(merchant)'."
                    },
                    {
                        "input": "s = antaprezaprezanta",
                        "output": "11",
                        "explanation": "We can split the string into '(a)(nt)(a)(pre)(z)(apre)(z)(a)(nt)(a)'."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><i>Think Recursively.</i></p>",
            "<p><i>Think of a greedy approach.</i></p>"
        ],
        "relatedTopics": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Recursion",
                "slug": "recursion"
            },
            {
                "name": "Strings",
                "slug": "strings"
            }
        ],
        "solutions": {},
        "platform": "CODESTUDIO"
    }
}