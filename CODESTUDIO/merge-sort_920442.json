{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 8855,
            "title": "Merge Sort",
            "titleSlug": "merge-sort_920442",
            "content": "<h4 id=\"given-a-sequence-of-numbers-arr-your-task-is-to-return-a-sorted-sequence-of-arr-in-non-descending-order-with-help-of-the-merge-sort-algorithm\">Given a sequence of numbers \u2018ARR\u2019. Your task is to return a sorted sequence of \u2018ARR\u2019 in non-descending order with help of the merge sort algorithm.</h4>\n\n<h4 id=\"example\">Example :</h4>\n\n<pre><code>Merge Sort Algorithm -\n\nMerge sort is a Divide and Conquer based Algorithm. It divides the input array into two-parts, until the size of the input array is not \u20181\u2019. In the return part, it will merge two sorted arrays a return a whole merged sorted array.\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/screenshot-87-6238.png\" alt=\"subsequence\"></p>\n\n<pre><code>The above illustrates shows how merge sort works.\n</code></pre>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>It is compulsory to use the \u2018Merge Sort\u2019 algorithm.\n</code></pre>\n\n<h5 id=\"input-format\">Input format :</h5>\n\n<pre><code>The first line of input contains an integer \u2018T\u2019 denoting the number of test cases.\nThe next 2*&#39;T&#39; lines represent the \u2018T\u2019 test cases.\n\nThe first line of each test case contains an integer \u2018N\u2019 which denotes the size of \u2018ARR\u2019.\n\nThe second line of each test case contains \u2018N\u2019 space-separated elements of \u2018ARR\u2019. \n</code></pre>\n\n<h5 id=\"output-format\">Output Format :</h5>\n\n<pre><code>For each test case, print the numbers in non-descending order\n</code></pre>\n\n<h5 id=\"note\">Note:</h5>\n\n<pre><code>You are not required to print the expected output; it has already been taken care of. Just implement the function.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints :</h5>\n\n<pre><code>1 &lt;= T &lt;= 50\n1 &lt;= N &lt;= 10^4\n-10^9 &lt;= arr[i] &lt;= 10^9\n\nTime Limit : 1 sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1 :</h5>\n\n<pre><code>2\n7\n3 4 1 6 2 5 7\n4\n4 3 1 2\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1 :</h5>\n\n<pre><code>1 2 3 4 5 6 7\n1 2 3 4\n</code></pre>\n\n<h5 id=\"explanation-for-sample-input-1\">Explanation For Sample Input 1:</h5>\n\n<pre><code>Test Case 1 :\n\nGiven \u2018ARR\u2019 : { 3, 4, 1, 6, 2, 5, 7 }\n\nThen sorted &#39;ARR&#39; in non-descending order will be : { 1, 2, 3, 4, 5, 6, 7 }. Non-descending order means every element must be greater than or equal to the previse element.\n\nTest Case 2 :\n\nGiven \u2018ARR\u2019 : { 4, 3, 1, 2 }\n\nThen sorted &#39;ARR&#39; in non-descending order will be : { 1, 2, 3, 4 }. \n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2 :</h5>\n\n<pre><code>2\n4\n5 4 6 7\n3\n2 1 1\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2 :</h5>\n\n<pre><code>4 5 6 7\n1 1 2\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": 227,
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a sequence of numbers, sort it in non-descending order using the Merge Sort algorithm. Merge sort is a divide-and-conquer algorithm that recursively divides the input array into two halves until each sub-array contains only one element. Then, it merges the sub-arrays in a sorted manner to produce the final sorted array. It is compulsory to use the Merge Sort algorithm.",
                "constraints": [
                    "1 <= T <= 50",
                    "1 <= N <= 10^4",
                    "-10^9 <= arr[i] <= 10^9",
                    "Time Limit : 1 sec"
                ],
                "testcases": [
                    {
                        "input": "7\n3 4 1 6 2 5 7",
                        "output": "1 2 3 4 5 6 7",
                        "explanation": "The given array {3, 4, 1, 6, 2, 5, 7} is sorted in non-descending order to produce {1, 2, 3, 4, 5, 6, 7}."
                    },
                    {
                        "input": "4\n4 3 1 2",
                        "output": "1 2 3 4",
                        "explanation": "The given array {4, 3, 1, 2} is sorted in non-descending order to produce {1, 2, 3, 4}."
                    },
                    {
                        "input": "4\n5 4 6 7",
                        "output": "4 5 6 7",
                        "explanation": "The given array {5, 4, 6, 7} is sorted in non-descending order to produce {4, 5, 6, 7}."
                    },
                    {
                        "input": "3\n2 1 1",
                        "output": "1 1 2",
                        "explanation": "The given array {2, 1, 1} is sorted in non-descending order to produce {1, 1, 2}."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Try to think recursively.</p>",
            "<p>Try to solve iteratively.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Arrays",
                "slug": "arrays"
            },
            {
                "name": "Sorting",
                "slug": "sorting"
            },
            {
                "name": "Recursion",
                "slug": "recursion"
            }
        ],
        "solutions": [
            {
                "lang": "cpp",
                "full_func": "/*\r\n    Time complexity: O(N*log(N))\r\n    Space complexity: O(N)\r\n\r\n    Where N is number of elements in array.\r\n*/\r\n\r\nvoid mergeSort(vector < int > & arr, int n) {\r\n    int currentGap = 2;\r\n\r\n    // Nearest power of 2 which is greater then or equal to n.\r\n    float nearestPowerTwo = log2(n);\r\n    if (int(nearestPowerTwo) != (nearestPowerTwo)) {\r\n        nearestPowerTwo = pow(2, int(nearestPowerTwo) + 1);\r\n    } \r\n    else {\r\n        nearestPowerTwo = pow(2, int(nearestPowerTwo));\r\n    }\r\n\r\n    int parts;\r\n    while (currentGap <= nearestPowerTwo) {\r\n\r\n        // Divide 'n' size list in 'n/currentGap' parts.\r\n        parts = n / currentGap;\r\n        if (n % currentGap != 0) {\r\n            parts++;\r\n        }\r\n        for (int i = 0; i < parts; i++) {\r\n\r\n            /*\r\n                Divide every part in two section and merge them in sorted manner.\r\n                'ptrLeft' is starting indices of current part\r\n                'ptrRight' is middle indices of current part\r\n                'end' is ending+1 indices of current part.\r\n            */\r\n           \r\n            int ptrLeft = i * currentGap;\r\n            int copyLeft = ptrLeft;\r\n            int end = (i + 1) * currentGap;\r\n            int ptrRight = (ptrLeft + end) / 2;\r\n            end = min(end, n);\r\n            int copyRight = ptrRight;\r\n            vector < int > mergeArr;\r\n            while (ptrLeft <= copyRight and ptrRight < end) {\r\n                if (arr[ptrLeft] > arr[ptrRight]) {\r\n                    mergeArr.push_back(arr[ptrRight]);\r\n                    ptrRight += 1;\r\n                } else {\r\n                    mergeArr.push_back(arr[ptrLeft]);\r\n                    ptrLeft += 1;\r\n                }\r\n\r\n                if (ptrLeft == copyRight) {\r\n                    while (ptrRight != end) {\r\n                        mergeArr.push_back(arr[ptrRight]);\r\n                        ptrRight++;\r\n                    }\r\n                    break;\r\n                }\r\n                if (ptrRight == end) {\r\n                    while (ptrLeft != copyRight) {\r\n                        mergeArr.push_back(arr[ptrLeft]);\r\n                        ptrLeft++;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Copy the 'mergeArr' in actual 'arr'.\r\n            for (int i = 0; i < mergeArr.size(); i++) {\r\n                arr[copyLeft + i] = mergeArr[i];\r\n            }\r\n        }\r\n        currentGap *= 2;\r\n    }\r\n\r\n}",
                "lang_text": "cpp"
            },
            {
                "lang": "python",
                "full_func": "'''\r\n    Time complexity: O(N*log(N))\r\n    Space complexity: O(N)\r\n\r\n    Where N is number of elements in array.\r\n'''\r\n\r\nfrom math import log2\r\n\r\ndef mergeSort(arr, n):\r\n\r\n    # Start with gap=2.\r\n    currentGap = 2\r\n\r\n    # Nearest power of 2 which is greater then or equal to n.\r\n    nearestPowerTwo = log2(n)\r\n    if(nearestPowerTwo != int(nearestPowerTwo)):\r\n        nearestPowerTwo = 2**(int(nearestPowerTwo)+1)\r\n    else:\r\n        nearestPowerTwo = 2**(int(nearestPowerTwo))\r\n\r\n    while (currentGap <= nearestPowerTwo):\r\n\r\n        # Divide 'n' size list in 'n//currentGap' parts.\r\n        parts = n//currentGap\r\n        if(n % currentGap != 0):\r\n            parts += 1\r\n\r\n        # Iterate every part.\r\n        for i in range(parts):\r\n\r\n            '''\r\n                Divide every part in two section and merge them in sorted manner.\r\n                'ptrLeft' is starting indices of current part\r\n                'ptrRight' is middle indices of current part\r\n                'end' is ending+1 indices of current part.\r\n            '''\r\n\r\n            ptrLeft = i*currentGap\r\n            copyLeftPtr = ptrLeft\r\n            end = (i+1)*currentGap\r\n            ptrRight = (ptrLeft+end)//2\r\n            end = min(end, n)\r\n            copyRightPtr = ptrRight\r\n\r\n            # List in which we sort sorted part of current part.\r\n            mergeArr = []\r\n\r\n            while(ptrLeft <= copyRightPtr and ptrRight < end):\r\n                if(arr[ptrLeft] > arr[ptrRight]):\r\n                    mergeArr.append(arr[ptrRight])\r\n                    ptrRight += 1\r\n                else:\r\n                    mergeArr.append(arr[ptrLeft])\r\n                    ptrLeft += 1\r\n\r\n                if (ptrLeft == copyRightPtr):\r\n                    mergeArr.extend(arr[ptrRight:end])\r\n                    break\r\n\r\n                if(ptrRight == end):\r\n                    mergeArr.extend(arr[ptrLeft:copyRightPtr])\r\n                    break\r\n\r\n            # Copy the 'mergeArr' in actual 'arr'.\r\n            for i in range(len(mergeArr)):\r\n                arr[copyLeftPtr+i] = mergeArr[i]\r\n\r\n        currentGap *= 2\r\n\r\n    return arr",
                "lang_text": "python"
            },
            {
                "lang": "java",
                "full_func": "/*\r\n    Time complexity : O(N*log(N))\r\n    Space complexity : O(N)\r\n\r\n    Where N is number of elements in array.\r\n*/\r\n\r\npublic class Solution {\r\n\r\n    public static void mergeSort(int[] arr, int n) {\r\n\r\n        int curr_size;\r\n\r\n        int left_start;\r\n\r\n        for (curr_size = 1; curr_size <= n - 1; curr_size = 2 * curr_size) {\r\n\r\n            for (left_start = 0; left_start < n - 1; left_start += 2 * curr_size) {\r\n                int mid = Math.min(left_start + curr_size - 1, n - 1);\r\n                int right_end = Math.min(left_start + 2 * curr_size - 1, n - 1);\r\n                merge(arr, left_start, mid, right_end);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Function to merge the two haves arr[l..m] and arr[m+1..r] of array arr[].\r\n    static void merge(int arr[], int l, int m, int r) {\r\n        int i, j, k;\r\n        int n1 = m - l + 1;\r\n        int n2 = r - m;\r\n\r\n        // Create temp arrays.\r\n        int L[] = new int[n1];\r\n        int R[] = new int[n2];\r\n\r\n        // Copy data to temp arrays L[] and R[].\r\n        for (i = 0; i < n1; i++)\r\n            L[i] = arr[l + i];\r\n        for (j = 0; j < n2; j++)\r\n            R[j] = arr[m + 1 + j];\r\n\r\n        // Merge the temp arrays back into arr[l..r].\r\n        i = 0;\r\n        j = 0;\r\n        k = l;\r\n        while (i < n1 && j < n2) {\r\n            if (L[i] <= R[j]) {\r\n                arr[k] = L[i];\r\n                i++;\r\n            } \r\n            else {\r\n                arr[k] = R[j];\r\n                j++;\r\n            }\r\n            k++;\r\n        }\r\n\r\n        // Copy the remaining elements of L[], if there are any.\r\n        while (i < n1) {\r\n            arr[k] = L[i];\r\n            i++;\r\n            k++;\r\n        }\r\n\r\n        // Copy the remaining elements of R[], if there are any.\r\n        while (j < n2) {\r\n            arr[k] = R[j];\r\n            j++;\r\n            k++;\r\n        }\r\n    }\r\n\r\n}",
                "lang_text": "java"
            }
        ],
        "platform": "CODESTUDIO"
    }
}