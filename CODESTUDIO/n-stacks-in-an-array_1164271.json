{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 10101,
            "title": "N Stacks In An Array",
            "titleSlug": "n-stacks-in-an-array_1164271",
            "content": "<h4 id=\"design-a-data-structure-to-implement-n-stacks-using-a-single-array-of-size-s-it-should-support-the-following-operations\">Design a data structure to implement \u2018N\u2019 stacks using a single array of size \u2018S\u2019. It should support the following operations:</h4>\n\n<pre><code>push(X, M): Pushes an element X into the Mth stack. Returns true if the element is pushed into the stack, otherwise false.\n\npop(M): Pops the top element from Mth Stack. Returns -1 if the stack is empty, otherwise, returns the popped element.\n</code></pre>\n\n<h4 id=\"two-types-of-queries-denote-these-operations\">Two types of queries denote these operations :</h4>\n\n<pre><code>Type 1: for push(X, M) operation.\nType 2: for pop(M) operation.\n</code></pre>\n\n<h5 id=\"input-format\">Input format :</h5>\n\n<pre><code>The first line of input contains three space-separated integers \u2018N\u2019, \u2018S\u2019 and \u2018Q\u2019 denoting the number of stacks, the size of the array and number of queries, respectively. \n\nThe next \u2018Q\u2019 lines specify the type of operation/query to be performed on the data structure.\n\nEach query contains an integer \u2018P\u2019 denoting the type of query.\n\nFor query of type 1, the integer \u2018P\u2019 is equal to 1 and it is followed by two space-separated integers \u2018X\u2019 and \u2018M\u2019 denoting the element and stack on which operation is to be performed, respectively.\n\nFor query of type 2, the integer \u2018P\u2019 is equal to 2 and it is followed by a single integer \u2018M\u2019 denoting the stack on which operation is to be performed.\n</code></pre>\n\n<h5 id=\"output-format\">Output format :</h5>\n\n<pre><code>For each query, print the output returned after performing the corresponding operation on the data structure. \n</code></pre>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>You do not need to print anything, it has already been taken care of. Just implement the given functions.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints :</h5>\n\n<pre><code>1 &lt;= N &lt;= S &lt;= 1000\n1 &lt;= Q &lt;= 10^5 \n1 &lt;= P &lt;= 2\n1 &lt;= X &lt;= 10^5\n\nTime Limit: 1 sec\n\nWhere \u2018S\u2019 represents the size of the array, \u2018N\u2019 represents the number of stacks, \u2018Q\u2019 represents the number of queries, \u2018P\u2019 represents the type of operation and \u2018X\u2019 represents the element.\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1 :</h5>\n\n<pre><code>3 6 5\n1 10 1\n1 20 1\n1 30 2\n2 1\n2 2\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1 :</h5>\n\n<pre><code>True \nTrue\nTrue\n20\n30\n</code></pre>\n\n<h5 id=\"explanation-1\">Explanation 1 :</h5>\n\n<pre><code>For the given input, we have the number of stacks, N = 3, size of the array, S = 6 and number of queries, Q = 5.\nOperations performed on the stack are as follows:\npush(10, 1): Push element \u201810\u2019 into the 1st stack. This returns true.\npush(20, 1): Push element \u201820\u2019 into the 1st stack. This returns true.\npush(30, 2): Push element \u201830\u2019 into the 2nd stack. This returns true.\npop(1): Pop the top element from the 1st stack. This returns 20.\npop(2): Pop the top element from the 2nd stack. This returns 30.\n\nThe following image shows the snapshots of the stack after each operation:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/10101-sample-1-7923.PNG\" alt=\"Sample Testcase 1\"></p>\n\n<h5 id=\"sample-input-2\">Sample Input 2 :</h5>\n\n<pre><code>1 5 5\n1 15 1\n1 25 1\n2 1\n1 30 1\n2 1\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2 :</h5>\n\n<pre><code>True\nTrue\n25\nTrue\n30\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 266,
            "dislikes": "NA",
            "rephrased": {
                "body": "Implement a data structure, `NStack`, to simulate 'N' stacks within a single array of size 'S'. The `NStack` class should support the following operations:\n\n*   `push(X, M)`: Adds element 'X' to the Mth stack. Returns `true` if the push is successful (i.e., space is available), otherwise `false`.  'M' is the stack number (1-indexed).\n*   `pop(M)`: Removes and returns the top element from the Mth stack. Returns `-1` if the Mth stack is empty. 'M' is the stack number (1-indexed).",
                "constraints": [
                    "1 <= N <= S <= 1000",
                    "1 <= Q <= 10^5",
                    "1 <= P <= 2",
                    "1 <= X <= 10^5"
                ],
                "testcases": [
                    {
                        "input": "N = 3, S = 6, Q = 5, queries = [[1, 10, 1], [1, 20, 1], [1, 30, 2], [2, 1], [2, 2]]",
                        "output": "True\nTrue\nTrue\n20\n30",
                        "explanation": "Initially, we have 3 stacks sharing an array of size 6.  The queries perform the following:\n1.  push(10, 1): Pushes 10 onto stack 1.\n2.  push(20, 1): Pushes 20 onto stack 1.\n3.  push(30, 2): Pushes 30 onto stack 2.\n4.  pop(1): Pops 20 from stack 1.\n5.  pop(2): Pops 30 from stack 2."
                    },
                    {
                        "input": "N = 1, S = 5, Q = 5, queries = [[1, 15, 1], [1, 25, 1], [2, 1], [1, 30, 1], [2, 1]]",
                        "output": "True\nTrue\n25\nTrue\n30",
                        "explanation": "One stack sharing an array of size 5. The queries:\n1.  push(15, 1): Push 15 onto stack 1.\n2.  push(25, 1): Push 25 onto stack 1.\n3.  pop(1): Pop 25 from stack 1.\n4.  push(30, 1): Push 30 onto stack 1.\n5.  pop(1): Pop 30 from stack 1."
                    },
                    {
                        "input": "N = 2, S = 4, Q = 6, queries = [[1, 5, 1], [1, 10, 1], [1, 15, 2], [2, 1], [2, 1], [2, 2]]",
                        "output": "True\nTrue\nTrue\n10\n5\n15",
                        "explanation": "Two stacks sharing an array of size 4.\n1. push(5, 1)\n2. push(10, 1)\n3. push(15, 2)\n4. pop(1) = 10\n5. pop(1) = 5\n6. pop(2) = 15"
                    },
                    {
                        "input": "N = 3, S = 5, Q = 4, queries = [[1, 1, 1], [1, 2, 2], [2, 1], [2, 3]]",
                        "output": "True\nTrue\n1\n-1",
                        "explanation": "Three stacks sharing an array of size 5.\n1. push(1, 1)\n2. push(2, 2)\n3. pop(1) = 1\n4. pop(3) = -1 (stack 3 is empty)"
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>A simple and intuitive approach could be to divide the array equally into N parts and use each part to implement one stack.</p>",
            "<p>Instead of dividing the array equally among N stacks, let the stacks grow independently of each other.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Stacks & Queues",
                "slug": "stacks-&-queues"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "cpp",
                "full_func": "/*\r\n\tTime complexity: O(1) for all operations.\r\n\tSpace Complexity: O(S + N)\r\n\t\r\n\tWhere S is the size of the array, \r\n    N is the number of stacks.\r\n*/\r\n\r\nclass NStack\r\n{\r\n    // Array to implement the stacks.\r\n    vector<int> arr;\r\n\r\n    // Array to keep track of the indices of the top elements of every stack.\r\n    vector<int> top;\r\n\r\n    // Array to store the next pointers/indices.\r\n    vector<int> next;\r\n\r\n    int n, s;\r\n\r\n    // Variable to store the starting index of the free list.\r\n    int freeStart;\r\n\r\npublic:\r\n    // Initialize your data structure.\r\n    NStack(int N, int S)\r\n    {\r\n        n = N;\r\n        s = S;\r\n\r\n        // Create the arrays.\r\n        arr = vector<int>(s);\r\n        top = vector<int>(n);\r\n        next = vector<int>(s);\r\n\r\n        // Initialize all stacks as empty.\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            top[i] = -1;\r\n        }\r\n\r\n        // Initialize all spaces as free as initially the complete array is empty.\r\n        for (int i = 0; i < s - 1; i++)\r\n        {\r\n            next[i] = i + 1;\r\n        }\r\n\r\n        // Set the last pointer of the free list to -1 to indicate the end of free list.\r\n        next[s - 1] = -1;\r\n\r\n        // Initialize the starting index of the free list.\r\n        freeStart = 0;\r\n    }\r\n\r\n    // Pushes 'X' into the Mth stack. Returns true if it gets pushed into the stack, and false otherwise.\r\n    bool push(int x, int m)\r\n    {\r\n        if (freeStart == -1)\r\n        {\r\n            // Array is full. So, element cannot be inserted.\r\n            return false;\r\n        }\r\n\r\n        // Store the index of the first free slot in a temporary variable.\r\n        int index = freeStart;\r\n\r\n        // Update the starting index of the free list.\r\n        freeStart = next[index];\r\n\r\n        // Store the new element in the free slot.\r\n        arr[index] = x;\r\n\r\n        // Update the next pointer of the new element.\r\n        next[index] = top[m - 1];\r\n\r\n        // Add the element to the stack by updating the head/top of the stack list.\r\n        top[m - 1] = index;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Pops top element from Mth Stack. Returns -1 if the stack is empty, otherwise returns the popped element.\r\n    int pop(int m)\r\n    {\r\n        if (top[m - 1] == -1)\r\n        {\r\n            // Stack is empty. So, return -1.\r\n            return -1;\r\n        }\r\n\r\n        // Find the index of the top element of the stack.\r\n        int index = top[m - 1];\r\n\r\n        // Remove the element from the stack by updating the head/top of the stack list.\r\n        top[m - 1] = next[index];\r\n\r\n        // Add the free slot to the free list.\r\n        next[index] = freeStart;\r\n        freeStart = index;\r\n\r\n        // Return the popped element.\r\n        return arr[index];\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "java",
                "full_func": "/*\r\nTime complexity: O(1) for all operations.\r\nSpace Complexity: O(S + N)\r\n\r\nWhere S is the size of the array, \r\n   N is the number of stacks.\r\n*/\r\n\r\npublic class NStack {\r\n\r\n    // Array to implement the stacks.\r\n    int[] arr;\r\n\r\n    // Array to keep track of the indices of the top elements of every stack.\r\n    int[] top;\r\n\r\n    // Array to store the next pointers/indices.\r\n    int[] next;\r\n\r\n    int freeStart;\r\n\r\n    NStack(int N, int S) {\r\n\r\n        // Create the arrays.\r\n        arr = new int[S];\r\n        top = new int[N + 1];\r\n        next = new int[S];\r\n\r\n        // Initialize all stacks as empty.\r\n        for (int i = 0; i < N + 1; i++) {\r\n            top[i] = -1;\r\n        }\r\n\r\n        // Initialize all spaces as free as initially the complete array is empty.\r\n        for (int i = 0; i < S - 1; i++) {\r\n            next[i] = i + 1;\r\n        }\r\n\r\n        // Set the last pointer of the free list to -1 to indicate the end of free list.\r\n        next[S - 1] = -1;\r\n\r\n        // Initialize the starting index of the free list.\r\n        freeStart = 0;\r\n    }\r\n\r\n    // Pushes 'X' into the Mth stack. Returns true if it gets pushed into the stack,\r\n    // and false otherwise.\r\n    boolean push(int x, int m) {\r\n        if (freeStart == -1) {\r\n            // Array is full. So, element cannot be inserted.\r\n            return false;\r\n        }\r\n\r\n        // Store the index of the first free slot in a temporary variable.\r\n        int index = freeStart;\r\n\r\n        // Update the starting index of the free list.\r\n        freeStart = next[index];\r\n\r\n        // Store the new element in the free slot.\r\n        arr[index] = x;\r\n\r\n        // Update the next pointer of the new element.\r\n        next[index] = top[m - 1];\r\n\r\n        // Add the element to the stack by updating the head/top of the stack list.\r\n        top[m - 1] = index;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Pops top element from Mth Stack. Returns -1 if the stack is empty, otherwise\r\n    // returns the popped element.\r\n    int pop(int m) {\r\n        if (top[m - 1] == -1) {\r\n            // Stack is empty. So, return -1.\r\n            return -1;\r\n        }\r\n\r\n        // Find the index of the top element of the stack.\r\n        int index = top[m - 1];\r\n\r\n        // Remove the element from the stack by updating the head/top of the stack list.\r\n        top[m - 1] = next[index];\r\n\r\n        // Add the free slot to the free list.\r\n        next[index] = freeStart;\r\n        freeStart = index;\r\n\r\n        // Return the popped element.\r\n        return arr[index];\r\n    }\r\n\r\n}\r\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "python",
                "full_func": "'''\n    Time complexity: O(1) for all operations.\n\tSpace Complexity: O(S + N)\n\t\n\tWhere S is the size of the array, \n    N is the number of stacks.\n'''\n\n\nclass NStack:\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n\n        # Array to implement the stacks.\n        self.arr = [0 for i in range(s)]\n\n        # Array to keep track of the indices of the top elements of every stack.\n        self.top = [-1 for i in range(n)]\n\n        # Initialize all spaces as free as initially the complete array is empty.\n        self.next = [i+1 for i in range(s)]\n\n        # Set the last pointer of the free list to -1 to indicate the end of free list.\n        self.next[s-1] = -1\n\n        # Initialize the starting index of the free list.\n        self.freeStart = 0\n\n    # Pushes 'X' into the Mth stack. Returns true if it gets pushed into the stack, and false otherwise.\n    def push(self, x, m):\n        if (self.freeStart == -1):\n            # Array is full. So, element cannot be inserted.\n            return False\n\n        # Store the index of the first free slot in a temporary variable.\n        index = self.freeStart\n\n        # Update the starting index of the free list.\n        self.freeStart = self.next[index]\n\n        # Store the new element in the free slot.\n        self.arr[index] = x\n\n        # Update the next pointer of the new element.\n        self.next[index] = self.top[m-1]\n\n        # Add the element to the stack by updating the head/top of the stack list.\n        self.top[m-1] = index\n\n        return True\n\n    # Pops top element from Mth Stack. Returns -1 if the stack is empty, otherwise returns the popped element.\n    def pop(self, m):\n        if (self.top[m - 1] == -1):\n            # Stack is empty. So, return -1.\n            return -1\n\n        # Find the index of the top element of the stack.\n        index = self.top[m - 1]\n\n        # Remove the element from the stack by updating the head/top of the stack list.\n        self.top[m - 1] = self.next[index]\n\n        # Add the free slot to the free list.\n        self.next[index] = self.freeStart\n        self.freeStart = index\n\n        # Return the popped element.\n        return self.arr[index]",
                "lang_text": "py"
            }
        },
        "platform": "CODESTUDIO"
    }
}