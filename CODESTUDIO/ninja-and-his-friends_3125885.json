{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 16322,
            "title": "Ninja And His Friends",
            "titleSlug": "ninja-and-his-friends_3125885",
            "content": "<h4 id=\"ninja-has-a-grid-of-size-r-x-c-each-cell-of-the-grid-contains-some-chocolates-ninja-has-two-friends-alice-and-bob-and-he-wants-to-collect-as-many-chocolates-as-possible-with-the-help-of-his-friends\">Ninja has a &#39;GRID&#39; of size &#39;R&#39; X &#39;C&#39;. Each cell of the grid contains some chocolates. Ninja has two friends Alice and Bob, and he wants to collect as many chocolates as possible with the help of his friends.</h4>\n\n<h4 id=\"initially-alice-is-in-the-top-left-position-i-e-0-0-and-bob-is-in-the-top-right-place-i-e-0-c-1-in-the-grid-each-of-them-can-move-from-their-current-cell-to-the-cells-just-below-them-when-anyone-passes-from-any-cell-he-will-pick-all-chocolates-in-it-and-then-the-number-of-chocolates-in-that-cell-will-become-zero-if-both-stay-in-the-same-cell-only-one-of-them-will-pick-the-chocolates-in-it\">Initially, Alice is in the top-left position i.e. (0, 0), and Bob is in the top-right place i.e. (0, \u2018C\u2019 - 1) in the grid. Each of them can move from their current cell to the cells just below them. When anyone passes from any cell, he will pick all chocolates in it, and then the number of chocolates in that cell will become zero. If both stay in the same cell, only one of them will pick the chocolates in it.</h4>\n\n<h4 id=\"if-alice-or-bob-is-at-i-j-then-they-can-move-to-i-1-j-i-1-j-1-or-i-1-j-1-they-will-always-stay-inside-the-grid\">If Alice or Bob is at (i, j) then they can move to (i + 1, j), (i + 1, j - 1) or (i + 1, j + 1). They will always stay inside the \u2018GRID\u2019.</h4>\n\n<h4 id=\"your-task-is-to-find-the-maximum-number-of-chocolates-ninja-can-collect-with-the-help-of-his-friends-by-following-the-above-rules\">Your task is to find the maximum number of chocolates Ninja can collect with the help of his friends by following the above rules.</h4>\n\n<h5 id=\"example\">Example:</h5>\n\n<pre><code>Input: \u2018R\u2019 = 3, \u2018C\u2019 = 4\n       \u2018GRID\u2019 = [[2, 3, 1, 2], [3, 4, 2, 2], [5, 6, 3, 5]]\nOutput: 21\n\nInitially Alice is at the position (0,0) he can follow the path (0,0) -&gt; (1,1) -&gt; (2,1) and will collect 2 + 4 + 6 = 12 chocolates.\n\nInitially Bob is at the position (0, 3) and he can follow the path (0, 3) -&gt; (1,3) -&gt; (2, 3) and will colllect 2 + 2 + 5 = 9 chocolates.\n\nHence the total number of chocolates collected will be 12 + 9 = 21. there is no other possible way to collect a greater number of chocolates than 21.\n</code></pre>\n\n<h5 id=\"input-format\">Input Format :</h5>\n\n<pre><code>The first line of input contains an integer &#39;T&#39;, denoting the number of test cases. \n\nFor each test case, the first line contains two integers&#39; R&#39; and &#39;C&#39; denoting the number of rows and number of columns in the grid. \n\nNext &#39;R&#39; lines will contain &#39;C&#39; integers each the value of each cell in the grid.\n</code></pre>\n\n<h5 id=\"output-format\">Output format :</h5>\n\n<pre><code>For each test case, print the maximum number of chocolates that can be collected.\n\nOutput for each test case will be printed in a separate line.\n</code></pre>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>You don&#39;t need to print anything. It has already been taken care of. Just implement the given function.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints :</h5>\n\n<pre><code>1 &lt;= \u2018T\u2019 &lt;= 10\n2 &lt;= &#39;R&#39;, &#39;C&#39; &lt;= 50\n0 &lt;= &#39;GRID[i][j]&#39;&lt;= 10^2\nTime Limit: 1sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1 :</h5>\n\n<pre><code>2\n3 4\n2 3 1 2\n3 4 2 2\n5 6 3 5\n2 2\n1 1\n1 2\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1 :</h5>\n\n<pre><code>21\n5\n</code></pre>\n\n<h5 id=\"explanation-of-sample-input-1\">Explanation Of Sample Input 1 :</h5>\n\n<pre><code>For the first test case, Initially Alice is at the position (0, 0) he can follow the path (0, 0) -&gt; (1, 1) -&gt; (2, 1) and will collect 2 + 4 + 6 = 12 chocolates.\n\nInitially Bob is at the position (0, 3) and he can follow the path (0, 3) -&gt; (1, 3) -&gt; (2, 3) and will collect 2 + 2 + 5 = 9 chocolates.\n\nHence the total number of chocolates collected will be 12 + 9 = 21.\n\nFor the second test case, Alice will follow the path (0, 0) -&gt; (1, 0) and Bob will follow the path (0, 1) -&gt; (1, 1). total number of chocolates collected will be 1 + 1 + 1 + 2 = 5\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2 :</h5>\n\n<pre><code>2\n2 2\n3 7\n7 6\n3 2\n4 5\n3 7\n4 2\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2 :</h5>\n\n<pre><code>23\n25\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 521,
            "dislikes": "NA",
            "rephrased": {
                "body": "A grid of size R x C is given, where each cell contains some chocolates. Two friends, Alice and Bob, start at the top-left (0, 0) and top-right (0, C-1) corners, respectively. They move downwards, and when either of them passes through a cell, they collect the chocolates, and the cell's value becomes zero. If they are in the same cell, only one of them collects the chocolates.  At position (i, j), a friend can move to (i+1, j), (i+1, j-1), or (i+1, j+1), always staying within the grid. Find the maximum number of chocolates that can be collected.",
                "constraints": [
                    "1 <= T <= 10",
                    "2 <= R, C <= 50",
                    "0 <= GRID[i][j] <= 100",
                    "Time Limit: 1sec"
                ],
                "testcases": [
                    {
                        "input": "3 4\n2 3 1 2\n3 4 2 2\n5 6 3 5",
                        "output": "21",
                        "explanation": "Alice can follow the path (0, 0) -> (1, 1) -> (2, 1) and collect 2 + 4 + 6 = 12 chocolates.\nBob can follow the path (0, 3) -> (1, 3) -> (2, 3) and collect 2 + 2 + 5 = 9 chocolates.\nThe total number of chocolates collected is 12 + 9 = 21."
                    },
                    {
                        "input": "2 2\n1 1\n1 2",
                        "output": "5",
                        "explanation": "Alice can follow the path (0, 0) -> (1, 0) and Bob can follow the path (0, 1) -> (1, 1).  The total chocolates collected will be 1 + 1 + 1 + 2 = 5."
                    },
                    {
                        "input": "2 2\n3 7\n7 6",
                        "output": "23",
                        "explanation": null
                    },
                    {
                        "input": "3 2\n4 5\n3 7\n4 2",
                        "output": "25",
                        "explanation": null
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Try to think recursively to explore all possible paths.</p>",
            "<p>Try to think about how we can skip the repetitions in the first approach.&nbsp;</p>",
            "<p>Try to think about how we can skip the repetitions in the first approach.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Recursion",
                "slug": "recursion"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "cpp",
                "full_func": "/*\r\n    Time complexity: O(R*(C^2))\r\n    Space complexity: O(C^2)\r\n\r\n    Where 'R' is the number of rows and 'C' is the number of columns in the grid.\r\n*/\r\n\r\nint maximumChocolates(int r, int c, vector<vector<int>> &grid) {\r\n    // Initializing the 'prev_dp' vector.\r\n    vector<vector<int>> prev_dp(c, vector<int>(c));\r\n\r\n    // Running a loop from 0 to 'r'.\r\n    for (int row = 0; row < r; row++) {\r\n        // Initializing a 'current_dp' vector.\r\n        vector<vector<int>> current_dp(c, vector<int>(c));\r\n        // Running a loop from 0 to 'min(c, row + 1)'.\r\n        for (int c1 = 0; c1 < min(c, row + 1); c1++) {\r\n            // Running a loop from 'max(0, c - 1 - row)' to 'c'.\r\n            for (int c2 = max(0, c - 1 - row); c2 < c; c2++) {\r\n                // Initializing a variable 'prev_max'.\r\n                int prev_max = 0;\r\n                for (int offset1 = max(0, c1 - 1); offset1 <= min(c - 1, c1 + 1); offset1++) {\r\n                    for (int offset2 = max(0, c2 - 1); offset2 <= min(c - 1, c2 + 1); offset2++) {\r\n                        // Updating the variable 'prev_max'.\r\n                        prev_max = max(prev_max, prev_dp[offset1][offset2]);\r\n                    }\r\n                }\r\n                // Case when both are in same row.\r\n                if (c1 == c2) {\r\n                    current_dp[c1][c2] = prev_max + grid[row][c1];\r\n                } else {\r\n                    current_dp[c1][c2] = prev_max + grid[row][c1] + grid[row][c2];\r\n                }\r\n            }\r\n        }\r\n        prev_dp = current_dp;\r\n    }\r\n    int res = 0;\r\n    for (int i = 0; i < c; i++) {\r\n        for (int j = 0; j < c; j++) {\r\n            // Updating the variable 'res' with max possible answer.\r\n            res = max(res, prev_dp[i][j]);\r\n        }\r\n    }\r\n    return res;\r\n}",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "java",
                "full_func": "/*\n    Time complexity: O(R * (C^2))\n    Space complexity: O(C^2)\n\n    Where 'R' is the number of rows and 'C' is the number of columns in the grid.\n*/\n\npublic class Solution {\n    public static int maximumChocolates(int r, int c, int[][] grid) {\n        // Initializing the 'prev_dp' vector.\n        int[][] prev_dp = new int[c][c];\n\n        // Running a loop from 0 to 'r'.\n        for (int row = 0; row < r; row++) {\n\n            // Initializing a 'current_dp' vector.\n            int[][] current_dp = new int[c][c];\n\n            // Running a loop from 0 to 'min(c, row + 1)'.\n            for (int c1 = 0; c1 < Math.min(c, row + 1); c1++) {\n\n                // Running a loop from 'max(0, c - 1 - row)' to 'c'.\n                for (int c2 = Math.max(0, c - 1 - row); c2 < c; c2++) {\n\n                    // Initializing a variable 'prev_max'.\n                    int prev_max = 0;\n                    for (int offset1 = Math.max(0, c1 - 1); \n                        offset1 <= Math.min(c - 1, c1 + 1); offset1++) {\n\n                        for (int offset2 = Math.max(0, c2 - 1); \n                            offset2 <= Math.min(c - 1, c2 + 1); offset2++) {\n\n                            // Updating the variable 'prev_max'.\n                            prev_max = Math.max(prev_max, prev_dp[offset1][offset2]);\n                        }\n                    }\n\n                    // Case when both are in same row.\n                    if (c1 == c2) {\n                        current_dp[c1][c2] = prev_max + grid[row][c1];\n                    } else {\n                        current_dp[c1][c2] = prev_max + grid[row][c1] + grid[row][c2];\n                    }\n                }\n            }\n\n            prev_dp = current_dp;\n        }\n\n        int res = 0;\n        for (int i = 0; i < c; i++) {\n            for (int j = 0; j < c; j++) {\n                // Updating the variable 'res' with max possible answer.\n                res = Math.max(res, prev_dp[i][j]);\n            }\n        }\n        \n        return res;\n    }\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "python",
                "full_func": "'''\r\n    Time complexity: O(R*(C^2))\r\n    Space complexity: O(C^2)\r\n\r\n    Where 'R' is the number of rows and 'C' is the number of columns in the grid.\r\n'''\r\n\r\n\r\nfrom typing import List\r\n\r\n\r\ndef maximumChocolates(r: int, c: int, grid: List[List[int]]) -> int:\r\n    # Initializing the 'prev_dp' vector.\r\n    prev_dp = [[0 for i in range(c)] for j in range(c)]\r\n\r\n    # Running a loop from 0 to 'r'.\r\n    for row in range(r):\r\n        # Initializing a 'current_dp' vector.\r\n        current_dp = [[0 for i in range(c)] for j in range(c)]\r\n\r\n        # Running a loop from 0 to 'min(c, row + 1)'.\r\n        for c1 in range(min(c, row + 1)):\r\n            # Running a loop from 'max(0, c - 1 - row)' to 'c'.\r\n            for c2 in range(max(0, c-1-row), c):\r\n\r\n                # Initializing a variable 'prev_max'.\r\n                prev_max = 0\r\n\r\n                for offset1 in range(max(0, c1 - 1), min(c-1, c1 + 1) + 1):\r\n                    for offset2 in range(max(0, c2-1), min(c-1, c2 + 1)+1):\r\n                        #  Updating the variable 'prev_max'.\r\n                        prev_max = max(prev_max, prev_dp[offset1][offset2])\r\n\r\n                # Case when both are in same row.\r\n                if (c1 == c2):\r\n                    current_dp[c1][c2] = prev_max + grid[row][c1]\r\n                else:\r\n                    current_dp[c1][c2] = prev_max + \\\r\n                        grid[row][c1] + grid[row][c2]\r\n\r\n        prev_dp = current_dp\r\n\r\n    res = 0\r\n    for i in range(c):\r\n        for j in range(c):\r\n            # Updating the variable 'res' with max possible answer.\r\n            res = max(res, prev_dp[i][j])\r\n\r\n    return res\r\n",
                "lang_text": "py"
            }
        },
        "platform": "CODESTUDIO"
    }
}