{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 22891,
            "title": "NINJA AND THE GRID",
            "titleSlug": "ninja-and-the-grid_6194954",
            "content": "<h4 id=\"there-is-a-n-x-n-grid-in-which-some-cells-are-empty-while-others-are-blocked-empty-cells-are-denoted-by-and-blocked-cells-by-initially-the-ninja-is-standing-at-the-bottom-of-the-grid\">There is a N X N \u2018GRID\u2019 in which some cells are empty while others are blocked. Empty cells are denoted by \u2018.\u2019 and blocked cells by \u2018#\u2019. Initially, the ninja is standing at the bottom of the GRID.</h4>\n\n<h4 id=\"ninja-can-start-at-any-one-of-the-bottom-empty-cells-he-can-take-steps-either-up-or-right-i-e-from-the-cell-i-j-to-cell-i-1-j-or-i-j-1-the-ninja-can-not-move-outside-the-grid-once-he-has-taken-a-step-towards-right-then-he-cannot-take-steps-in-any-other-direction\">Ninja can start at any one of the bottom empty cells. He can take steps either up or right, i.e., from the cell ( i, j ) to cell ( i - 1,  j ) or ( i, j + 1 ). The ninja can not move outside the grid. Once he has taken a step towards right then, he cannot take steps in any other direction.</h4>\n\n<h4 id=\"you-need-to-calculate-the-number-of-ways-he-can-reach-the-right-end-of-the-grid\">You need to calculate the number of ways he can reach the right end of the grid.</h4>\n\n<h4 id=\"note-ninja-can-not-pass-through-the-blocked-cells\">Note: Ninja can not pass through the blocked cells.</h4>\n\n<h5 id=\"example\">Example:</h5>\n\n<pre><code>Input:\n\n\u2018N\u2019 = 3\n\u2018GRID\u2019 = [ # . .  ] [ # . . ] [ # . . ]\n\nFollowing are the possible ways:\n\n( 2, 1 ) =&gt; ( 2, 2 )\n( 2, 1 ) =&gt; ( 1, 1 ) =&gt; ( 1, 2 )\n( 2, 1 ) =&gt; ( 1, 1 ) =&gt; ( 0, 1 ) =&gt; ( 0, 2 )\n( 2, 2 )\n( 2, 2 ) =&gt; ( 1, 2 )\n( 2, 2 ) =&gt; ( 1, 2 ) =&gt; ( 0, 2 )\n\nWhere ( i, j ) denotes the cell GRID [ i ] [ j ].\n</code></pre>\n\n<h5 id=\"input-format\">Input Format:</h5>\n\n<pre><code>The first line contains \u2018T,\u2019 denoting the number of test cases.\n\nThe first line of each test case contains \u2018N\u2019 denoting the dimensions of the \u2018GRID\u2019.\n\nEach of the next \u2018N\u2019 lines contains \u2018N\u2019 characters denoting the cells of the \u2018GRID\u2019.\n</code></pre>\n\n<h5 id=\"output-format\">Output Format:</h5>\n\n<pre><code>Return the number of ways he can reach the right end of the \u2018GRID\u2019.\n</code></pre>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>You don&#39;t need to print anything. It has already been taken care of. Just implement the given function.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints :</h5>\n\n<pre><code>1 &lt;= T &lt;= 10    \n1 &lt;= N &lt;= 1000\n\nTime Limit: 1 sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1:</h5>\n\n<pre><code>2\n3\n#.#\n#..\n#.#\n3\n###\n.#.\n.#.\n</code></pre>\n\n<p>Sample Output 1:</p>\n\n<pre><code>1\n2\n</code></pre>\n\n<h5 id=\"explanation-of-sample-input-1\">Explanation Of Sample Input 1:</h5>\n\n<pre><code>For the first test case:-\nThe only possible path is:\n( 2, 1 ) =&gt; ( 1, 1 ) =&gt; ( 1, 2 )\n\nFor the second test case:-\nFollowing are the possible ways:\n( 2, 2 ) =&gt; ( 2, 1 )\n( 2, 2 )\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2:</h5>\n\n<pre><code>2\n3\n#..\n#..\n#.#\n2\n..\n..\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2:</h5>\n\n<pre><code>2\n4\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": -9,
            "dislikes": "NA",
            "rephrased": {
                "body": "A ninja is positioned at the bottom row of an N x N grid. The grid contains empty cells ('.') and blocked cells ('#'). The ninja can start at any empty cell in the bottom row. The ninja can move up (i-1, j) or right (i, j+1). Once the ninja moves right, they cannot move up anymore. The goal is to find the number of paths the ninja can take to reach the rightmost end of the grid, avoiding blocked cells.",
                "constraints": [
                    "1 <= T <= 10",
                    "1 <= N <= 1000",
                    "Time Limit: 1 sec"
                ],
                "testcases": [
                    {
                        "input": "3\n#.#\n#..\n#.#",
                        "output": "1",
                        "explanation": "The only possible path is (2, 1) -> (1, 1) -> (1, 2)."
                    },
                    {
                        "input": "3\n###\n.#.\n.#.",
                        "output": "2",
                        "explanation": "The possible paths are (2, 2) -> (2, 1) and (2, 2)."
                    },
                    {
                        "input": "3\n#..\n#..\n#.#",
                        "output": "2",
                        "explanation": "Possible paths are:\n(2,1) -> (1,1) -> (1,2)\n(2,2)"
                    },
                    {
                        "input": "2\n..\n..",
                        "output": "4",
                        "explanation": "Possible paths are:\n(1,0) -> (0,0) \n(1,0) -> (0,1) \n(1,1) -> (0,0) \n(1,1) -> (0,1)"
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><strong>&nbsp;</strong>Try to find the cells whose right and down directions have no blocked cells.</p>",
            "<p><strong>&nbsp;</strong>can we optimise the solution with the help of precomputation?</p>"
        ],
        "relatedTopics": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ],
        "solutions": {},
        "platform": "CODESTUDIO"
    }
}