{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 8989,
            "title": "No Adjacent Same",
            "titleSlug": "no-adjacent-same_973005",
            "content": "<h4 id=\"you-are-given-a-32-bit-integer-n-at-the-right-of-the-leftmost-set-bit-your-task-is-to-check-if-there-are-no-two-adjacent-bits-that-are-the-same\">You are given a 32-bit integer &#39;N&#39;. At the right of the leftmost set bit, your task is to check if there are no two adjacent bits that are the same.</h4>\n\n<h5 id=\"for-example\">For Example :</h5>\n\n<pre><code>42 is valid because it&#39;s binary representation &#39;101010&#39; has no two adjacent bits that are the same.\n</code></pre>\n\n<h5 id=\"input-format\">Input Format :</h5>\n\n<pre><code>The first line contains a single integer T representing the number of test cases.\n\nThe first line of each test case will contain a single integer \u2018N\u2019 which denotes the given number.\n</code></pre>\n\n<h5 id=\"output-format\">Output Format :</h5>\n\n<pre><code>For each test case, return true if no two adjacent bits are the same at the right of the leftmost set bit otherwise return false.\n</code></pre>\n\n<h5 id=\"note\">Note:</h5>\n\n<pre><code>You don\u2019t need to print anything, it has already been taken care of. Just implement the given function.\n</code></pre>\n\n<h5 id=\"follow-up\">Follow Up:</h5>\n\n<pre><code> Can you solve this using O(1) time complexity?    \n</code></pre>\n\n<h5 id=\"constraints\">Constraints:</h5>\n\n<pre><code>1 &lt;= T &lt;= 10\n1 &lt;= N &lt;= 10^9\n\nTime Limit: 1 sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1:</h5>\n\n<pre><code>2\n21\n31\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1:</h5>\n\n<pre><code>true\nfalse\n</code></pre>\n\n<h5 id=\"explanation-for-sample-input-1\">Explanation For Sample Input 1:</h5>\n\n<pre><code>In example 1, binary representation of 21 is &#39;10101&#39;. Since, no two adjacent bits are the same here, it is valid.\nIn example 2, binary representation of 31 is \u201811111\u2019. All the digits of binary representation are the same, hence it is not valid.\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2:</h5>\n\n<pre><code>2\n20\n85\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2:</h5>\n\n<pre><code>false\ntrue\n</code></pre>\n\n<h5 id=\"explanation-for-sample-input-2\">Explanation For Sample Input 2:</h5>\n\n<pre><code>In example 1, binary representation of 20 is &#39;10100&#39;. Since, the 0-th and 1-st digits of the binary number are the same, it is invalid.\nIn example 2, binary representation of 85 is \u20181010101\u2019. Since, no two adjacent bits are the same here, it is valid.\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": 16,
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a 32-bit unsigned integer 'n', determine if the binary representation of 'n' to the right of the leftmost set bit contains no two adjacent bits that are the same. Return `true` if it does, and `false` otherwise.",
                "constraints": [
                    "1 <= T <= 10",
                    "1 <= N <= 10^9",
                    "Time Limit: 1 sec"
                ],
                "testcases": [
                    {
                        "input": "n = 21",
                        "output": "true",
                        "explanation": "The binary representation of 21 is '10101'. No two adjacent bits are the same to the right of the leftmost set bit, so the function should return true."
                    },
                    {
                        "input": "n = 31",
                        "output": "false",
                        "explanation": "The binary representation of 31 is '11111'.  All bits are the same, therefore adjacent bits are the same. The function should return false."
                    },
                    {
                        "input": "n = 20",
                        "output": "false",
                        "explanation": "The binary representation of 20 is '10100'. The last two bits are the same. Therefore, the function should return false."
                    },
                    {
                        "input": "n = 85",
                        "output": "true",
                        "explanation": "The binary representation of 85 is '1010101'. No two adjacent bits are the same to the right of the leftmost set bit, so the function should return true."
                    },
                    {
                        "input": "n = 42",
                        "output": "true",
                        "explanation": "The binary representation of 42 is '101010'. No two adjacent bits are the same to the right of the leftmost set bit, so the function should return true."
                    },
                    {
                        "input": "n = 64",
                        "output": "true",
                        "explanation": "The binary representation of 64 is '1000000'. No two adjacent bits are the same to the right of the leftmost set bit, so the function should return true."
                    },
                    {
                        "input": "n = 65",
                        "output": "false",
                        "explanation": "The binary representation of 65 is '1000001'. No two adjacent bits are the same to the right of the leftmost set bit, so the function should return true."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Can you iterate through each bit and check if adjacent bits are the same or different?</p>",
            "<p>Can you think of solving the problem using bitwise xor operation?</p>"
        ],
        "relatedTopics": [
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation"
            }
        ],
        "solutions": {},
        "platform": "CODESTUDIO"
    }
}