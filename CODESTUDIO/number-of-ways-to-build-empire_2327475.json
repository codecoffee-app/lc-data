{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 14964,
            "title": "Number of Ways to Build Empire",
            "titleSlug": "number-of-ways-to-build-empire_2327475",
            "content": "<h4 id=\"the-king-is-on-a-quest-to-conquer-the-entire-world\">The King is on a quest to conquer the entire world.</h4>\n\n<h4 id=\"there-are-n-kingdoms-in-the-world-numbered-from-0-to-n-1-each-kingdom-can-only-be-reached-from-exactly-one-of-the-other-kingdoms-except-the-0th-kingdom-where-the-king-lives-also-it-is-possible-to-reach-all-other-kingdoms-from-the-0th-kingdom\">There are \u2018N\u2019 kingdoms in the world numbered from 0 to N-1. Each kingdom can only be reached from exactly one of the other kingdoms, except the \u20180<sup>th</sup>\u2019 kingdom where the King lives. Also, it is possible to reach all other kingdoms from the 0<sup>th</sup> kingdom.</h4>\n\n<h4 id=\"that-is-the-world-is-made-up-of-a-network-of-kingdoms-in-form-of-a-tree-rooted-at-zero-you-are-given-an-array-prevkingdom-denoting-that-the-ith-kingdom-can-only-be-reached-from-the-prevkingdom-i-th-kingdom-and-prevkingdom-0-1\">That is, the world is made up of a network of kingdoms in form of a tree rooted at zero. You are given an array \u2018prevKingdom\u2019 denoting that the i<sup>th</sup> kingdom can only be reached from the \u2018prevKingdom[i]<sup>th</sup>\u2019 kingdom, and prevKingdom[0] = -1.</h4>\n\n<h4 id=\"the-king-initially-lives-in-the-0th-kingdom-but-he-wants-to-conquer-all-other-kingdoms-he-can-only-conquer-a-kingdom-if-all-other-kingdoms-lying-on-the-shortest-path-to-the-0th-kingdom-have-already-been-conquered\">The King initially lives in the 0<sup>th</sup> kingdom, but he wants to conquer all other kingdoms; he can only conquer a kingdom if all other kingdoms lying on the shortest path to the 0<sup>th</sup> kingdom have already been conquered.</h4>\n\n<h4 id=\"find-the-number-of-ways-in-which-the-king-can-conquer-the-entire-world-as-this-number-can-be-very-big-return-its-modulo-109-7\">Find the number of ways in which the King can conquer the entire world. As this number can be very big, return its modulo 10<sup>9</sup>+7.</h4>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>Two ways of conquering the world are considered different if the order in which the king conquered the kingdoms from 1 to N-1 are different. Refer to the example below for a better understanding.\n</code></pre>\n\n<h5 id=\"for-example\">For Example :</h5>\n\n<pre><code>If N = 4, prevKingdom = { -1, 0, 0, 1 } , then the network of kingdoms is denoted as: \n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/img1-eg-12667.jpg\" alt=\"\"></p>\n\n<pre><code>Then the King has 3 ways to conquer the world:\n0 -&gt; 1 -&gt; 2 -&gt; 3\n0 -&gt; 1 -&gt; 3 -&gt; 2\n0 -&gt; 2 -&gt; 1 -&gt; 3\nAll these 3 ways satisfy the constraint that before conquering any kingdom all the kingdoms on the shortest path to the 0th kingdom have been conquered, in other words: before conquering kingdom-3 the King must conquer kingdom-1.\n</code></pre>\n\n<h5 id=\"input-format\">Input Format :</h5>\n\n<pre><code>The first line contains a single integer \u2018T\u2019 denoting the number of test cases, then each test case follows:\n\nThe first line of each test case contains a single integer \u2018N\u2019 denoting the number of kingdoms.\n\nThe next line contains N integers, \u2018prevKingdom[i]\u2019 denoting that the ith kingdom can only be reached from the prevKingdom[i]^th kingdom. \n</code></pre>\n\n<h5 id=\"output-format\">Output Format :</h5>\n\n<pre><code>For each test case, print a single integer denoting the number of ways the King can conquer the world.\n\nOutput for each test case will be printed in a separate line.\n</code></pre>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>You are not required to print anything; it has already been taken care of. Just implement the function.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints :</h5>\n\n<pre><code>1 &lt;= T &lt;= 10      \n0 &lt;= N &lt;= 10000\n0 &lt;= prevKingdom[i] &lt; N, and prevKingdom[0] = -1\n\nTime limit: 1 sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1 :</h5>\n\n<pre><code>2\n4\n-1 0 0 1\n4\n-1 0 1 2 \n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1 :</h5>\n\n<pre><code>3\n1\n</code></pre>\n\n<h5 id=\"explanation-for-sample-input-1\">Explanation For Sample Input 1 :</h5>\n\n<pre><code>For test case 1 : \nWe will return 3, because:\n( 0 -&gt; 1 -&gt; 2 -&gt; 3 )\n( 0 -&gt; 1 -&gt; 3 -&gt; 2 )\n( 0 -&gt; 2 -&gt; 1 -&gt; 3 )\nare the only possible ways to conquer the world.\n\nFor test case 2 : \nWe will return 1, because:\n( 0 -&gt; 1 -&gt; 2 -&gt; 3 ) is the only possible way to conquer the world.\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2 :</h5>\n\n<pre><code>2\n8\n-1 0 0 1 2 3 3 4\n12\n-1 0 0 1 2 3 3 4 5 5 6 6\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2 :</h5>\n\n<pre><code>70\n13200\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 7,
            "dislikes": "NA",
            "rephrased": {
                "body": "The King embarks on a quest to conquer all 'N' kingdoms, numbered from 0 to N-1. The kingdom network forms a tree rooted at kingdom 0 (where the King resides). Each kingdom (except kingdom 0) is accessible from exactly one other kingdom. The 'prevKingdom' array indicates that kingdom 'i' can only be reached from kingdom 'prevKingdom[i]'. To conquer a kingdom, the King must first conquer all kingdoms on the shortest path back to kingdom 0.  Determine the number of distinct ways the King can conquer the entire world, modulo 10^9 + 7. Two conquering sequences are considered distinct if the order of conquering kingdoms 1 to N-1 differs.",
                "constraints": [
                    "1 <= T <= 10",
                    "0 <= N <= 10000",
                    "0 <= prevKingdom[i] < N, and prevKingdom[0] = -1",
                    "Time limit: 1 sec"
                ],
                "testcases": [
                    {
                        "input": "4\n-1 0 0 1",
                        "output": "3",
                        "explanation": "The possible conquering orders are:\n0 -> 1 -> 2 -> 3\n0 -> 1 -> 3 -> 2\n0 -> 2 -> 1 -> 3"
                    },
                    {
                        "input": "4\n-1 0 1 2",
                        "output": "1",
                        "explanation": "The only possible conquering order is:\n0 -> 1 -> 2 -> 3"
                    },
                    {
                        "input": "8\n-1 0 0 1 2 3 3 4",
                        "output": "70",
                        "explanation": null
                    },
                    {
                        "input": "12\n-1 0 0 1 2 3 3 4 5 5 6 6",
                        "output": "13200",
                        "explanation": null
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Consider a node with 2 children, if we already calculated the solution for subtrees rooted at both the child nodes, then how can we combine the result to get the answer for the current node?</p>",
            "<p>Try using depth-first search to implement the logic of combining child nodes.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            },
            {
                "name": "Trees",
                "slug": "trees"
            }
        ],
        "solutions": {},
        "platform": "CODESTUDIO"
    }
}