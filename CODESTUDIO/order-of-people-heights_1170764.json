{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 10176,
            "title": "Order of People Heights",
            "titleSlug": "order-of-people-heights_1170764",
            "content": "<h4 id=\"there-are-n-people-numbered-from-0-to-n-1-standing-in-a-queue-you-are-given-two-arrays-height-and-infront-consisting-of-n-non-negative-integers-height-i-gives-the-height-of-the-ith-person-and-infront-i-gives-the-number-of-persons-who-are-taller-than-the-ith-person-and-standing-in-front-of-the-ith-person\">There are \u2018N\u2019 people numbered from 0 to N - 1, standing in a queue. You are given two arrays \u2018Height\u2019 and \u2018Infront\u2018 consisting of \u2018N\u2019 non-negative integers. \u2018Height[i]\u2019 gives the height of the ith person, and \u2018Infront[i]\u2019  gives the number of persons who are taller than the ith person and standing in front of the ith person.</h4>\n\n<h4 id=\"your-task-is-to-find-out-the-actual-order-of-people-in-a-queue-you-should-print-n-integers-where-the-ith-integer-is-the-height-of-the-person-who-should-be-at-the-ith-position-from-the-start-of-the-queue\">Your task is to find out the actual order of people in a queue. You should print \u2018N\u2019 integers where the \u2018ith\u2019 integer is the height of the person who should be at the ith position from the start of the queue.</h4>\n\n<h4 id=\"note\">Note :</h4>\n\n<pre><code>1. Consider that all elements in array \u2018Height\u2019 are unique.\n2. It is guaranteed that a valid order always exists for the given array \u2018Height\u2019 and \u2018Infront\u2019. \n</code></pre>\n\n<h4 id=\"example\">Example :</h4>\n\n<pre><code>Let there are 6 people, their heights are given by array  \u2018Height\u2019 :  [5, 3, 2, 6, 1, 4],  and the number of people in front of them is given by array \u2018Infront\u2019: [0, 1, 2, 0, 3, 2]\n\nThus the actual order of people\u2019s height in the queue will be [5, 3, 2, 1, 6, 4]\n\nIn this order, the first person in a queue i.e a person with a height of 5, has no person in front of them who is taller than him.\nThe second person in a queue i.e a person with a height of 3 has 1 person (person with height 5) in front of them who is taller than him.\nThe third person in a queue i.e a person with a height of 2 has 2 people (people with height 5 and 3) in front of them who are taller than him.\nThe fourth person in a queue i.e a person with a height of 1 has 3 people (people with height 5, 3, 2) in front of them who are taller than him.\nThe fifth person in a queue i.e a person with a height of 6 has no person in front of them who is taller than him.\nThe sixth person in a queue i.e a person with a height of 4 has 2 people (people with height 5, and 6) in front of them who are taller than him.\n\nWe can observe this is the only possible order that is possible according to the array \u2018Infront\u2019.\n</code></pre>\n\n<h5 id=\"input-format\">Input format :</h5>\n\n<pre><code>The first line of input contains an integer \u2018T\u2019 denoting the number of test cases.\nThe next 3 * &#39;T&#39; lines represent the \u2018T\u2019 test cases.\n\nThe first line of each test case consists of a single integer \u2018N\u2019 representing the number of people in a queue.   \nThe second line of each test case consists of \u2018N\u2019 space-separated integers representing the array \u2018Height\u2019.\nThe third line of each test case consists of \u2018N\u2019 space-separated integers representing the array \u2018Infront\u2019.\n</code></pre>\n\n<h5 id=\"output-format\">Output format :</h5>\n\n<pre><code>For each test case, print \u2018N\u2019 integers where the \u2018ith\u2019 integer is the height of the person who should be at the ith position from the start of the queue.\n\nPrint the output of each test case in a new line.\n</code></pre>\n\n<h4 id=\"note\">Note :</h4>\n\n<pre><code>You do not need to print anything, it has already been taken care of. Just implement the given function.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints :</h5>\n\n<pre><code>1 &lt;= T &lt;= 50\n1  &lt;= N &lt;=  10^4\n1 &lt;= Height[i] &lt;= 10^9\n0 &lt;= Infront[i] &lt; \u2018N\u2019\n\nWhere \u2018T\u2019 is the total number of test cases, \u2018N\u2019 is the number of people in the queue, Height[i], and Infront[i] respectively are height and number of people in front of ith who are taller than him.\n\nTime limit: 1 sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1 :</h5>\n\n<pre><code>2\n5\n5 4 3 2 1\n0 0 0 0 0\n6\n5 3 2 6 1 4\n0 1 2 0 3 2\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1 :</h5>\n\n<pre><code>1 2 3 4 5\n5 3 2 1 6 4\n</code></pre>\n\n<h5 id=\"explanation-of-sample-input-1\">Explanation Of Sample Input 1 :</h5>\n\n<pre><code>Test case 1:\nThere is no person in front of any person who is taller than him, Thus all of them must be present in the queue in increasing order of their height.\n\nTest case 2:\nSee the problem statement for an explanation.\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2 :</h5>\n\n<pre><code>2\n2\n2 3\n1 0\n5\n1 2 3 4 5\n4 3 2 1 0\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2 :</h5>\n\n<pre><code>3 2\n5 4 3 2 1\n</code></pre>\n\n<p><br/></p>\n",
            "isPaidOnly": false,
            "difficulty": "Ninja",
            "likes": 232,
            "dislikes": "NA",
            "rephrased": {
                "body": "Given 'N' people with unique heights, numbered from 0 to N-1, standing in a queue. You are provided with two arrays: 'Height', representing the height of each person, and 'Infront', representing the number of taller people standing in front of each person. Determine the actual order of people in the queue based on their heights.  Return an array of 'N' integers representing the heights of the people in the correct order from the start of the queue.",
                "constraints": [
                    "1 <= T <= 50",
                    "1 <= N <= 10^4",
                    "1 <= Height[i] <= 10^9",
                    "0 <= Infront[i] < N",
                    "All elements in array \u2018Height\u2019 are unique.",
                    "A valid order always exists for the given array \u2018Height\u2019 and \u2018Infront\u2019."
                ],
                "testcases": [
                    {
                        "input": "5\n5 4 3 2 1\n0 0 0 0 0",
                        "output": "1 2 3 4 5",
                        "explanation": "Since no one has taller people in front, the queue must be sorted in ascending order of height."
                    },
                    {
                        "input": "6\n5 3 2 6 1 4\n0 1 2 0 3 2",
                        "output": "5 3 2 1 6 4",
                        "explanation": "The person with height 5 has 0 taller people in front. The person with height 3 has 1 taller person (5) in front. The person with height 2 has 2 taller people (5, 3) in front. The person with height 1 has 3 taller people (5, 3, 2) in front. The person with height 6 has 0 taller people in front. The person with height 4 has 2 taller people (5, 6) in front. This arrangement satisfies all Infront constraints."
                    },
                    {
                        "input": "2\n2 3\n1 0",
                        "output": "3 2",
                        "explanation": "The person with height 2 has 1 taller person in front (3). The person with height 3 has 0 taller people in front. Therefore, the order is 3, 2."
                    },
                    {
                        "input": "5\n1 2 3 4 5\n4 3 2 1 0",
                        "output": "5 4 3 2 1",
                        "explanation": "The person with height 1 has 4 taller people in front. The person with height 2 has 3 taller people in front. The person with height 3 has 2 taller people in front. The person with height 4 has 1 taller people in front. The person with height 5 has 0 taller people in front.  This leads to the descending order: 5, 4, 3, 2, 1."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Sort people by their height.</p>",
            "<p>Can we make the process of finding the kth empty position even more efficient?</p>",
            "<p>Try out all possible orders in which \u2018N\u2019 people can stand in a queue.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Sorting",
                "slug": "sorting"
            }
        ],
        "solutions": [
            {
                "lang": "cpp",
                "full_func": "/*\n    Time Complexity : O(N^2*(N!))\n    Space Complexity : O(N)\n\n    where  \u2018N\u2019 is the number of people.\n*/\n\n#include <algorithm>\n\nbool nextPermutaion(vector<int> &permutation, int n) {\n    // Find lexicographical next permuation of given vector.\n\n   for(int i = n-2; i >= 0; i--) {\n       if(permutation[i] < permutation[i+1]) {\n            int smallest = i+1;\n            for(int j = i+1; j < n; j++) {\n                if(permutation[j] > permutation[i] && permutation[j] < permutation[smallest]) {\n                    smallest = j;\n                }\n            }\n            swap(permutation[i], permutation[smallest]);\n            reverse(permutation.begin()+i+1, permutation.end());\n            return true;\n        }\n    }\n    return false;\n}\n\nvector<int> findOrder(vector<int> &height, vector<int> &infront) {\n    // Number of people in a queue.\n    int n = height.size();\n\n    // Create an array \u2018permutation\u2019 of size \u2018N\u2019 such that permutation[i]:= i.\n    vector<int> permutation(n);\n    for(int i = 0; i < n; i++) {\n        permutation[i] = i;\n    }\n\n    // It will have actual order of people in a queue.\n    vector<int> result(n);\n\n    // One by one check for all the permutations whether it is an actual order of people in a queue or not\n    do {\n        bool flag = true;\n        for(int i = 0; i < n; i++) {\n            // Count number of people taller than ith person and standing in front of it.\n            int tallerBefore = 0;\n            for(int j = 0; j < i; j++) {\n                if(height[permutation[j]] > height[permutation[i]]) {\n                    tallerBefore++;\n                }\n            }\n\n            if(tallerBefore != infront[permutation[i]]) {\n                // This permutation cannot be actual order of people in a queue.\n                flag = false;\n                break;\n            }\n        }\n\n        if(flag == true) {\n            // This permutation is actual order of people in a queue.\n            for(int i = 0; i < n; i++) {\n                result[i] = height[permutation[i]];\n            }\n            break;\n        }\n\n    } while(nextPermutaion(permutation, n) == true);\n\n    return result;\n}",
                "lang_text": "cpp"
            },
            {
                "lang": "python",
                "full_func": "'''\n    Time Complexity : O(N^2*(N!))\n    Space Complexity : O(N)\n\n    where  \u2018N\u2019 is the number of people.\n'''\n\n\ndef nextPermutaion(permutation, n):\n    # Find lexicographical next permuation of given list.\n\n    for i in range(n-2, -1, -1):\n        if (permutation[i] < permutation[i+1]):\n            smallest = i+1\n            for j in range(i+1, n):\n                if (permutation[j] > permutation[i] and permutation[j] < permutation[smallest]):\n                    smallest = j\n\n            get = permutation[i], permutation[smallest]\n            permutation[smallest], permutation[i] = get\n\n            rev = list(reversed(permutation[i+1:]))\n            permutation = permutation[:i+1] + rev\n            return permutation\n\n    return []\n\n\ndef findOrder(height, infront):\n    # Number of people in a queue.\n    n = len(height)\n\n    # Create an array \u2018permutation\u2019 of size \u2018N\u2019 such that permutation[i]:= i.\n    permutation = [i for i in range(n)]\n\n    # It will have actual order of people in a queue.\n    result = [0 for i in range(n)]\n\n    # One by one check for all the permutations whether it is an actual order of people in a queue or not.\n    while(True):\n        flag = True\n        for i in range(n):\n            # Count number of people taller than ith person and standing in front of it.\n            tallerBefore = 0\n            for j in range(i):\n                if (height[permutation[j]] > height[permutation[i]]):\n                    tallerBefore += 1\n\n            if (tallerBefore != infront[permutation[i]]):\n                # This permutation cannot be actual order of people in a queue.\n                flag = False\n                break\n\n        if (flag == True):\n            # This permutation is actual order of people in a queue.\n            for i in range(n):\n                result[i] = height[permutation[i]]\n            break\n\n        permutation = nextPermutaion(permutation, n)\n        if (len(permutation) == 0):\n            break\n\n    return result\n",
                "lang_text": "python"
            },
            {
                "lang": "java",
                "full_func": "/*\r\n    Time Complexity : O(N^2*(N!))\r\n    Space Complexity : O(N)\r\n\r\n    where  N is the number of people.\r\n*/\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class Solution {\r\n    static void swap(int[] a, int i, int j) {\r\n        int temp = a[i];\r\n        a[i] = a[j];\r\n        a[j] = temp;\r\n    }\r\n\r\n    static void reverse(int[] a, int x) {\r\n        int n = a.length;\r\n        n--;\r\n        while (x < n) {\r\n            swap(a, x, n);\r\n            x++;\r\n            n--;\r\n        }\r\n\r\n    }\r\n\r\n    static boolean nextPermutaion(int[] permutation, int n) {\r\n        // Find lexicographical next permuation of given vector.\r\n\r\n        for (int i = n - 2; i >= 0; i--) {\r\n            if (permutation[i] < permutation[i + 1]) {\r\n                int smallest = i + 1;\r\n                for (int j = i + 1; j < n; j++) {\r\n                    if (permutation[j] > permutation[i] && permutation[j] < permutation[smallest]) {\r\n                        smallest = j;\r\n                    }\r\n                }\r\n                swap(permutation, i, smallest);\r\n                reverse(permutation, i + 1);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public static ArrayList<Integer> findOrder(ArrayList<Integer> height, ArrayList<Integer> infront) {\r\n\r\n        int n = height.size();\r\n\r\n        // Create an array permutation of size N such that permutation[i]:= i.\r\n        int[] permutation = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            permutation[i] = i;\r\n        }\r\n\r\n        // It will have actual order of people in a queue.\r\n        ArrayList<Integer> result = new ArrayList<Integer>();\r\n        for (int i = 0; i < n; i++) {\r\n            result.add(0);\r\n        }\r\n\r\n        // One by one check for all the permutations whether it is an actual order of\r\n        // people in a queue or not\r\n        do {\r\n            boolean flag = true;\r\n            for (int i = 0; i < n; i++) {\r\n                // Count number of people taller than ith person and standing in front of it.\r\n                int tallerBefore = 0;\r\n                for (int j = 0; j < i; j++) {\r\n                    if (height.get(permutation[j]) > height.get(permutation[i])) {\r\n                        tallerBefore++;\r\n                    }\r\n                }\r\n\r\n                if (tallerBefore != infront.get(permutation[i])) {\r\n                    // This permutation cannot be actual order of people in a queue.\r\n                    flag = false;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (flag == true) {\r\n                // This permutation is actual order of people in a queue.\r\n                for (int i = 0; i < n; i++) {\r\n                    result.set(i, height.get(permutation[i]));\r\n                }\r\n                break;\r\n            }\r\n\r\n        } while (nextPermutaion(permutation, n) == true);\r\n\r\n        return result;\r\n    }\r\n}\r\n",
                "lang_text": "java"
            }
        ],
        "platform": "CODESTUDIO"
    }
}