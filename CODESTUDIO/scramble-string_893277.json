{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 8660,
            "title": "Scramble String",
            "titleSlug": "scramble-string_893277",
            "content": "<h4 id=\"you-are-given-an-integer-n-and-two-strings-s-and-r-each-having-size-n-you-can-scramble-the-string-s-to-obtain-string-r-using-the-following-operations\">You are given an integer \u2018N\u2019 and two strings \u2018S\u2019 and &#39;R&#39; each having size = \u2018N\u2019. You can scramble the string \u2018S\u2019 to obtain string &#39;R&#39; using the following operations:</h4>\n\n<h4 id=\"1-if-the-length-of-the-string-is-greater-than-1\">1. If the length of the string is greater than 1:</h4>\n\n<h4 id=\"select-any-random-index-and-split-the-string-into-two-non-empty-substrings-for-e-g-if-the-string-is-s-then-divide-it-into-two-non-empty-substrings-a-and-b-such-that-s-a-b\"><li>Select any random index and split the string into two non-empty substrings. For e.g: if the string is \u2018S\u2019, then divide it into two non-empty substrings \u2018A\u2019 and \u2018B\u2019 such that \u2018S\u2019 = \u2018A\u2019 + \u2018B\u2019.</h4>\n\n<h4 id=\"you-can-choose-to-swap-the-two-substrings-or-keep-them-in-the-same-order-i-e-after-this-operation-string-s-may-become-either-s-a-b-or-s-b-a\"><li>You can choose to swap the two substrings or keep them in the same order, i.e., after this operation string \u2018S\u2019 may become either \u2018S\u2019 = \u2018A\u2019 + \u2018B\u2019 or \u2018S\u2019 = \u2018B\u2019 + \u2018A\u2019.</h4>\n\n<h4 id=\"apply-the-first-step-recursively-on-each-of-the-two-strings-a-and-b\"><li>Apply the first step recursively on each of the two strings \u2018A\u2019 and \u2018B\u2019.</h4>\n\n<h4 id=\"2-if-the-length-of-the-string-is-equal-to-1-then-stop\">2. If the length of the string is equal to 1 then stop.</h4>\n\n<h4 id=\"your-task-is-to-return-true-if-r-is-a-scrambled-string-of-s-else-return-false\">Your task is to return true if &#39;R&#39; is a scrambled string of \u2018S\u2019 else return false.</h4>\n\n<h4 id=\"note\">Note:</h4>\n\n<pre><code>1. Both the strings are non-empty and are of the same length.\n\n2. You can apply the above operations any number of times on \u2018S\u2019.\n\n3. The operations can only be applied on the string \u2018S\u2019.\n\n4. \u2018S\u2019 and &#39;R&#39; consist of lowercase letters only.\n</code></pre>\n\n<h5 id=\"input-format\">Input Format:</h5>\n\n<pre><code>The first line of the input contains an integer &#39;T&#39; denoting the number of test cases.\n\nThe first line of each test case contains an integer \u2018N\u2019, denoting the size of the strings.\n\nThe second line of each test case contains two space-separated strings \u2018S\u2019 and &#39;R&#39;.\n</code></pre>\n\n<h5 id=\"output-format\">Output Format:</h5>\n\n<pre><code>For each test case print a single line containing either  \u201ctrue\u201d if the string &#39;R&#39; is a scrambled string of \u2018S\u2019, else \u201cfalse\u201d.\n</code></pre>\n\n<h5 id=\"note\">Note:</h5>\n\n<pre><code>You do not need to print anything, it has already been taken care of. Just implement the given function.\n</code></pre>\n\n<h5 id=\"constraints\">Constraints:</h5>\n\n<pre><code>1 &lt;= T &lt;= 50\n1 &lt;= len(S) &lt;= 30\n\nWhere \u2018len(S)\u2019 represents the length of the string \u2018S\u2019.\n\nTime Limit: 1 sec\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1:</h5>\n\n<pre><code>1\n5\ngreat rgeat \n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1:</h5>\n\n<pre><code>true\n</code></pre>\n\n<h5 id=\"explanation-for-sample-input-1\">Explanation for Sample Input 1:</h5>\n\n<pre><code>Note that the \u2018/\u2019 denotes the division of string.\nOne of the possible ways in which the operations can be applied on S is:\n\u201cgreat\u201d -&gt; \u201cgr/eat\u201d (Division at random index)\n\u201cgr/eat\u201d -&gt; \u201cgr/eat\u201d (Decided not to swap the two substrings and keep them in the same order.)\n\u201cgr/eat\u201d -&gt; \u201cg/r / e/at\u201d (Applying the same operation of division at random index recursively on both substrings).\n\u201cg/r / e/at\u201d -&gt; \u201cr/g / e/at\u201d (Random choice to swap the first substring and keeping the second substring same.)\n\u201cr/g / e/at\u201d -&gt; \u201cr/g / e/ a/t\u201d (Again applying the same algorithm recursively to divide at into a/t.)\n\u201cr/g / e/ a/t\u201d -&gt; \u201cr/g / e/ a/t\u201d (Random decision to keep the strings in same order and not swap them.)\nNow since the length of all the strings is equal to 1, we stop the algorithm and the result of S = \u201crgeat\u201d which is equal to T.\nHence return true.\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2:</h5>\n\n<pre><code>2\n1\na a\n5\npqrst  rptqs\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2:</h5>\n\n<pre><code>true\nfalse\n</code></pre>\n\n<h5 id=\"explanation-for-sample-input-2\">Explanation for Sample Input 2:</h5>\n\n<pre><code>For the first test case, since both the strings are equal, we return true.\n\nFor the second test case, there is no possible sequence of operations to make S equal to T. For example, \npqrst --&gt; cut p|qrst\np|qrst \u2192 cut p, qr|st\np, qr|st --&gt; scramble p, st, qr = pstqr which is scrambled and pq are apart. We cannot scramble rptqs into pqrst because there is no way in which we can cut pqrst such that prefix and suffix are anagrams of the correspondings in rptqs. See:\n\np | qrst --&gt; &#39;p&#39; not anagram of &#39;r&#39; nor &#39;s&#39;\npq | rst --&gt; pq not anagram of rp nor of qs\npqr | st --&gt; pqr not anagram of rpt nor of tqs\npqrs | t --&gt; pqrs not anagram of rptq nor of ptqs\n\nHence we return false.\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 16,
            "dislikes": "NA",
            "rephrased": {
                "body": "Given an integer 'N' and two strings 'S' and 'R', both of length 'N', determine if 'R' is a scrambled string of 'S'.  A scrambled string can be formed from 'S' by recursively splitting it into two non-empty substrings and optionally swapping them.  The operations are:\n\n1. **Splitting:** If the string's length is greater than 1, select a random index and split the string into two non-empty substrings, 'A' and 'B', such that 'S' = 'A' + 'B'.\n2. **Swapping (Optional):**  You can either swap the two substrings or keep them in the same order. 'S' can become either 'A' + 'B' or 'B' + 'A'.\n3. **Recursion:** Apply steps 1 and 2 recursively on 'A' and 'B'.\n\nReturn `true` if 'R' can be obtained from 'S' through these operations, and `false` otherwise.",
                "constraints": [
                    "1 <= T <= 50 (Number of test cases)",
                    "1 <= len(S) <= 30 (Length of string 'S')",
                    "Both strings are non-empty and have the same length.",
                    "Operations can only be applied to string 'S'.",
                    "Strings 'S' and 'R' consist of lowercase letters only.",
                    "Time Limit: 1 sec"
                ],
                "testcases": [
                    {
                        "input": "5\ngreat rgeat",
                        "output": "true",
                        "explanation": "One possible sequence of operations to transform 'great' to 'rgeat':\n1. 'great' -> 'gr/eat'\n2. 'gr/eat' -> 'gr/eat' (no swap)\n3. 'gr/eat' -> 'g/r / e/at'\n4. 'g/r / e/at' -> 'r/g / e/at' (swap 'g' and 'r')\n5. 'r/g / e/at' -> 'r/g / e/ a/t'\n6. 'r/g / e/ a/t' -> 'r/g / e/ a/t' (no swaps)\nResult: 'rgeat'"
                    },
                    {
                        "input": "1\na a",
                        "output": "true",
                        "explanation": "Since both strings are identical, the result is true."
                    },
                    {
                        "input": "5\npqrst  rptqs",
                        "output": "false",
                        "explanation": "There is no possible sequence of splits and swaps that will transform 'pqrst' into 'rptqs'. The letters 'p', 'q', 'r', 's', and 't' would have to be reordered using the permitted swaps of adjacent blocks after splitting.  In this case it is not possible to obtain 'rptqs' from 'pqrst' through the prescribed operations."
                    },
                    {
                        "input": "2\na a\n5\npqrst  rptqs",
                        "output": "true\nfalse",
                        "explanation": "First test case: Since both the strings are equal, we return true. Second test case: there is no possible sequence of operations to make S equal to T. For example, pqrst --> cut p|qrst ,p|qrst \u2192 cut p, qr|st ,p, qr|st --> scramble p, st, qr = pstqr which is scrambled and pq are apart. We cannot scramble rptqs into pqrst because there is no way in which we can cut pqrst such that prefix and suffix are anagrams of the correspondings in rptqs."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Try the simplest possible way.</p>",
            "<p>Try to think of storing every recursive solution.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Strings",
                "slug": "strings"
            },
            {
                "name": "Recursion",
                "slug": "recursion"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ],
        "solutions": {},
        "platform": "CODESTUDIO"
    }
}