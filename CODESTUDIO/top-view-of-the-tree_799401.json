{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 8007,
            "title": "Top View Of The Tree",
            "titleSlug": "top-view-of-the-tree_799401",
            "content": "<h4 id=\"you-are-given-a-binary-tree-of-n-nodes\">You are given a Binary Tree of <em><strong>&#39;n&#39;</strong></em> nodes.</h4>\n\n<p><br/></p>\n\n<h4 id=\"the-top-view-of-the-binary-tree-is-the-set-of-nodes-visible-when-we-see-the-tree-from-the-top\">The Top view of the binary tree is the set of nodes visible when we see the tree from the top.</h4>\n\n<p><br/></p>\n\n<h4 id=\"find-the-top-view-of-the-given-binary-tree-from-left-to-right\">Find the top view of the given binary tree, from left to right.</h4>\n\n<p><br/></p>\n\n<h5 id=\"example\">Example :</h5>\n\n<pre><code>Input: Let the binary tree be:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/top_view-5246.jpg\" alt=\"Example\"></p>\n\n<pre><code>Output: [10, 4, 2, 1, 3, 6]\n\nExplanation: Consider the vertical lines in the figure. The top view contains the topmost node from each vertical line.\n</code></pre>\n\n<h5 id=\"input-format\">Input format :</h5>\n\n<pre><code>The first line of input contains elements in the level order form for the first binary tree. The line consists of values of nodes separated by a single space. In case a node is null, we take -1 in its place.\n</code></pre>\n\n<h5 id=\"input-format-explanation\">Input format explanation:</h5>\n\n<pre><code>The level order input for the tree depicted in the below image would be \n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/0000000000004189.png\" alt=\"alt text\"></p>\n\n<pre><code>1\n2 3\n4 -1 5 6\n-1 7 -1 -1 -1 -1\n-1 -1\n\nThe sequence will be put together in a single line separated by a single space. Hence, for the above-depicted tree, the input will be given as:\n\n1 2 3 4 -1 5 6 -1 7 -1 -1 -1 -1 -1 -1\n\nExplanation :\nLevel 1 :\nThe root node of the tree is 1\n\nLevel 2 :\nLeft child of 1 = 2\nRight child of 1 = 3\n\nLevel 3 :\nLeft child of 2 = 4\nRight child of 2 = null (-1)\nLeft child of 3 = 5\nRight child of 3 = 6\n\nLevel 4 :\nLeft child of 4 = null (-1)\nRight child of 4 = 7\nLeft child of 5 = null (-1)\nRight child of 5 = null (-1)\nLeft child of 6 = null (-1)\nRight child of 6 = null (-1)\n\nLevel 5 :\nLeft child of 7 = null (-1)\nRight child of 7 = null (-1)\n\nThe first not-null node (of the previous level) is treated as the parent of the first two nodes of the current level. The second not-null node (of the previous level) is treated as the parent node for the next two nodes of the current level, and so on.\nThe input ends when all nodes at the last level are null (-1).\n</code></pre>\n\n<p><br/></p>\n\n<h5 id=\"output-format\">Output Format:</h5>\n\n<pre><code>Print the vector/list of all the elements of the top view of the given tree from left to right.\n</code></pre>\n\n<p><br/></p>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>You do not need to print anything; it has already been taken care of. Just implement the given function.\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1:</h5>\n\n<pre><code>1 2 3 4 5 -1 6 -1 7 -1 -1 8 -1 9 -1 -1 11 10 -1 -1 -1 -1 -1\n</code></pre>\n\n<p><br/></p>\n\n<h5 id=\"sample-output-1\">Sample Output 1:</h5>\n\n<pre><code>10 4 2 1 3 6\n</code></pre>\n\n<p><br/></p>\n\n<h5 id=\"explanation-of-sample-output-1\">Explanation of Sample Output 1:</h5>\n\n<pre><code>The binary tree is:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/top_view-5246.jpg\" alt=\"Example\"></p>\n\n<pre><code>Consider the vertical lines in the figure. The top view contains the topmost node from each vertical line.\n</code></pre>\n\n<p>In test case 1, </p>\n\n<p><br/></p>\n\n<h5 id=\"sample-input-2\">Sample Input 2:</h5>\n\n<pre><code>1 2 3 4 5 6 7 8 9 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n</code></pre>\n\n<p><br/></p>\n\n<h5 id=\"sample-output-2\">Sample Output 2:</h5>\n\n<pre><code>8 4 2 1 3 7\n</code></pre>\n\n<p><br/></p>\n\n<h5 id=\"explanation-of-sample-output-2\">Explanation of Sample Output 2:</h5>\n\n<pre><code>The binary tree is:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/topview-5245.jpg\" alt=\"Example\"></p>\n\n<pre><code>From left to right, the top view of the tree will be [8,4,2,1,3,7], where 9, 5 and 6 will be hidden when we see from the top of the tree.\n</code></pre>\n\n<p><br/></p>\n\n<h5 id=\"expected-time-complexity\">Expected time complexity :</h5>\n\n<pre><code>The expected time complexity is O(n * log(n)).\n</code></pre>\n\n<p><br/></p>\n\n<h5 id=\"constraints\">Constraints:</h5>\n\n<pre><code>1 &lt;= &#39;n&#39; &lt;= 10000\n1 &lt;= data in any node &lt;= 10 ^ 6\n\nTime limit: 1 sec\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 174,
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a binary tree of 'n' nodes, find the top view of the tree. The top view consists of the nodes that are visible when the tree is viewed from the top, ordered from left to right. The tree is provided in level order format where -1 denotes null node.",
                "constraints": [
                    "1 <= 'n' <= 10000",
                    "1 <= data in any node <= 10 ^ 6",
                    "Time limit: 1 sec"
                ],
                "testcases": [
                    {
                        "input": "1 2 3 4 5 -1 6 -1 7 -1 -1 8 -1 9 -1 -1 11 10 -1 -1 -1 -1 -1",
                        "output": "10 4 2 1 3 6",
                        "explanation": "Starting from the leftmost side, the nodes visible from the top are 10, 4, 2, 1, 3, and 6."
                    },
                    {
                        "input": "1 2 3 4 5 6 7 8 9 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1",
                        "output": "8 4 2 1 3 7",
                        "explanation": "From left to right, the top view of the tree is [8,4,2,1,3,7]. Nodes 9, 5, and 6 are hidden when viewed from the top."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>How will a node be hidden by another node?</p>",
            "<p>Can you think about using level order traversal?</p>"
        ],
        "relatedTopics": [
            {
                "name": "Binary Trees",
                "slug": "binary-trees"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "cpp",
                "full_func": "/*\n    Time Complexity: O(n * log(n))\n    Space Complexity : O(n)\n\n    Where 'n' is the number of nodes in the given binary tree.\n*/\n\n/************************************************************\n\n    Following is the TreeNode class structure:\n\n    template <typename T>\n    class TreeNode\n    {\n    public:\n        T data;\n        TreeNode<T> *left;\n        TreeNode<T> *right;\n\n        TreeNode(T dat)\n        {\n            this->data = dat;\n            left = NULL;\n            right = NULL;\n        }\n    };\n\n************************************************************/\n\n#include <map>\n#include <queue>\n\nvector<int> getTopView(TreeNode<int> *root)\n{\n    // For storing top view element.\n    vector<int> topView;\n\n    // Key will be the horizontal distance from root and value corresponding to that key will be the value of the node.\n    map<int, int> visited;\n\n    // If root is NULL then return the top view.\n    if (root == NULL)\n    {\n        return topView;\n    }\n\n    // For iterating level by level.\n    queue<pair<TreeNode<int> *, int>> level;\n\n    // Append root to the level with 0 horizontal distance.\n    level.push({root, 0});\n\n    // Iterate untill level does not become empty.\n    while (level.size() != 0)\n    {\n        // Get total number of node at current level.\n        int levelSize = level.size();\n\n        while (levelSize != 0)\n        {\n            // Get front of the queue.\n            pair<TreeNode<int> *, int> curr = level.front();\n            level.pop();\n\n            // Get the horizontal distance of curr node.\n            int hrDistance = curr.second;\n\n            // Get current node.\n            TreeNode<int> *currNode = curr.first;\n\n            // Check whether hDistance is visited or not. If not visited then only it will be seen by the top of the tree.\n            if (visited.count(hrDistance) == 0)\n            {\n                // Make it visited.\n                visited.insert({hrDistance, currNode->data});\n            }\n\n            // Append left child if it exist with horizontal distance one less than currNode.\n            if (currNode->left != NULL)\n            {\n                level.push({currNode->left, hrDistance - 1});\n            }\n\n            // Append right child if it exist with horizontal distance one more than currNode.\n            if (currNode->right != NULL)\n            {\n                level.push({currNode->right, hrDistance + 1});\n            }\n\n            levelSize = levelSize - 1;\n        }\n    }\n\n    // Now visited have the element which can be the view from the top of the tree\n    for (auto x : visited)\n    {\n        topView.push_back(x.second);\n    }\n\n    // Return the answer sequence of nodes.\n    return topView;\n}",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "java",
                "full_func": "/*\r\n    Time Complexity: O(n * log(n))\r\n    Space Complexity : O(n)\r\n\r\n    Where 'n' is the number of nodes in the given binary tree.\r\n*/\r\n\r\nimport java.util.List;\r\nimport java.util.ArrayList;\r\nimport java.util.Queue;\r\nimport java.util.LinkedList;\r\nimport java.util.Map;\r\nimport java.util.TreeMap;\r\nimport java.util.AbstractMap.SimpleEntry;\r\npublic class Solution {\r\n    public static List<Integer> getTopView(TreeNode root) {\r\n        // For storing top view element.\r\n        List<Integer> topView = new ArrayList<>();\r\n\r\n        // Key will be the horizontal distance from root and value corresponding to that key will be the value of the node.\r\n        Map<Integer, Integer> visited = new TreeMap<>();\r\n\r\n        // If root is null then return the top view.\r\n        if (root == null) {\r\n            return topView;\r\n        }\r\n\r\n        // For iterating level by level.\r\n        Queue<SimpleEntry<TreeNode, Integer>> level = new LinkedList<>();\r\n\r\n        // Append root to the level with 0 horizontal distance.\r\n        level.add(new SimpleEntry<>(root, 0));\r\n\r\n        // Iterate until level does not become empty.\r\n        while (!level.isEmpty()) {\r\n            // Get total number of node at current level.\r\n            int levelSize = level.size();\r\n\r\n            while (levelSize != 0) {\r\n\r\n                // Get total number of node at current level.\r\n                SimpleEntry<TreeNode, Integer> current = level.poll();\r\n\r\n                // Get the horizontal distance of curr node.\r\n                int hrDistance = current.getValue();\r\n\r\n                // Get current node.\r\n                TreeNode currentNode = current.getKey();\r\n\r\n                // Check whether hDistance is visited or not. If not visited then only it will be seen by the top of the tree.\r\n                if (!visited.containsKey(hrDistance)) {\r\n                    // Make it visited.\r\n                    visited.put(hrDistance, currentNode.data);\r\n                }\r\n\r\n                // Append left child if it exist with horizontal distance one less than currNode.\r\n                if (currentNode.left != null) {\r\n                    level.add(new SimpleEntry<>(currentNode.left, hrDistance - 1));\r\n                }\r\n\r\n                // Append right child if it exist with horizontal distance one more than currNode.\r\n                if (currentNode.right != null) {\r\n                    level.add(new SimpleEntry<>(currentNode.right, hrDistance + 1));\r\n                }\r\n                levelSize = levelSize - 1;\r\n            }\r\n        }\r\n        // Now visited have the element which can be the view from the top of the tree\r\n        topView.addAll(visited.values());\r\n\r\n        // Return the answer sequence of nodes.\r\n        return topView;\r\n    }\r\n}\r\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "python",
                "full_func": "''' \r\n    Time Complexity : O(N * log( N ))\r\n    Space Complexity : (N)\r\n\r\n    Where 'N' is the number of nodes in the given binary tree.\r\n'''\r\n\r\nfrom sys import stdin, setrecursionlimit\r\nfrom queue import Queue\r\nsetrecursionlimit(10**7)\r\n\r\n# Binary tree node class for reference.\r\nclass BinaryTreeNode:\r\n    def __init__(self, data):\r\n        self.val = data\r\n        self.left = None\r\n        self.right = None\r\n\r\ndef getTopView(root):\r\n    # For storing top view element.\r\n    topView = []\r\n\r\n    # Key will be the horizontal distance from root and value corresponding to that key will be the value of the node.\r\n    visited = dict()\r\n\r\n    # If root is None then return the top view.\r\n    if (root == None):\r\n        return topView\r\n\r\n    # For iterating level by level.\r\n    level = Queue()\r\n\r\n    # Append root to the level with 0 horizontal distance.\r\n    level.put((root, 0))\r\n\r\n    # Iterate untill level does not become empty.\r\n    while (level.qsize() > 0):\r\n\r\n        # Get total number of node at current level.\r\n        levelSize = level.qsize()\r\n\r\n        while (levelSize > 0):\r\n\r\n            # Get front of the queue.\r\n            curr = level.get()\r\n\r\n            # Get the horizontal distance of curr node.\r\n            hrDistance = curr[1]\r\n\r\n            # Get current node.\r\n            currNode = curr[0]\r\n\r\n            # Check whether hDistance is visited or not. If not visited then only it will be seen by the top of the tree.\r\n            if (hrDistance not in visited):\r\n                # Make it visited.\r\n                visited[hrDistance] = currNode.val\r\n\r\n            # Append left child if it exist with horizontal distance one less than currNode.\r\n            if (currNode.left != None):\r\n                level.put((currNode.left, hrDistance - 1))\r\n\r\n            # Append right child if it exist with horizontal distance one more than currNode.\r\n            if (currNode.right != None):\r\n                level.put((currNode.right, hrDistance + 1))\r\n\r\n            levelSize -= 1\r\n\r\n    # Now visited have the element which can be the view from the top of the tree.\r\n    for view in sorted(visited):\r\n        topView.append(visited[view])\r\n\r\n    # Return the answer sequence of nodes.\r\n    return topView\r\n\r\n# Taking input.\r\ndef takeInput():\r\n\r\n    arr = list(map(int, stdin.readline().strip().split(\" \")))\r\n\r\n    rootData = arr[0]\r\n\r\n    n = len(arr)\r\n\r\n    if(rootData == -1):\r\n        return None\r\n\r\n    root = BinaryTreeNode(rootData)\r\n    q = Queue()\r\n    q.put(root)\r\n    index = 1\r\n    while(q.qsize() > 0):\r\n        currentNode = q.get()\r\n\r\n        leftChild = arr[index]\r\n\r\n        if(leftChild != -1):\r\n            leftNode = BinaryTreeNode(leftChild)\r\n            currentNode.left = leftNode\r\n            q.put(leftNode)\r\n\r\n        index += 1\r\n        rightChild = arr[index]\r\n\r\n        if(rightChild != -1):\r\n            rightNode = BinaryTreeNode(rightChild)\r\n            currentNode .right = rightNode\r\n            q.put(rightNode)\r\n\r\n        index += 1\r\n\r\n    return root\r\n\r\n# Printing the tree nodes.\r\ndef printAns(ans):\r\n    for x in ans:\r\n        print(x, end=\" \")\r\n    print()\r\n\r\n\r\n# Main.\r\nT = 1\r\nfor i in range(T):\r\n    root = takeInput()\r\n    ans = getTopView(root)\r\n    printAns(ans)",
                "lang_text": "py"
            }
        },
        "platform": "CODESTUDIO"
    }
}