{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 9238,
            "title": "Tree Traversal",
            "titleSlug": "tree-traversal_981269",
            "content": "<h4 id=\"you-have-been-given-a-binary-tree-of-n\">You have been given a Binary Tree of <em><strong>&#39;N&#39;</strong></em></h4>\n\n<p>nodes, where the nodes have integer values. </p>\n\n<p><br></p>\n\n<h4 id=\"your-task-is-to-return-the-ln-order-pre-order-and-post-order-traversals-of-the-given-binary-tree\">Your task is to return the ln-Order, Pre-Order, and Post-Order traversals of the given binary tree.</h4>\n\n<p><br></p>\n\n<h5 id=\"for-example\">For example :</h5>\n\n<pre><code>For the given binary tree:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/tt1-6639.jpg\" alt=\"Binary - Tree1\"></p>\n\n<pre><code>The Inorder traversal will be [5, 3, 2, 1, 7, 4, 6].\nThe Preorder traversal will be [1, 3, 5, 2, 4, 7, 6].\nThe Postorder traversal will be [5, 2, 3, 7, 6, 4, 1].\n</code></pre>\n\n<h5 id=\"input-format\">Input Format :</h5>\n\n<pre><code>The first line contains elements of the tree in the level order form. The line consists of values of nodes separated by a single space. In case a node is null, we take -1 in its place.\n</code></pre>\n\n<h5 id=\"example\">Example :</h5>\n\n<pre><code>The input for the tree is depicted in the below image: \n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/tt2-6640.jpg\" alt=\"BT - 2\"></p>\n\n<pre><code>1 3 8 5 2 7 -1 -1 -1 -1 -1 -1 -1\n</code></pre>\n\n<h4 id=\"explanation\">Explanation :</h4>\n\n<pre><code>Level 1 :\nThe root node of the tree is 1\n\nLevel 2 :\nLeft child of 1 = 3\nRight child of 1 = 8\n\nLevel 3 :\nLeft child of 3 = 5\nRight child of 3 = 2\nLeft child of 8 =7\nRight child of 8 =  null (-1)\n\n\nLevel 4 :\nLeft child of 5 = null (-1)\nRight child of 5 = null (-1)\nLeft child of 2 = null (-1)\nRight child of 2 = null (-1)\nLeft child of 7 = null (-1)\nRight child of 7 = null (-1)\n\n1\n3 8\n5 2 7 -1\n-1 -1 -1 -1 -1 -1\n</code></pre>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>1. The first not-null node(of the previous level) is treated as the parent of the first two nodes of the current level. The second not-null node (of the previous level) is treated as the parent node for the next two nodes of the current level and so on.\n\n2. The input ends when all nodes at the last level are null(-1).\n\n3. The above format was just to provide clarity on how the input is formed for a given tree. The sequence will be put together in a single line separated by a single space. Hence, for the above-depicted tree, the input will be given as:\n\n1 3 8 5 2 7 -1 -1 -1 -1 -1 -1 -1\n</code></pre>\n\n<h5 id=\"output-format\">Output Format :</h5>\n\n<pre><code>The first line of output contains &#39;N&#39; single space-separated integers denoting the node&#39;s values in In-Order traversal.\n\nThe second line of output contains &#39;N&#39; single space-separated integers denoting the node&#39;s values in Pre-Order traversal.\n\nThe third line of output contains &#39;N&#39; single space-separated integers denoting the node&#39;s values in Post-Order traversal.\n</code></pre>\n\n<h5 id=\"note\">Note :</h5>\n\n<pre><code>You don&#39;t need to print anything, it has already been taken care of. Just implement the given function.\n</code></pre>\n<h5 id=\"sample-input-1\">Sample Input 1 :</h5>\n\n<pre><code>1 2 3 -1 -1 -1  6 -1 -1\n</code></pre>\n\n<h5 id=\"sample-output-1\">Sample Output 1 :</h5>\n\n<pre><code>2 1 3 6 \n1 2 3 6 \n2 6 3 1\n</code></pre>\n\n<h5 id=\"explanation-of-sample-output-1\">Explanation of Sample Output 1 :</h5>\n\n<pre><code> The given binary tree is shown below:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/tt3-6641.jpg\" alt=\"BT - 3\"></p>\n\n<pre><code>Inorder traversal of given tree = [2, 1, 3, 6]\nPreorder traversal of given tree = [1, 2, 3, 6]\nPostorder traversal of given tree = [2, 6, 3, 1]\n</code></pre>\n\n<h5 id=\"sample-input-2\">Sample Input 2 :</h5>\n\n<pre><code>1 2 4 5 3 -1 -1 -1 -1 -1 -1\n</code></pre>\n\n<h5 id=\"sample-output-2\">Sample Output 2 :</h5>\n\n<pre><code>5 2 3 1 4 \n1 2 5 3 4 \n5 3 2 4 1\n</code></pre>\n\n<h5 id=\"explanation-of-sample-output-2\">Explanation of Sample Output 2 :</h5>\n\n<pre><code>The given binary tree is shown below:\n</code></pre>\n\n<p><img src=\"https://files.codingninjas.in/tt5-6643.jpg\" alt=\"BT - 5\"></p>\n\n<pre><code>Inorder traversal of given tree = [5, 2, 3, 1, 4]\nPreorder traversal of given tree = [1, 2, 5, 3, 4]\nPostorder traversal of given tree = [5, 3, 2, 4, 1]\n</code></pre>\n\n<h5 id=\"constraints\">Constraints :</h5>\n\n<pre><code>1 &lt;= &#39;N&#39; &lt;= 10^5\n0 &lt;= &#39;data&#39; &lt;= 10^5     \n\nwhere &#39;N&#39; is the number of nodes and &#39;data&#39; denotes the node value of the binary tree nodes.\n\nTime limit: 1 sec\n</code></pre>\n",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": 251,
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a binary tree represented by its root node, your task is to implement a function that performs In-Order, Pre-Order, and Post-Order traversals of the tree. Return a vector of vectors, where each inner vector contains the node values for each traversal respectively.",
                "constraints": [
                    "1 <= 'N' <= 10^5, where 'N' is the number of nodes in the binary tree.",
                    "0 <= 'data' <= 10^5, where 'data' denotes the node value of the binary tree nodes.",
                    "Time limit: 1 sec"
                ],
                "testcases": [
                    {
                        "input": "root = TreeNode(1, TreeNode(2, NULL, NULL), TreeNode(3, NULL, TreeNode(6, NULL, NULL)))",
                        "output": "[[2, 1, 3, 6], [1, 2, 3, 6], [2, 6, 3, 1]]",
                        "explanation": "The given binary tree is shown below:\n\n     1\n   /   \\\n  2     3\n         \\\n          6\n\nInorder traversal of given tree = [2, 1, 3, 6]\nPreorder traversal of given tree = [1, 2, 3, 6]\nPostorder traversal of given tree = [2, 6, 3, 1]"
                    },
                    {
                        "input": "root = TreeNode(1, TreeNode(2, TreeNode(5, NULL, NULL), TreeNode(3, NULL, NULL)), TreeNode(4, NULL, NULL))",
                        "output": "[[5, 2, 3, 1, 4], [1, 2, 5, 3, 4], [5, 3, 2, 4, 1]]",
                        "explanation": "The given binary tree is shown below:\n\n     1\n   /   \\\n  2     4\n / \\\n5   3\n\nInorder traversal of given tree = [5, 2, 3, 1, 4]\nPreorder traversal of given tree = [1, 2, 5, 3, 4]\nPostorder traversal of given tree = [5, 3, 2, 4, 1]"
                    },
                    {
                        "input": "root = TreeNode(1, TreeNode(2, TreeNode(4, NULL, NULL), TreeNode(5, NULL, NULL)), TreeNode(3, NULL, NULL))",
                        "output": "[[4, 2, 5, 1, 3], [1, 2, 4, 5, 3], [4, 5, 2, 3, 1]]",
                        "explanation": "The given binary tree is shown below:\n\n        1\n       / \\\n      2   3\n     / \\\n    4   5\nInorder traversal of given tree = [4, 2, 5, 1, 3]\nPreorder traversal of given tree = [1, 2, 4, 5, 3]\nPostorder traversal of given tree = [4, 5, 2, 3, 1]"
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Think of a recursive solution.</p>",
            "<p>Think of an iterative solution.</p>",
            "<p>Think of an iterative solution using constant space.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Binary Trees",
                "slug": "binary-trees"
            },
            {
                "name": "Stacks & Queues",
                "slug": "stacks-&-queues"
            },
            {
                "name": "Recursion",
                "slug": "recursion"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "cpp",
                "full_func": "/*\r\n    Time Complexity: O(N)\r\n    Space Complexity: O(1)\r\n\r\n    where 'N' is the number of nodes in the tree.\r\n*/\r\n\r\n// Morris Traversal for inOrder\r\nvector<int> getInOrderTraversal(TreeNode *root) {\r\n\r\n    // Create answer array to store traversal\r\n    vector<int> answer;\r\n\r\n    // Base case\r\n    if (root == NULL) {\r\n        return answer;\r\n    }\r\n\r\n    // Predecessor will store predecessor node and\r\n    // Current wil store current node\r\n    TreeNode *current, *predecessor;\r\n\r\n    // Initialize current node as root .\r\n    current = root;\r\n\r\n    // Run a loop until current !=NULL\r\n    while (current != NULL) {\r\n        // If current -> left = NULL then add data of current to answer.\r\n        // And Move to right subtree of current\r\n        if (current->left == NULL) {\r\n            answer.push_back(current->data);\r\n            current = current->right;\r\n        }\r\n        else {\r\n\r\n            // Find the inorder predecessor of current node\r\n            // i.e. find the rightmost node on the left subtree of current\r\n            predecessor = current->left;\r\n            while (predecessor->right != NULL && predecessor->right != current) {\r\n                predecessor = predecessor->right;\r\n            }\r\n\r\n            // Make a link between predecessor and current node\r\n            // So that we have a path to come back to current\r\n            // When we have traversed the whole left subtree\r\n            if (predecessor->right == NULL) {\r\n                predecessor->right = current;\r\n                current = current->left;\r\n            }\r\n\r\n            // If right node of predecessor is not NULL then it\r\n            // Means we have traversed the whole left subtree.\r\n            // So we unlink the connection between current and predecessor\r\n            // And move to right node of current.\r\n            else {\r\n                predecessor->right = NULL;\r\n                answer.push_back(current->data);\r\n                current = current->right;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Return answer\r\n    return answer;\r\n\r\n}\r\n\r\n// Morris Traversal for preOrder\r\nvector<int> getPreOrderTraversal(TreeNode *root) {\r\n\r\n    // Create answer array to store traversal\r\n    vector<int> answer;\r\n\r\n    // Base case\r\n    if (root == NULL) {\r\n        return answer;\r\n    }\r\n\r\n    // Predecessor will store predecessor node and\r\n    // Current wil store current node\r\n    TreeNode *current, *predecessor;\r\n\r\n    // Initialize current node as root\r\n    current = root;\r\n\r\n    // Run a loop until current !=NULL\r\n    while (current != NULL)\r\n    {\r\n\r\n        if (current->left == NULL)\r\n        {\r\n            // Add current node data to answe\r\n            answer.push_back(current->data);\r\n\r\n            // Move to right child of current\r\n            current = current->right;\r\n        }\r\n        else\r\n        {\r\n            // Find predecessor of current node.\r\n            predecessor = current->left;\r\n            while (predecessor->right && predecessor->right != current) {\r\n                predecessor = predecessor->right;\r\n            }\r\n\r\n            // If the right child of predecessor already points to\r\n            // Current node then set right child as NULL and\r\n            // Move to right subtree of current\r\n            if (predecessor->right == current) {\r\n                predecessor->right = NULL;\r\n                current = current->right;\r\n            }\r\n\r\n            else {\r\n                // Add data of currrent node to answer\r\n                answer.push_back(current->data);\r\n\r\n                // Set right subtree of predecessor as current\r\n                predecessor->right = current;\r\n\r\n                // Move to left subtree of current\r\n                current = current->left;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Return answer\r\n    return answer;\r\n}\r\n\r\n// Morris Traversal for postOrder\r\nvector<int> getPostOrderTraversal(TreeNode *root) {\r\n\r\n    // Create answer array to store traversal\r\n    vector<int> answer;\r\n\r\n    // Base case\r\n    if (root == NULL) {\r\n        return answer;\r\n    }\r\n\r\n    // Predecessor will store predecessor and\r\n    // Current wil store current node\r\n    TreeNode *current, *predecessor;\r\n\r\n    // Initialize current node as root\r\n    current = root;\r\n\r\n    // Run a loop until current !=NULL\r\n    while (current != NULL)\r\n    {\r\n        // Check if right subtree of node is NULL instead of left\r\n        if (current->right == NULL)\r\n        {\r\n            // Add current node data to answe\r\n            answer.push_back(current->data);\r\n\r\n            // Move to left child of current\r\n            current = current->left;\r\n        }\r\n        else\r\n        {\r\n            // Find predecessor\r\n            predecessor = current->right;\r\n            while (predecessor->left != NULL && predecessor->left != current) {\r\n                predecessor = predecessor->left;\r\n            }\r\n\r\n            // If the left child of predecessor already points to\r\n            // Current node then set left child as NULL and\r\n            // Move to left subtree of current\r\n            if (predecessor->left == current) {\r\n                predecessor->left = NULL;\r\n                current = current->left;\r\n            }\r\n\r\n            else {\r\n                // Add data of currrent node to answer\r\n                answer.push_back(current->data);\r\n\r\n                // Set right subtree of predecessor as current\r\n                predecessor->left = current;\r\n\r\n                // Move to right subtree of current\r\n                current = current->right;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Reverse all elements of answer array\r\n    reverse(answer.begin(), answer.end());\r\n\r\n    // Return answer\r\n    return answer;\r\n}\r\n\r\nvector<vector<int>> getTreeTraversal(TreeNode *root)\r\n{\r\n    vector<vector<int>> result(3);\r\n\r\n    // Call function to get inOrder Traversal\r\n    result[0] = getInOrderTraversal(root);\r\n\r\n    // Call function to get preOrder Traversal\r\n    result[1] = getPreOrderTraversal(root);\r\n\r\n    // Call function to get postOrder Traversal\r\n    result[2] = getPostOrderTraversal(root);\r\n\r\n    // Return all 3 tree traversals\r\n    return result;\r\n}",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "java",
                "full_func": "/*\r\n    Time Complexity  : O(N)\r\n    Space Complexity : O(1)\r\n\r\n    Where 'N' is the total number of nodes in the binary tree.\r\n*/\r\n\r\nimport java.util.List;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n\r\npublic class Solution {\r\n\r\n    // Morris Traversal for inOrder.\r\n    private static List<Integer> getInOrderTraversal(TreeNode root) {\r\n\r\n        // Create answer array to store traversal.\r\n        List<Integer> answer = new ArrayList<>();\r\n\r\n        // Base case.\r\n        if (root == null) {\r\n            return answer;\r\n        }\r\n\r\n        // 'PREDECESSOR' and 'CURRENT' will store predecessor and current nodes, respectively.\r\n        TreeNode current;\r\n        TreeNode predecessor;\r\n\r\n        // Initialize 'CURRENT' node as root.\r\n        current = root;\r\n\r\n        // Run a loop until 'CURRENT' != NULL.\r\n        while (current != null) {\r\n            if (current.left == null) {\r\n                answer.add(current.data);\r\n                current = current.right;\r\n            } else {\r\n\r\n                // Find the rightmost node on the left subtree of current.\r\n                predecessor = current.left;\r\n                while (predecessor.right != null && predecessor.right != current) {\r\n                    predecessor = predecessor.right;\r\n                }\r\n\r\n                if (predecessor.right == null) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t\tMake a link between predecessor and current node\r\n\t\t\t\t\t\tSo that we have a path to come back to current\r\n\t\t\t\t\t\tWhen we have traversed the whole left subtree.\r\n\t\t\t\t\t*/\r\n                    predecessor.right = current;\r\n                    current = current.left;\r\n                }\r\n                else {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t\tIf right node of predecessor is not NULL then it\r\n\t\t\t\t\t\tMeans we have traversed the whole left subtree.\r\n\t\t\t\t\t\tSo we unlink the connection between current and predecessor\r\n\t\t\t\t\t\tAnd move to right node of current.\r\n\t\t\t\t\t*/\r\n                    predecessor.right = null;\r\n                    answer.add(current.data);\r\n                    current = current.right;\r\n                }\r\n            }\r\n        }\r\n        return answer;\r\n    }\r\n\r\n    // Morris Traversal for preOrder.\r\n    private static List<Integer> getPreOrderTraversal(TreeNode root) {\r\n\r\n        // Create answer array to store traversal.\r\n        List<Integer> answer = new ArrayList<>();\r\n\r\n        // Base case.\r\n        if (root == null) {\r\n            return answer;\r\n        }\r\n\r\n        // 'PREDECESSOR' and 'CURRENT' will store predecessor and current nodes, respectively.\r\n        TreeNode current;\r\n        TreeNode predecessor;\r\n\r\n        // Initialize current node as 'ROOT'.\r\n        current = root;\r\n\r\n        // Run a loop until 'CURRENT' != NULL.\r\n        while (current != null) {\r\n\r\n            if (current.left == null) {\r\n                // Add current node data to answer.\r\n                answer.add(current.data);\r\n\r\n                // Move to right child of current.\r\n                current = current.right;\r\n            } else {\r\n                // Find predecessor of current node.\r\n                predecessor = current.left;\r\n                while (predecessor.right != null && predecessor.right != current) {\r\n                    predecessor = predecessor.right;\r\n                }\r\n\r\n                if (predecessor.right == current) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t\tIf the right child of predecessor already points to\r\n\t\t\t\t\t\tCurrent node then set right child as NULL and\r\n\t\t\t\t\t\tMove to right subtree of current.\r\n\t\t\t\t\t*/\r\n                    predecessor.right = null;\r\n                    current = current.right;\r\n                }\r\n                else {\r\n                    // Add data of currrent node to answer.\r\n                    answer.add(current.data);\r\n\r\n                    // Set right subtree of predecessor as 'CURRENT'.\r\n                    predecessor.right = current;\r\n\r\n                    // Move to left subtree of 'CURRENT'.\r\n                    current = current.left;\r\n                }\r\n            }\r\n        }\r\n        return answer;\r\n    }\r\n\r\n    // Morris Traversal for postOrder.\r\n    private static List<Integer> getPostOrderTraversal(TreeNode root) {\r\n\r\n        // Create answer array to store traversal.\r\n        List<Integer> answer = new ArrayList<>();\r\n\r\n        // Base case.\r\n        if (root == null) {\r\n            return answer;\r\n        }\r\n\r\n        // 'PREDECESSOR' and 'CURRENT' will store predecessor and current nodes, respectively.\r\n        TreeNode current;\r\n        TreeNode predecessor;\r\n\r\n        // Initialize current node as root.\r\n        current = root;\r\n\r\n        // Run a loop until 'CURRENT' != NULL.\r\n        while (current != null) {\r\n            // Check if right subtree of node is null instead of left.\r\n            if (current.right == null) {\r\n                // Add current node data to 'ANSWER'.\r\n                answer.add(current.data);\r\n\r\n                // Move to left child of current.\r\n                current = current.left;\r\n            } else {\r\n                // Find predecessor.\r\n                predecessor = current.right;\r\n                while (predecessor.left != null && predecessor.left != current) {\r\n                    predecessor = predecessor.left;\r\n                }\r\n\r\n                if (predecessor.left == current) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t\tIf the left child of predecessor already points to\r\n\t\t\t\t\t\tCurrent node then set left child as NULL and\r\n\t\t\t\t\t\tMove to left subtree of current.\r\n\t\t\t\t\t*/\r\n                    predecessor.left = null;\r\n                    current = current.left;\r\n                }\r\n\r\n                else {\r\n                    // Add data of currrent node to answer.\r\n                    answer.add(current.data);\r\n\r\n                    // Set right subtree of predecessor as current.\r\n                    predecessor.left = current;\r\n\r\n                    // Move to right subtree of current.\r\n                    current = current.right;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Reverse all elements of 'ANSWER' array.\r\n        Collections.reverse(answer);\r\n\r\n        // Return answer.\r\n        return answer;\r\n    }\r\n\r\n    public static List<List<Integer>> getTreeTraversal(TreeNode root) {\r\n        List<List<Integer>> result = new ArrayList<>();\r\n\r\n        // Call function to get inOrder Traversal.\r\n        result.add(getInOrderTraversal(root));\r\n\r\n        // Call function to get preOrder Traversal.\r\n        result.add(getPreOrderTraversal(root));\r\n\r\n        // Call function to get postOrder Traversal.\r\n        result.add(getPostOrderTraversal(root));\r\n\r\n        // Return all 3 tree traversals.\r\n        return result;\r\n    }\r\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "python",
                "full_func": "'''\r\n    Time Complexity  : O(N)\r\n    Space Complexity : O(1)\r\n\r\n    Where 'N' is the total number of nodes in the binary tree.\r\n'''\r\n\r\n# Following is the Binary Tree node structure:\r\nclass BinaryTreeNode :\r\n    def __init__(self, data) :\r\n        self.data = data\r\n        self.left = None\r\n        self.right = None\r\n\r\n# Morris Traversal for inOrder.\r\ndef getInOrderTraversal(root):\r\n    # Create answer array to store traversal.\r\n    answer = []\r\n\r\n    # Base case.\r\n    if (root == None):\r\n        return answer\r\n\r\n    # 'PREDECESSOR' and 'CURRENT' will store predecessor and current nodes, respectively.\r\n    current = None\r\n    predecessor = None\r\n\r\n    # Initialize 'CURRENT' node as root.\r\n    current = root\r\n\r\n    # Run a loop until 'CURRENT' != None.\r\n    while (current != None):\r\n        if (current.left == None):\r\n            answer.append(current.data)\r\n            current = current.right\r\n        else:\r\n            # Find the rightmost node on the left subtree of current.\r\n            predecessor = current.left\r\n            while (predecessor.right != None and predecessor.right != current):\r\n                predecessor = predecessor.right\r\n\r\n            if (predecessor.right == None):\r\n                '''\r\n                    Make a link between predecessor and current node\r\n                    So that we have a path to come back to current\r\n                    When we have traversed the whole left subtree.\r\n                '''\r\n                predecessor.right = current\r\n                current = current.left\r\n            else:\r\n                '''\r\n                    If right node of predecessor is not None then it\r\n                    Means we have traversed the whole left subtree.\r\n                    So we unlink the connection between current and predecessor\r\n                    And move to right node of current.\r\n                '''\r\n                predecessor.right = None\r\n                answer.append(current.data)\r\n                current = current.right\r\n    return answer\r\n\r\n# Morris Traversal for preOrder.\r\ndef getPreOrderTraversal(root):\r\n\r\n    # Create answer array to store traversal.\r\n    answer = []\r\n\r\n    # Base case.\r\n    if (root == None):\r\n        return answer\r\n    \r\n\r\n    # 'PREDECESSOR' and 'CURRENT' will store predecessor and current nodes, respectively.\r\n    current = None\r\n    predecessor = None\r\n\r\n    # Initialize current node as 'ROOT'.\r\n    current = root\r\n\r\n    # Run a loop until 'CURRENT' != None.\r\n    while (current != None):\r\n        if (current.left == None):\r\n            # Add current node data to answer.\r\n            answer.append(current.data)\r\n            # Move to right child of current.\r\n            current = current.right\r\n        else:\r\n            # Find predecessor of current node.\r\n            predecessor = current.left\r\n            while (predecessor.right and predecessor.right != current):\r\n                predecessor = predecessor.right\r\n            \r\n            if (predecessor.right == current):\r\n                '''\r\n                    If the right child of predecessor already points to\r\n                    Current node then set right child as None and\r\n                    Move to right subtree of current.\r\n                '''\r\n                predecessor.right = None\r\n                current = current.right\r\n            else:\r\n                # Add data of currrent node to answer.\r\n                answer.append(current.data)\r\n                # Set right subtree of predecessor as 'CURRENT'.\r\n                predecessor.right = current\r\n                # Move to left subtree of 'CURRENT'.\r\n                current = current.left\r\n    return answer\r\n\r\n\r\n# Morris Traversal for postOrder.\r\ndef getPostOrderTraversal(root):\r\n    # Create answer array to store traversal.\r\n    answer = []\r\n\r\n    # Base case.\r\n    if (root == None):\r\n        return answer\r\n    \r\n    # 'PREDECESSOR' and 'CURRENT' will store predecessor and current nodes, respectively.\r\n    current = None\r\n    predecessor = None\r\n\r\n    # Initialize current node as root.\r\n    current = root\r\n\r\n    # Run a loop until 'CURRENT' != None.\r\n    while (current != None):\r\n        # Check if right subtree of node is None instead of left.\r\n        if (current.right == None):\r\n            # Add current node data to 'ANSWER'.\r\n            answer.append(current.data)\r\n            # Move to left child of current.\r\n            current = current.left\r\n        else:\r\n            # Find predecessor.\r\n            predecessor = current.right\r\n            while (predecessor.left != None and predecessor.left != current):\r\n                predecessor = predecessor.left\r\n            \r\n            if (predecessor.left == current):\r\n                '''\r\n                    If the left child of predecessor already points to\r\n                    Current node then set left child as None and\r\n                    Move to left subtree of current.\r\n                '''\r\n                predecessor.left = None\r\n                current = current.left\r\n            else:\r\n                # Add data of currrent node to answer.\r\n                answer.append(current.data)\r\n                # Set right subtree of predecessor as current.\r\n                predecessor.left = current\r\n                # Move to right subtree of current.\r\n                current = current.right\r\n\r\n    # Reverse all elements of 'ANSWER' array.\r\n    answer.reverse()\r\n\r\n    # Return answer.\r\n    return answer\r\n\r\n\r\ndef getTreeTraversal(root):\r\n    result = [[],[],[]]\r\n\r\n    # Call function to get inOrder Traversal.\r\n    result[0] = getInOrderTraversal(root)\r\n\r\n    # Call function to get preOrder Traversal.\r\n    result[1] = getPreOrderTraversal(root)\r\n\r\n    # Call function to get postOrder Traversal.\r\n    result[2] = getPostOrderTraversal(root)\r\n\r\n    # Return all 3 tree traversals.\r\n    return result\r\n",
                "lang_text": "py"
            }
        },
        "platform": "CODESTUDIO"
    }
}