{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 702902,
            "title": "Water Collection",
            "titleSlug": "amount-of-water1348",
            "content": "<p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">It is raining in Geek City. The height of the buildings in the city is given in an array <strong>arr[]</strong>. Calculate the amount of water that can be collected between all the buildings.</span></p>\n<p style=\"text-align: justify;\"><span style=\"font-size: 18px;\"><strong>Examples:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input: </strong>arr[] = [3, 0, 2, 0, 4]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong>\nGeek city looks like\n<img style=\"height: 250px; width: 500px;\" title=\"Click to enlarge\" src=\"https://media.geeksforgeeks.org/wp-content/uploads/20200429012307/Untitled-Diagram811.png\" alt=\"\" />\nWe can trap \"3 units\" of water between 3 and 2, \"1 unit\" <br />on top of bar 2 and \"3 units\" between 2 and 4. </span></pre>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong> arr[] = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong>\nThe structure is like below\n<img style=\"height: 268px; width: 500px;\" title=\"Click to enlarge\" src=\"https://media.geeksforgeeks.org/wp-content/uploads/20200429011707/Untitled-Diagram101.png\" alt=\"\" />\nTrap \"1 unit\" between first 1 and 2, \"4 units\" between <br />first 2 and 3 and \"1 unit\" between second last 1 and last 2.</span></pre>\n<p><br /><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:</strong> O(n)<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(1)</span></p>\n<p style=\"text-align: justify;\"><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>6</sup><br />1 &le; arr[i] &le; 10<sup>3</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given an array `arr[]` representing the heights of buildings in Geek City, calculate the total amount of water that can be trapped between the buildings after rainfall.",
                "constraints": [
                    "1 \u2264 arr.size() \u2264 10^6",
                    "1 \u2264 arr[i] \u2264 10^3"
                ],
                "testcases": [
                    {
                        "input": "[3, 0, 2, 0, 4]",
                        "output": "7",
                        "explanation": "The water trapped can be visualized as: 3 units between the buildings of height 3 and 2, 1 unit on top of the building of height 2, and 3 units between the buildings of height 2 and 4, resulting in a total of 7 units."
                    },
                    {
                        "input": "[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]",
                        "output": "6",
                        "explanation": "The water trapped is: 1 unit between the buildings of height 1 and 2, 4 units between the buildings of height 2 and 3, and 1 unit between the second last building of height 1 and the last building of height 2. The sum is 6 units."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span >If there is a larger wall to the right then the water can be retained with the height equal to the smaller wall on the left.&nbsp;</span></p>",
            "<p><span >If there are no larger walls to the right then start from the left. There must be a larger wall to the left now.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Arrays",
                "slug": "arrays"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [
            "amazon",
            "adobe"
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "//Back-end complete function template for C++\n\nclass Solution {\n  public:\n    int maxWater(vector<int>& arr) {\n        int n = arr.size();\n        int size = n - 1;\n        // Let the first element be stored as\n        // previous, we shall loop from index 1\n        int prev = arr[0];\n\n        // To store previous wall's index\n        int prev_index = 0;\n        int water = 0;\n\n        // To store the water until a larger wall\n        // is found, if there are no larger walls\n        // then delete temp value from water\n        int temp = 0;\n        for (int i = 1; i <= size; i++) {\n\n            // If the current wall is taller than\n            // the previous wall then make current\n            // wall as the previous wall and its\n            // index as previous wall's index\n            // for the subsequent loops\n            if (arr[i] >= prev) {\n                prev = arr[i];\n                prev_index = i;\n\n                // Because larger or same height wall is found\n                temp = 0;\n            } else {\n\n                // Since current wall is shorter than\n                // the previous, we subtract previous\n                // wall's height from the current wall's\n                // height and add it to the water\n                water += prev - arr[i];\n\n                // Store the same value in temp as well\n                // If we dont find any larger wall then\n                // we will subtract temp from water\n                temp += prev - arr[i];\n            }\n        }\n\n        // If the last wall was larger than or equal\n        // to the previous wall then prev_index would\n        // be equal to size of the array (last element)\n        // If we didn't find a wall greater than or equal\n        // to the previous wall from the left then\n        // prev_index must be less than the index\n        // of the last element\n        if (prev_index < size) {\n\n            // Temp would've stored the water collected\n            // from previous largest wall till the end\n            // of array if no larger wall was found then\n            // it has excess water and remove that\n            // from 'water' var\n            water -= temp;\n\n            // We start from the end of the array, so previous\n            // should be assigned to the last element\n            prev = arr[size];\n\n            // Loop from the end of array up to the 'previous index'\n            // which would contain the \"largest wall from the left\"\n            for (int i = size; i >= prev_index; i--) {\n                // Right end wall will be definitely smaller\n                // than the 'previous index' wall\n                if (arr[i] >= prev) {\n                    prev = arr[i];\n                } else {\n                    water += prev - arr[i];\n                }\n            }\n        }\n\n        // Return the maximum water\n        return water;\n    }\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n    public static int maxWater(int[] arr) {\n        int n = arr.length;\n        int size = n - 1;\n\n        // Let the first element be stored as previous, we shall loop from index 1\n        int prev = arr[0];\n\n        // To store previous wall's index\n        int prevIndex = 0;\n        int water = 0;\n\n        // To store the water until a larger wall is found, if there are no larger walls\n        // then delete temp value from water\n        int temp = 0;\n        for (int i = 1; i <= size; i++) {\n\n            // If the current wall is taller than the previous wall then make current\n            // wall as the previous wall and its index as previous wall's index\n            // for the subsequent loops\n            if (arr[i] >= prev) {\n                prev = arr[i];\n                prevIndex = i;\n\n                // Because larger or same height wall is found\n                temp = 0;\n            } else {\n\n                // Since current wall is shorter than the previous, we subtract previous\n                // wall's height from the current wall's height and add it to the water\n                water += prev - arr[i];\n\n                // Store the same value in temp as well\n                // If we don't find any larger wall then we will subtract temp from\n                // water\n                temp += prev - arr[i];\n            }\n        }\n\n        // If the last wall was larger than or equal to the previous wall then\n        // prevIndex would be equal to size of the array (last element)\n        // If we didn't find a wall greater than or equal to the previous wall from the\n        // left then prevIndex must be less than the index of the last element\n        if (prevIndex < size) {\n\n            // Temp would've stored the water collected from previous largest wall till\n            // the end of array if no larger wall was found then it has excess water and\n            // remove that from 'water' variable\n            water -= temp;\n\n            // We start from the end of the array, so previous should be assigned to the\n            // last element\n            prev = arr[size];\n\n            // Loop from the end of array up to the 'previous index' which would contain\n            // the \"largest wall from the left\"\n            for (int i = size; i >= prevIndex; i--) {\n                // Right end wall will be definitely smaller than the 'previous index'\n                // wall\n                if (arr[i] >= prev) {\n                    prev = arr[i];\n                } else {\n                    water += prev - arr[i];\n                }\n            }\n        }\n\n        // Return the maximum water\n        return water;\n    }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Solution:\n\n    def maxWater(self, arr):\n        n = len(arr)\n        size = n - 1\n\n        # Let the first element be stored as previous, we shall loop from index 1\n        prev = arr[0]\n\n        # To store previous wall's index\n        prev_index = 0\n        water = 0\n\n        # To store the water until a larger wall is found, if there are no larger walls\n        # then delete temp value from water\n        temp = 0\n        for i in range(1, size + 1):\n\n            # If the current wall is taller than the previous wall then make current\n            # wall as the previous wall and its index as previous wall's index\n            # for the subsequent loops\n            if arr[i] >= prev:\n                prev = arr[i]\n                prev_index = i\n\n                # Because larger or same height wall is found\n                temp = 0\n            else:\n\n                # Since current wall is shorter than the previous, we subtract previous\n                # wall's height from the current wall's height and add it to the water\n                water += prev - arr[i]\n\n                # Store the same value in temp as well\n                # If we don't find any larger wall then we will subtract temp from water\n                temp += prev - arr[i]\n\n        # If the last wall was larger than or equal to the previous wall then\n        # prev_index would be equal to size of the array (last element)\n        # If we didn't find a wall greater than or equal to the previous wall from the left\n        # then prev_index must be less than the index of the last element\n        if prev_index < size:\n\n            # Temp would've stored the water collected from previous largest wall till\n            # the end of array if no larger wall was found then it has excess water and\n            # remove that from 'water' variable\n            water -= temp\n\n            # We start from the end of the array, so previous should be assigned to the last element\n            prev = arr[size]\n\n            # Loop from the end of array up to the 'previous index' which would contain\n            # the \"largest wall from the left\"\n            for i in range(size, prev_index - 1, -1):\n                # Right end wall will be definitely smaller than the 'previous index' wall\n                if arr[i] >= prev:\n                    prev = arr[i]\n                else:\n                    water += prev - arr[i]\n\n        # Return the maximum water\n        return water\n",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "class Solution {\n    maxWater(arr) {\n        let n = arr.length;\n        const size = n - 1;\n\n        // Let the first element be stored as previous, we shall loop from index 1\n        let prev = arr[0];\n\n        // To store previous wall's index\n        let prevIndex = 0;\n        let water = 0;\n\n        // To store the water until a larger wall is found, if there are no larger walls\n        // then delete temp value from water\n        let temp = 0;\n        for (let i = 1; i <= size; i++) {\n\n            // If the current wall is taller than the previous wall then make current\n            // wall as the previous wall and its index as previous wall's index\n            // for the subsequent loops\n            if (arr[i] >= prev) {\n                prev = arr[i];\n                prevIndex = i;\n\n                // Because larger or same height wall is found\n                temp = 0;\n            } else {\n\n                // Since current wall is shorter than the previous, we subtract previous\n                // wall's height from the current wall's height and add it to the water\n                water += prev - arr[i];\n\n                // Store the same value in temp as well\n                // If we don't find any larger wall then we will subtract temp from\n                // water\n                temp += prev - arr[i];\n            }\n        }\n\n        // If the last wall was larger than or equal to the previous wall then\n        // prevIndex would be equal to size of the array (last element)\n        // If we didn't find a wall greater than or equal to the previous wall from the\n        // left then prevIndex must be less than the index of the last element\n        if (prevIndex < size) {\n\n            // Temp would've stored the water collected from previous largest wall till\n            // the end of array if no larger wall was found then it has excess water and\n            // remove that from 'water' variable\n            water -= temp;\n\n            // We start from the end of the array, so previous should be assigned to the\n            // last element\n            prev = arr[size];\n\n            // Loop from the end of array up to the 'previous index' which would contain\n            // the \"largest wall from the left\"\n            for (let i = size; i >= prevIndex; i--) {\n                // Right end wall will be definitely smaller than the 'previous index'\n                // wall\n                if (arr[i] >= prev) {\n                    prev = arr[i];\n                } else {\n                    water += prev - arr[i];\n                }\n            }\n        }\n\n        // Return the maximum water\n        return water;\n    }\n}\n",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}