{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 705655,
            "title": "Articulation Point - II",
            "titleSlug": "articulation-point2616",
            "content": "<p><span style=\"font-size: 18px;\">Given an undirected graph (not necessarily connected) with&nbsp;<strong>V&nbsp;</strong>vertices and adjacency list&nbsp;<strong>adj</strong>. You are required to find all the vertices removing which</span>&nbsp;<span style=\"font-size: 18px;\">(and edges through it) disconnects the graph into 2 or more components,</span>&nbsp;<span style=\"font-size: 18px;\">or in other words,&nbsp;removing which increases the number of connected components.</span><br /><span style=\"font-size: 18px;\"><strong>Note:&nbsp;</strong>Indexing is zero-based i.e nodes numbering from (0 to V-1). There might be loops present in the graph.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Example 1:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:\n</strong></span><img src=\"https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/705655/Web/Other/45dad444-f8bf-41ba-98a8-5aaee97661c3_1685087131.png\" alt=\"\" />\n<span style=\"font-size: 18px;\"><strong>Output:</strong>{1,4}\n<strong>Explanation: </strong>Removing the vertex 1 will\ndiscconect the graph as-\n</span><img src=\"https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/705655/Web/Other/7a95e57c-2585-49de-8a1e-fa9d132d05eb_1685087131.png\" alt=\"\" />\n<span style=\"font-size: 18px;\">Removing the vertex 4 will disconnect the\ngraph as-\n</span><img src=\"https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/705655/Web/Other/0fe03c03-a0d1-4b5b-bc17-bf2d8c67810e_1685087131.png\" alt=\"\" />\n</pre>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>articulationPoints</strong><strong>()&nbsp;</strong>which takes V and adj as input parameters and returns a list containing all the vertices removing which turn the graph into two or more disconnected components in sorted order. If there are no such vertices then returns a list containing -1.</span><br />&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:&nbsp;</strong>O(V + E)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(V)</span><br />&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; V &le; 10<sup>4</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Requires DFS</span></p>",
            "<p><span style=\"font-size:18px\">A simple approach is to one by one remove all vertices and see if removal of a vertex causes disconnected graph. Following are steps of simple approach for connected graph.</span></p>\n\n<p><span style=\"font-size:18px\">1) For every vertex v, do following<br />\n&hellip;..a) Remove v from graph<br />\n..&hellip;b) See if the graph remains connected (We can either use BFS or DFS)<br />\n&hellip;..c) Add v back to the graph</span></p>\n\n<p><span style=\"font-size:18px\">O(V*(V+E)) -- Complexity</span></p>",
            "<p><span style=\"font-size:18px\"><strong>A O(V+E) algorithm to find all&nbsp;<strong>A</strong>rticulation&nbsp;<strong>P</strong>oints (APs)</strong><br />\nThe idea is to use DFS (Depth First Search). In DFS, we follow vertices in tree form called DFS tree. In DFS tree, a vertex u is parent of another vertex v, if v is discovered by u (obviously v is an adjacent of u in graph). In DFS tree, a vertex u is articulation point if one of the following two conditions is true.<br />\n<strong>1)</strong>&nbsp;u is root of DFS tree and it has at least two children.<br />\n<strong>2)</strong>&nbsp;u is not root of DFS tree and it has a child v such that no vertex in subtree rooted with v has a back edge to one of the ancestors (in DFS tree) of u.</span></p>\n\n<p><span style=\"font-size:18px\">O(V+E) -- complexity</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Graph",
                "slug": "graph"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class Solution {\n\npublic:\n    void APUtil(vector<int> adj[], int u, bool visited[],\n                int disc[], int low[], int &time, int parent,\n                bool isAP[])\n    {\n        // Count of children in DFS Tree\n        int children = 0;\n\n        // Mark the current node as visited\n        visited[u] = true;\n\n        // Initialize discovery time and low value\n        disc[u] = low[u] = ++time;\n\n        // Go through all vertices aadjacent to this\n        for (auto v : adj[u])\n        {\n            // If v is not visited yet, then make it a child of u\n            // in DFS tree and recur for it\n            if (!visited[v])\n            {\n                children++;\n                APUtil(adj, v, visited, disc, low, time, u, isAP);\n\n                // Check if the subtree rooted with v has\n                // a connection to one of the ancestors of u\n                low[u]  = min(low[u], low[v]);\n\n                // If u is not root and low value of one of\n                // its child is more than discovery value of u.\n                if (parent != -1 && low[v] >= disc[u])\n                    isAP[u] = true;\n            }\n\n            // Update low value of u for parent function calls.\n            else if (v != parent)\n                low[u]  = min(low[u], disc[v]);\n        }\n\n\n        // If u is root of DFS tree and has two or more chilren.\n        if (parent == -1 && children > 1)\n            isAP[u] = true;\n    }\n\n    vector<int> articulationPoints(int V, vector<int>adj[]) {\n\n        vector<int> ans;  // vector to store the articulatipon points\n\n\n        int disc[V] = {0};\n        int low[V];\n        bool visited[V] = {false};\n        bool isAP[V] = {false};\n        int time = 0, par = -1;\n\n        // Adding this loop so that the\n        // code works even if we are given\n        // disconnected graph\n        for (int u = 0; u < V; u++)\n            if (!visited[u])\n                APUtil(adj, u, visited, disc, low,\n                       time, par, isAP);\n\n        // Printing the APs\n        for (int u = 0; u < V; u++)\n            if (isAP[u] == true)\n                ans.push_back(u);\n\n        //  for(int i=0; i<N; i++) {\n        //      if(arti[i])     // if ith node is an articulation point\n        //          ans.push_back(i);\n        //  }\n\n        if (ans.size() == 0)\n            ans.push_back(-1);\n\n        return ans;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution {\n    TreeSet<Integer> al = new TreeSet<>(); // TreeSet to store the articulation points\n    int time = 0; // variable to keep track of discovery time\n\n    public int[] articulationPoints(int v, ArrayList<ArrayList<Integer>> adj) {\n        int disc[] = new int[v]; // array to store the discovery time of each vertex\n        int low[] = new int[v]; // array to store the low points of each vertex\n        boolean visited[] = new boolean[v]; // boolean array to keep track of visited vertices\n\n        for (int i = 0; i < v; i++) {\n            if (!visited[i]) // if vertex is not visited, call the utility function\n                util(i, -1, adj, disc, low, visited);\n        }\n\n        if (al.size() == 0) { // if no articulation points found\n            int ans[] = {-1}; // return -1 as answer\n            return ans;\n        }\n\n        int ans[] = new int[al.size()]; // array to store the articulation points\n        int i = 0;\n        for (int x : al)\n            ans[i++] = x; // copy values from TreeSet to array\n\n        return ans;\n    }\n\n    void util(int v, int parent, ArrayList<ArrayList<Integer>> adj, int disc[], int low[], boolean visited[]) {\n        disc[v] = time; // set the discovery time of current vertex\n        low[v] = time++; // set the low point of current vertex\n        visited[v] = true; // mark current vertex as visited\n        int count = 0; // variable to count the number of child vertices\n\n        for (int x : adj.get(v)) { // iterate over the neighbors of current vertex\n            if (!visited[x]) { // if neighbor is not visited, call the utility function\n                util(x, v, adj, disc, low, visited);\n\n                count++; // increment the child count\n                low[v] = Math.min(low[v], low[x]); // update the low point of current vertex\n\n                if (parent != -1 && low[x] >= disc[v]) // if current vertex is not root and low point of neighbor is greater than or equal to discovery time of current vertex\n                    al.add(v); // add current vertex to the TreeSet\n            } else if (x != parent) { // if neighbor is visited and not parent of current vertex\n                low[v] = Math.min(low[v], disc[x]); // update the low point of current vertex\n            }\n        }\n\n        if (parent == -1 && count >= 2) // if current vertex is root and has two or more children\n            al.add(v); // add current vertex to the TreeSet\n    }\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "class Solution:\n    '''A recursive function that find articulation points\n    using DFS traversal\n    u --> The vertex to be visited next\n    visited[] --> keeps tract of visited vertices\n    disc[] --> Stores discovery times of visited vertices\n    parent[] --> Stores parent vertices in DFS tree\n    ap[] --> Store articulation points'''\n\n    def APUtil(self, u, visited, ap, parent, low, disc, adj, time):\n\n        # Count of children in current node\n        children = 0\n\n        # Mark the current node as visited and print it\n        visited[u] = True\n\n        # Initialize discovery time and low value\n        disc[u] = time\n        low[u] = time\n        time += 1\n\n        # Recur for all the vertices adjacent to this vertex\n        for v in adj[u]:\n            # If v is not visited yet, then make it a child of u\n            # in DFS tree and recur for it\n            if visited[v] == False:\n                parent[v] = u\n                children += 1\n                self.APUtil(v, visited, ap, parent, low, disc, adj, time)\n\n                # Check if the subtree rooted with v has a connection to\n                # one of the ancestors of u\n                low[u] = min(low[u], low[v])\n\n                # u is an articulation point in following cases\n                # (1) u is root of DFS tree and has two or more chilren.\n                if parent[u] == -1 and children > 1:\n                    ap[u] = True\n\n                # (2) If u is not root and low value of one of its child is more\n                # than discovery value of u.\n                if parent[u] != -1 and low[v] >= disc[u]:\n                    ap[u] = True\n\n                    # Update low value of u for parent function calls\n            elif v != parent[u]:\n                low[u] = min(low[u], disc[v])\n\n                # The function to do DFS traversal. It uses recursive APUtil()\n\n    def articulationPoints(self, V, adj):\n\n        # Mark all the vertices as not visited\n        # and Initialize parent and visited,\n        # and ap(articulation point) arrays\n        visited = [False] * (V)\n        disc = [float(\"Inf\")] * (V)\n        low = [float(\"Inf\")] * (V)\n        parent = [-1] * (V)\n        ap = [False] * (V)  # To store articulation points\n\n        # Call the recursive helper function\n        # to find articulation points\n        # in DFS tree rooted with vertex 'i'\n        time = 0\n        for i in range(V):\n            if visited[i] == False:\n                self.APUtil(i, visited, ap, parent, low, disc, adj, time)\n\n        flag = 0\n        ans = []\n        for index, value in enumerate(ap):\n            if value == True:\n                flag = 1\n                ans.append(index)\n        if flag == 0:\n            return [-1]\n        else:\n            return ans\n",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "\nclass Solution\n{\n    public List<int> articulationPoints(int V, List<int>[] adj)\n    {\n        int[] disc = new int[V];\n        int[] low = new int[V];\n        bool[] visited = new bool[V];\n        bool[] isAP = new bool[V];\n        List<int> result = new List<int>();\n\n        for (int i = 0; i < V; i++)\n        {\n            disc[i] = -1;\n            low[i] = int.MaxValue;\n        }\n\n        int time = 0;\n\n        for (int u = 0; u < V; u++)\n        {\n            if (!visited[u])\n            {\n                DFS(u, adj, visited, disc, low, ref time, -1, isAP);\n            }\n        }\n\n        for (int u = 0; u < V; u++)\n        {\n            if (isAP[u])\n            {\n                result.Add(u);\n            }\n        }\n\n        if (result.Count == 0)\n        {\n            result.Add(-1);\n        }\n\n        result.Sort();\n        return result;\n    }\n\n    private void DFS(int u, List<int>[] adj, bool[] visited, int[] disc, int[] low, ref int time, int parent, bool[] isAP)\n    {\n        visited[u] = true;\n        disc[u] = low[u] = ++time;\n        int children = 0;\n\n        foreach (int v in adj[u])\n        {\n            if (!visited[v])\n            {\n                children++;\n                DFS(v, adj, visited, disc, low, ref time, u, isAP);\n                low[u] = Math.Min(low[u], low[v]);\n\n                if (parent != -1 && low[v] >= disc[u])\n                {\n                    isAP[u] = true;\n                }\n            }\n            else if (v != parent)\n            {\n                low[u] = Math.Min(low[u], disc[v]);\n            }\n        }\n\n        if (parent == -1 && children > 1)\n        {\n            isAP[u] = true;\n        }\n    }\n}",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\n/**\n * @param {number} V\n * @param {number[][]} adj\n * @returns {number[]}\n*/\n\nclass Solution {\n    //Function to find articulation points in an undirected graph.\n    articulationPoints(V, adj){\n        \n        let visited = new Array(V).fill(false); //Mark all the vertices as not visited\n        let disc = new Array(V).fill(Number.MAX_SAFE_INTEGER); // Initialize discovery times of visited vertices\n        let low = new Array(V).fill(Number.MAX_SAFE_INTEGER); // Stores parent vertices in DFS tree\n        let parent = new Array(V).fill(-1); // Store articulation points\n        let ap = new Array(V).fill(false); //Stores parent vertices in DFS tree\n        let time = 0; // To store discovery time\n        \n        // A recursive function that find articulation points using DFS traversal\n        const APUtil = (u) => {\n            \n            let children = 0; // Count of children in current node\n            \n            visited[u] = true; // Mark the current node as visited \n            \n            disc[u] = time; // Initialize discovery time and low value\n            low[u] = time;\n            time++;\n            \n            // Recur for all the vertices adjacent to this vertex\n            for(let v of adj[u]){\n                if(!visited[v]){\n                    parent[v] = u; // If v is not visited yet, then make it a child of u in DFS tree and recur for it\n                    children++;\n                    APUtil(v);\n                    \n                    low[u] = Math.min(low[u], low[v]); // Check if the subtree rooted with v has a connection to one of the ancestors of u\n                    \n                    if(parent[u] === -1 && children > 1){ // u is an articulation point in following cases (1) u is root of DFS tree and has two or more chilren.\n                        ap[u] = true;\n                    }\n                    \n                    if(parent[u] !== -1 && low[v] >= disc[u]){ // (2) If u is not root and low value of one of its child is more than discovery value of u.\n                        ap[u] = true;\n                    }\n                }else if(v !== parent[u]){\n                    low[u] = Math.min(low[u], disc[v]);\n                }\n            }\n        }\n        \n        // Call the recursive helper function to find articulation points in DFS tree rooted with vertex 'i'\n        for(let i = 0; i < V; i++){\n            if(!visited[i]){\n                APUtil(i);\n            }\n        }\n        \n        let flag = 0;\n        let ans = [];\n        \n        for(let index in ap){\n            if(ap[index]){\n                flag = 1;\n                ans.push(parseInt(index));\n            }\n        }\n        \n        if(flag === 0){\n            return [-1];\n        }else{\n            return ans.sort((a, b) => a - b);\n        }\n    }\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}