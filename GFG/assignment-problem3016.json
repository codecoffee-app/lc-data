{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 705695,
            "title": "Assignment Problem",
            "titleSlug": "assignment-problem3016",
            "content": "<p><span style=\"font-size:18px\">You are the head of a firm and you have to assign jobs to people. You have <strong>N</strong> persons working under you and you have N jobs that are to be done by these persons. Each person has to do exactly one job and each job has to be done by exactly one person. Each person has his own capability (in terms of time taken) to do any particular job. Your task is to assign the jobs to the persons in such a way that the total time taken is minimum. A job can be assigned to only one person and a person can do only one job.</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong></span>\r\n<span style=\"font-size:18px\"><strong>N = </strong>2</span>\r\n<span style=\"font-size:18px\"><strong>Arr[] = </strong>{3, 5, 10, 1}</span>\r\n<span style=\"font-size:18px\"><strong>Output:</strong></span>\r\n<span style=\"font-size:18px\">4</span>\r\n<span style=\"font-size:18px\"><strong>Explanation:</strong></span>\r\n<span style=\"font-size:18px\">The first person takes times 3 and 5\r\nfor jobs 1 and 2 respectively. The second\r\nperson takes times 10 and 1 for jobs 1 and\r\n2 respectively. We can see that the optimal\r\nassignment will be to give job 1 to person 1\r\nand job 2 to person 2 for a total for 3+1 = 4.</span></pre>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 2:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong></span>\r\n<span style=\"font-size:18px\"><strong>N = </strong>3</span>\r\n<span style=\"font-size:18px\"><strong>Arr[] = </strong>{</span><span style=\"font-size:18px\">2, 1, 2,&nbsp;9, 8, 1, 1, 1, 1}</span>\r\n<span style=\"font-size:18px\"><strong>Output:</strong></span>\r\n<span style=\"font-size:18px\">3 \r\n<strong>Explanation: </strong>\r\nThe optimal arrangement would be to assign \r\njob 1 to person 3,job 2 to person 1 and job \r\n3 to person 2.</span>\r\n</pre>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Your Task:</strong><br />\r\nYou don&#39;t need to read input or print anything. Your task is to complete the function <strong>assignmentProblem()</strong> which takes an Integer N and an array Arr[] of size N<sup>2</sup> as input and returns the time taken for the best possible assignment.</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong> O(N<sup>2</sup>)<br />\r\n<strong>Expected Auxiliary Space:</strong> O(N<sup>2</sup>)</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Constraints:</strong></span><br />\r\n<span style=\"font-size:18px\">1 &lt;= N &lt;= 30<br />\r\n1 &lt;= Arr[i] &lt;= 100</span></p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "You are tasked with optimizing job assignments within a firm. Given N individuals and N jobs, each person must be assigned exactly one job, and each job must be completed by exactly one person. Each person has a different time cost associated with performing each job. Your goal is to determine the optimal assignment of jobs to people that minimizes the total time taken to complete all jobs.",
                "constraints": [
                    "1 <= N <= 30",
                    "1 <= Arr[i] <= 100"
                ],
                "testcases": [
                    {
                        "input": "N = 2\nArr[] = {3, 5, 10, 1}",
                        "output": "4",
                        "explanation": "There are two people and two jobs.  The cost matrix is:\nPerson 1: Job 1 - 3, Job 2 - 5\nPerson 2: Job 1 - 10, Job 2 - 1\nThe optimal assignment is Person 1 -> Job 1 (cost 3) and Person 2 -> Job 2 (cost 1), resulting in a total cost of 3 + 1 = 4."
                    },
                    {
                        "input": "N = 3\nArr[] = {2, 1, 2, 9, 8, 1, 1, 1, 1}",
                        "output": "3",
                        "explanation": "There are three people and three jobs. The cost matrix is:\nPerson 1: Job 1 - 2, Job 2 - 1, Job 3 - 2\nPerson 2: Job 1 - 9, Job 2 - 8, Job 3 - 1\nPerson 3: Job 1 - 1, Job 2 - 1, Job 3 - 1\nThe optimal assignment is Person 3 -> Job 1 (cost 1), Person 1 -> Job 2 (cost 1), and Person 2 -> Job 3 (cost 1), resulting in a total cost of 1 + 1 + 1 = 3."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Simple Dp will result in TLE. Use Hungarian Method to solve the problem.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Graph",
                "slug": "graph"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [
            "google"
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\r\n  public:\r\n  \r\n    int cost[31][31]; //cost matrix\r\n    int n, max_match; //n workers and n jobs\r\n    int lx[31], ly[31]; //labels of X and Y parts\r\n    int xy[31]; //xy[x] - vertex that is matched with x,\r\n    int yx[31]; //yx[y] - vertex that is matched with y\r\n    bool S[31], T[31]; //sets S and T in algorithm\r\n    int slack[31]; //as in the algorithm description\r\n    int slackx[31]; //slackx[y] such a vertex, that\r\n    int prev_ious[31]; //array for memorizing alternating p\r\n  \r\n    void init_labels()\r\n    {\r\n        memset(lx, 0, sizeof(lx));\r\n        memset(ly, 0, sizeof(ly));\r\n        for (int x = 0; x < n; x++)\r\n        for (int y = 0; y < n; y++)\r\n        lx[x] = max(lx[x], cost[x][y]);\r\n    }\r\n    \r\n     \r\n    void update_labels()\r\n    {\r\n        int x, y;\r\n        int delta = 99999999; //init delta as infinity\r\n        for (y = 0; y < n; y++) //calculate delta using slack\r\n            if (!T[y])\r\n                delta = min(delta, slack[y]);\r\n        for (x = 0; x < n; x++) //update X labels\r\n            if (S[x])\r\n                lx[x] -= delta;\r\n        for (y = 0; y < n; y++) //update Y labels\r\n            if (T[y])\r\n                ly[y] += delta;\r\n        for (y = 0; y < n; y++) //update slack array\r\n            if (!T[y])\r\n                slack[y] -= delta;\r\n    }\r\n    \r\n    \r\n    void add_to_tree(int x, int prev_iousx) \r\n    //x - current vertex,prev_iousx - vertex from X before x in the alternating path,\r\n    //so we add edges (prev_iousx, xy[x]), (xy[x], x)\r\n    {\r\n        S[x] = true; //add x to S\r\n        prev_ious[x] = prev_iousx; //we need this when augmenting\r\n        for (int y = 0; y < n; y++) //update slacks, because we add new vertex to S\r\n            if (lx[x] + ly[y] - cost[x][y] < slack[y])\r\n            {\r\n                slack[y] = lx[x] + ly[y] - cost[x][y];\r\n                slackx[y] = x;\r\n            }\r\n    }\r\n    \r\n    \r\n    \r\n    void augment() //main function of the algorithm\r\n    {\r\n        if (max_match == n) return; //check wether matching is already perfect\r\n        int x, y, root; //just counters and root vertex\r\n        int q[31], wr = 0, rd = 0; //q - queue for bfs, wr,rd - write and read\r\n        //pos in queue\r\n        memset(S, false, sizeof(S)); //init set S\r\n        memset(T, false, sizeof(T)); //init set T\r\n        memset(prev_ious, -1, sizeof(prev_ious)); //init set prev_ious - for the alternating tree\r\n        \r\n        for (x = 0; x < n; x++) //finding root of the tree\r\n        {\r\n            if (xy[x] == -1)\r\n            {\r\n                q[wr++] = root = x;\r\n                prev_ious[x] = -2;\r\n                S[x] = true;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        for (y = 0; y < n; y++) //initializing slack array\r\n        {\r\n            slack[y] = lx[root] + ly[y] - cost[root][y];\r\n            slackx[y] = root;\r\n        }\r\n        \r\n        //second part of augment() function\r\n        while (true) //main cycle\r\n        {\r\n            while (rd < wr) //building tree with bfs cycle\r\n            {\r\n                x = q[rd++]; //current vertex from X part\r\n                for (y = 0; y < n; y++) //iterate through all edges in equality graph\r\n                    if (cost[x][y] == lx[x] + ly[y] && !T[y])\r\n                    {\r\n                        if (yx[y] == -1) break; //an exposed vertex in Y found, so\r\n                                                //augmenting path exists!\r\n                            T[y] = true; //else just add y to T,\r\n                        q[wr++] = yx[y]; //add vertex yx[y], which is matched\r\n                        //with y, to the queue\r\n                        add_to_tree(yx[y], x); //add edges (x,y) and (y,yx[y]) to the tree\r\n                    }\r\n                if (y < n)\r\n                    break; //augmenting path found!\r\n            }\r\n            if (y < n)\r\n                break; //augmenting path found!\r\n            \r\n            update_labels(); //augmenting path not found, so improve labeling\r\n            \r\n            wr = rd = 0; \r\n            for (y = 0; y < n; y++) \r\n            //in this cycle we add edges that were added to the equality graph as a\r\n            //result of improving the labeling, we add edge (slackx[y], y) to the tree if\r\n            //and only if !T[y] && slack[y] == 0, also with this edge we add another one\r\n            //(y, yx[y]) or augment the matching, if y was exposed\r\n            if (!T[y] && slack[y] == 0)\r\n            {\r\n                if (yx[y] == -1) //exposed vertex in Y found - augmenting path exists!\r\n                {\r\n                    x = slackx[y];\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    T[y] = true; //else just add y to T,\r\n                    if (!S[yx[y]]) \r\n                    {\r\n                        q[wr++] = yx[y]; //add vertex yx[y], which is matched with\r\n                        //y, to the queue\r\n                        add_to_tree(yx[y], slackx[y]); //and add edges (x,y) and (y,\r\n                        //yx[y]) to the tree\r\n                    }\r\n                }\r\n            }\r\n            if (y < n) break; //augmenting path found!\r\n        }\r\n        \r\n        if (y < n) //we found augmenting path!\r\n        {\r\n            max_match++; //increment matching\r\n            //in this cycle we inverse edges along augmenting path\r\n            for (int cx = x, cy = y, ty; cx != -2; cx = prev_ious[cx], cy = ty)\r\n            {\r\n                ty = xy[cx];\r\n                yx[cy] = cx;\r\n                xy[cx] = cy;\r\n            }\r\n            augment(); //recall function, go to step 1 of the algorithm\r\n        }\r\n    }//end of augment() function\r\n     \r\n    int hungarian()\r\n    {\r\n        int ret = 0; //weight of the optimal matching\r\n        max_match = 0; //number of vertices in current matching\r\n        memset(xy, -1, sizeof(xy)); \r\n        memset(yx, -1, sizeof(yx));\r\n        init_labels(); //step 0\r\n        augment(); //steps 1-3\r\n        \r\n        for (int x = 0; x < n; x++) //forming answer there\r\n            ret += cost[x][xy[x]];\r\n    \r\n        return ret;\r\n    }\r\n    \r\n    int assignmentProblem(int Arr[], int N) {\r\n        \r\n        n = N;\r\n        for(int i=0; i<n; i++)\r\n            for(int j=0; j<n; j++)\r\n                cost[i][j] = -1*Arr[i*n+j];\r\n                \r\n        int ans = -1 * hungarian();\r\n        \r\n        return ans;\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": null,
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Solution:\n\n    def assignmentProblem(self, Arr, N):\n        n=N\n        l=Arr\n        m = []\n        m_beg = []\n\n        # Creating a matrix from the given array\n        for i in range(n):\n            m.append(l[i*n:(i+1)*n])\n            m_beg.append(l[i*n:(i+1)*n])\n\n        # Function to solve the assignment problem\n        def util():\n            u, v, ind = [0]*n, [0]*n, [-1]*n\n\n            # Finding the minimum cost assignment using Hungarian Algorithm\n            for i in range(n):\n                links, mins, visited = [-1]*n, [1000]*n, [False]*n\n                marked_i, marked_j = i, -1\n\n                while marked_i != -1:\n                    j = -1\n                    for j1 in range(n):\n                        if not visited[j1]:\n                            current = m[marked_i][j1] - u[marked_i] - v[j1]\n                            if current < mins[j1]:\n                                mins[j1] = current\n                                links[j1] = marked_j\n                            if j == -1 or mins[j1] < mins[j]:\n                                j = j1\n\n                    delta = mins[j]\n\n                    for j1 in range(n):\n                        if visited[j1]:\n                            u[ind[j1]] += delta\n                            v[j1] -= delta\n                        else:\n                            mins[j1] -= delta\n\n                    u[i] += delta\n                    visited[j] = True\n                    marked_j, marked_i = j, ind[j]\n\n                while links[j] != -1:\n                    ind[j] = ind[links[j]]\n                    j = links[j]\n\n                ind[j] = i\n\n            # Returning the assignment pairs\n            return [(ind[j], j) for j in range(n)]\n\n        # Finding the total cost of the assignment\n        return (sum(m_beg[x][y] for x,y in util()))",
                "lang_text": "py"
            }
        },
        "platform": "GFG"
    }
}