{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 700527,
            "title": "AVL Tree Deletion",
            "titleSlug": "avl-tree-deletion",
            "content": "<p><span style=\"font-size: 18px;\">Given an <strong>AVL tree</strong> and <strong>N</strong> values to be deleted from the tree. Write a function to delete a given value from the tree. All the <strong>N</strong> values which needs to be deleted are passed one by one as input <strong>data </strong>by driver code itself, you are asked to return the root of modified tree after deleting the value.</span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Example 1:\n</strong>\nTree = \n\\t  4\n\\t/   \\\n     2     6\n    / \\   / \\  \n   1   3 5   7</span>\n\n<span style=\"font-size: 18px;\">N = 4\nValues to be deleted = {4,1,3,6}</span>\n\n<span style=\"font-size: 18px;\"><strong>Input: </strong>Value to be deleted = 4\n<strong>Output:</strong>\n\\t  5    \n\\t/   \\\n     2     6\n    / \\     \\  \n   1   3     7</span>\n\n<span style=\"font-size: 18px;\"><strong>Input: </strong>Value to be deleted = 1\n<strong>Output:</strong>\n\\t  5    \n\\t/   \\\n     2     6\n\\t\\     \\  \n\\t 3     7</span>\n\n<span style=\"font-size: 18px;\"><strong>Input: </strong>Value to be deleted = 3\n<strong>Output:</strong>\n\\t  5    \n\\t/   \\\n     2     6\n\\t\\t\\  \n\\t\\t 7</span>\n\n<span style=\"font-size: 18px;\"><strong>Input: </strong>Value to be deleted = 6\n<strong>Output:</strong>\n\\t  5    \n\\t/   \\\n     2     7</span>\n\n</pre>\n<p><span style=\"font-size: 18px;\"><strong>Your Task: &nbsp;</strong><br />You dont need to read input or print anything. Complete the function<strong> delelteNode()</strong> which takes the root of the tree and the value of the node to be deleted as input parameters and returns the root of the modified tree.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Note:&nbsp;</strong>The tree will be checked after each deletion.&nbsp;<br />If it violates the properties of balanced BST, an error message will be printed followed by the inorder traversal of the tree at that moment.<br />If instead all deletion are successful, inorder traversal of tree will be printed.<br />If every single node is deleted from tree, 'null' will be printed.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:</strong> O(height of tree)<br /><strong>Expected Auxiliary Space: </strong>O(height of tree)</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; N &le; 500</span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given an AVL tree, delete a series of N values from the tree, one at a time. Your task is to implement the `deleteNode` function that removes a given value from the AVL tree and returns the root of the modified tree after each deletion. The deletion process should maintain the AVL tree properties (balance).",
                "constraints": [
                    "1 <= N <= 500"
                ],
                "testcases": [
                    {
                        "input": "Tree =  \n     4\n    /   \\\n   2     6\n  / \\   / \\\n 1   3 5   7\nValue to be deleted = 4",
                        "output": "     5    \n    /   \\\n   2     6\n  / \\     \\\n 1   3     7",
                        "explanation": "After deleting 4, the tree is rebalanced, resulting in root 5."
                    },
                    {
                        "input": "Tree =  \n     5    \n    /   \\\n   2     6\n  / \\     \\\n 1   3     7\nValue to be deleted = 1",
                        "output": "     5    \n    /   \\\n   2     6\n    \\     \\\n     3     7",
                        "explanation": "After deleting 1, the tree remains an AVL tree."
                    },
                    {
                        "input": "Tree =  \n     5    \n    /   \\\n   2     6\n    \\     \\\n     3     7\nValue to be deleted = 3",
                        "output": "     5    \n    /   \\\n   2     6\n        \\\n         7",
                        "explanation": "After deleting 3, the tree remains an AVL tree."
                    },
                    {
                        "input": "Tree =  \n     5    \n    /   \\\n   2     6\n        \\\n         7\nValue to be deleted = 6",
                        "output": "     5    \n    /   \\\n   2     7",
                        "explanation": "After deleting 6, the tree remains an AVL tree."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>AVL Tree is a self-balancing BST tree, hence after every deletion we must maintain this property of AVL Tree and it can basically be achieved by a concept of rotation in BST.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "AVL-Tree",
                "slug": "avl-tree"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Advanced Data Structure",
                "slug": "advanced-data-structure"
            }
        ],
        "companies": [
            "morgan-stanley",
            "amazon",
            "snapdeal",
            "makemytrip",
            "oracle",
            "oxigen-wallet"
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "//\r\n\r\n// Function to get height of a node\r\nint height(struct Node *N)\r\n{\r\n    if (N == NULL)\r\n        return 0;\r\n    return N->height;\r\n}\r\n\r\n// Function to perform a right rotation\r\nstruct Node *rightRotate(struct Node *y)\r\n{\r\n    struct Node *x = y->left;\r\n    struct Node *T2 = x->right;\r\n    x->right = y;\r\n    y->left = T2;\r\n    y->height = max(height(y->left), height(y->right))+1;\r\n    x->height = max(height(x->left), height(x->right))+1;\r\n    return x;\r\n}\r\n\r\n// Function to perform a left rotation\r\nstruct Node *leftRotate(struct Node *x)\r\n{\r\n    struct Node *y = x->right;\r\n    struct Node *T2 = y->left;\r\n    y->left = x;\r\n    x->right = T2;\r\n    x->height = max(height(x->left), height(x->right))+1;\r\n    y->height = max(height(y->left), height(y->right))+1;\r\n    return y;\r\n}\r\n\r\n// Function to get balance factor of a node\r\nint getBalance(struct Node *N)\r\n{\r\n    if (N == NULL)\r\n        return 0;\r\n    return height(N->left) - height(N->right);\r\n}\r\n\r\n// Function to find the node with minimum value in a given node\r\nstruct Node * minValueNode(struct Node* node)\r\n{\r\n    struct Node* current = node;\r\n    while (current->left != NULL)\r\n        current = current->left;\r\n    return current;\r\n}\r\n\r\n// Function to delete a node in the AVL tree\r\nstruct Node* deleteNode(struct Node* root, int data)\r\n{\r\n    if (root == NULL)\r\n        return root;\r\n    if ( data < root->data )\r\n        root->left = deleteNode(root->left, data);\r\n    else if( data > root->data )\r\n        root->right = deleteNode(root->right, data);\r\n    else\r\n    {\r\n        if( (root->left == NULL) || (root->right == NULL) )\r\n        {\r\n            struct Node *temp = root->left ? root->left :root->right;\r\n            if (temp == NULL)\r\n            {\r\n                temp = root;\r\n                root = NULL;\r\n            }\r\n            else \r\n             *root = *temp;\r\n            free(temp);\r\n        }\r\n        else\r\n        {\r\n            struct Node* temp = minValueNode(root->right);\r\n            root->data = temp->data;\r\n            root->right = deleteNode(root->right, temp->data);\r\n        }\r\n    }\r\n    if (root == NULL)\r\n      return root;\r\n    root->height = 1 + max(height(root->left),height(root->right));\r\n    int balance = getBalance(root);\r\n    if (balance > 1 && getBalance(root->left) >= 0)\r\n        return rightRotate(root);\r\n    if (balance > 1 && getBalance(root->left) < 0)\r\n    {\r\n        root->left =  leftRotate(root->left);\r\n        return rightRotate(root);\r\n    }\r\n    if (balance < -1 && getBalance(root->right) <= 0)\r\n        return leftRotate(root);\r\n    if (balance < -1 && getBalance(root->right) > 0)\r\n    {\r\n        root->right = rightRotate(root->right);\r\n        return leftRotate(root);\r\n    }\r\n    return root;\r\n}",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "// Back-end complete function Template for Java\n\nclass Sol {\n   public static int height(Node N)\n    {\n        // if Node is null, return height as 0\n        if (N == null)\n            return 0;\n        \n        // return the height of the Node\n        return N.height;\n    }\n\n    public static Node rightRotate(Node y)\n    {\n        // perform right rotation on the Node y\n        Node x = y.left;\n        Node T2 = x.right;\n        x.right = y;\n        y.left = T2;\n        // update the heights of the Nodes\n        y.height = Math.max(height(y.left), height(y.right))+1;\n        x.height = Math.max(height(x.left), height(x.right))+1;\n        return x;\n    }\n    \n    public static Node leftRotate(Node x)\n    {\n        // perform left rotation on the Node x\n        Node y = x.right;\n        Node T2 = y.left;\n        y.left = x;\n        x.right = T2;\n        // update the heights of the Nodes\n        x.height = Math.max(height(x.left), height(x.right))+1;\n        y.height = Math.max(height(y.left), height(y.right))+1;\n        return y;\n    }\n    \n    public static int getBalance(Node N)\n    {\n        // get the balance factor of the Node N\n        if (N == null)\n            return 0;\n        return height(N.left) - height(N.right);\n    }\n    \n    public static Node minValueNode(Node node)\n    {\n        // find the minimum value Node in the subtree rooted at node\n        Node current = node;\n        while (current.left != null)\n            current = current.left;\n     \n        return current;\n    }\n    public static Node deleteNode(Node root, int key)\n    {\n         if (root == null)\n            return root;\n \n        // if key is smaller than the root's key, recursively delete in left subtree\n        if (key < root.data)\n            root.left = deleteNode(root.left, key);\n \n        // if key is greater than the root's key, recursively delete in right subtree\n        else if (key > root.data)\n            root.right = deleteNode(root.right, key);\n \n        \n        else\n        {\n \n            // Node with only one child or no child\n            if ((root.left == null) || (root.right == null))\n            {\n                Node temp = null;\n                \n                // set temp to the non-null child\n                if (temp == root.left)\n                    temp = root.right;\n                else\n                    temp = root.left;\n \n                // if temp is null, set root to null\n                if (temp == null)\n                {\n                    temp = root;\n                    root = null;\n                }\n                else   \n                    root = temp; \n            }\n            else\n            {\n                // Node with two children\n                // find the inorder successor (smallest in the right subtree)\n                Node temp = minValueNode(root.right);\n \n                // copy the value of the inorder successor to the root\n                root.data = temp.data;\n \n                // recursively delete the inorder successor\n                root.right = deleteNode(root.right, temp.data);\n            }\n        }\n \n        // if root is null, return null\n        if (root == null)\n            return root;\n \n        // update the height of the root\n        root.height = Math.max(height(root.left), height(root.right)) + 1;\n \n        // get the balance factor of the root\n        int balance = getBalance(root);\n \n        // perform rotations based on the balance factor\n        if (balance > 1 && getBalance(root.left) >= 0)\n            return rightRotate(root);\n \n        if (balance > 1 && getBalance(root.left) < 0)\n        {\n            root.left = leftRotate(root.left);\n            return rightRotate(root);\n        }\n \n        if (balance < -1 && getBalance(root.right) <= 0)\n            return leftRotate(root);\n \n        if (balance < -1 && getBalance(root.right) > 0)\n        {\n            root.right = rightRotate(root.right);\n            return leftRotate(root);\n        }\n \n        return root;\n \n    }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "#Back-end complete function Template for Python 3\r\n\r\ndef getHeight(n):\r\n    if n is None:\r\n        return 0\r\n    return n.height\r\n\r\ndef getBalance(n):\r\n    return getHeight(n.left) - getHeight(n.right)\r\n\r\ndef leftRotate(z): \r\n    \r\n    y = z.right \r\n    T2 = y.left \r\n    \r\n    # Perform rotation \r\n    y.left = z \r\n    z.right = T2 \r\n    \r\n    # Update heights \r\n    z.height = 1 + max(getHeight(z.left), getHeight(z.right)) \r\n    y.height = 1 + max(getHeight(y.left), getHeight(y.right)) \r\n    \r\n    # Return the new root \r\n    return y\r\n\r\ndef rightRotate(z): \r\n    \r\n    y = z.left \r\n    T3 = y.right \r\n    \r\n    # Perform rotation \r\n    y.right = z \r\n    z.left = T3 \r\n    \r\n    # Update heights \r\n    z.height = 1 + max(getHeight(z.left), getHeight(z.right)) \r\n    y.height = 1 + max(getHeight(y.left), getHeight(y.right)) \r\n    \r\n    # Return the new root \r\n    return y\r\n\r\ndef deleteNode(root, key):\r\n    if root is None:\r\n        return None\r\n    \r\n    # step 1: searching for key:\r\n    if root.data > key:\r\n        root.left = deleteNode(root.left, key)\r\n    \r\n    elif root.data < key:\r\n        root.right = deleteNode(root.right, key)\r\n    \r\n    # step 2 : deleting key, if found:\r\n    else:\r\n        if root.left is None:\r\n            return root.right\r\n        \r\n        if root.right is None:\r\n            return root.left\r\n        \r\n        if root.right.left is None:\r\n            root.right.left = root.left\r\n            root = root.right\r\n            # balancing might be needed in this case\r\n        \r\n        else:\r\n            # finding next smallest node:\r\n            parent = root.right\r\n            nxt = parent.left\r\n            while nxt.left:\r\n                parent = nxt\r\n                nxt = nxt.left\r\n        \r\n            # swapping key with this node\r\n            parent.left = nxt.right\r\n            nxt.right , nxt.left = root.right , root.left\r\n            root = nxt\r\n            \r\n            # now, traversing downwards to balance the tree\r\n            # from bottom up\r\n            root.right = deleteNode(root.right, key)\r\n    \r\n    # step 3: balancing current node\r\n    balance = getBalance(root)\r\n    \r\n    if balance < -1:\r\n        \r\n        # case 1\r\n        if getBalance(root.right) < 1:\r\n            return leftRotate(root)\r\n        \r\n        # case 2\r\n        root.right = rightRotate(root.right)\r\n        return leftRotate(root)\r\n    \r\n    if balance > 1:\r\n        \r\n        # case 3\r\n        if getBalance(root.left) > -1:\r\n            return rightRotate(root)\r\n        \r\n        # case 4\r\n        root.left = leftRotate(root.left)\r\n        return rightRotate(root)\r\n    \r\n    root.height = 1 + max( getHeight(root.left) , getHeight(root.right) )\r\n    return root\r\n",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "//Back-end complete function Template for javascript\r\n\r\nclass Solution {\r\n  \tdeleteNode(root ,data){\r\n  \r\n  \t\t  if (root == null)\r\n            return root;\r\n \r\n        \r\n        if (data < root.data)\r\n            root.left = this.deleteNode(root.left, data);\r\n \r\n        \r\n        else if (data > root.data)\r\n            root.right = this.deleteNode(root.right, data);\r\n \r\n        \r\n        else\r\n        {\r\n \r\n            \r\n            if ((root.left == null) || (root.right == null))\r\n            {\r\n                let temp = null;\r\n                if (temp == root.left)\r\n                    temp = root.right;\r\n                else\r\n                    temp = root.left;\r\n \r\n               \r\n                if (temp == null)\r\n                {\r\n                    temp = root;\r\n                    root = null;\r\n                }\r\n                else   \r\n                    root = temp; \r\n            }\r\n            else\r\n            {\r\n \r\n               \r\n                let temp = this.minValueNode(root.right);\r\n \r\n               \r\n                root.data = temp.data;\r\n \r\n                \r\n                root.right = this.deleteNode(root.right, temp.data);\r\n            }\r\n        }\r\n \r\n       \r\n        if (root == null)\r\n            return root;\r\n \r\n        \r\n        root.height = Math.max(this.height(root.left),this.height(root.right)) + 1;\r\n \r\n       \r\n        let balance = this.getBalance(root);\r\n \r\n        \r\n        if (balance > 1 && this.getBalance(root.left) >= 0)\r\n            return this.rightRotate(root);\r\n \r\n       \r\n        if (balance > 1 && this.getBalance(root.left) < 0)\r\n        {\r\n            root.left = this.leftRotate(root.left);\r\n            return this.rightRotate(root);\r\n        }\r\n \r\n       \r\n        if (balance < -1 && this.getBalance(root.right) <= 0)\r\n            return this.leftRotate(root);\r\n \r\n       \r\n        if (balance < -1 && this.getBalance(root.right) > 0)\r\n        {\r\n            root.right = this.rightRotate(root.right);\r\n            return this.leftRotate(root);\r\n        }\r\n \r\n        return root;  \t\r\n      }\r\n\r\n\r\n    height(N)\r\n    {\r\n        if (N == null)\r\n            return 0;\r\n        return N.height;\r\n    }\r\n    max( a,  b)\r\n    {\r\n        return (a > b)? a : b;\r\n    }\r\n    newNode( key)\r\n    {\r\n        let node =new Node(0);\r\n        node.data = key;\r\n        node.left = null;\r\n        node.right = null;\r\n        node.height = 1; \r\n        return node;\r\n    }\r\n    rightRotate( y)\r\n    {\r\n        let x = y.left;\r\n        let T2 = x.right;\r\n        x.right = y;\r\n        y.left = T2;\r\n        y.height = this.max(this.height(y.left), this.height(y.right))+1;\r\n        x.height = this.max(this.height(x.left), this.height(x.right))+1;\r\n        return x;\r\n    }\r\n    leftRotate( x)\r\n    {\r\n        let y = x.right;\r\n        let T2 = y.left;\r\n        y.left = x;\r\n        x.right = T2;\r\n        x.height = this.max(this.height(x.left), this.height(x.right))+1;\r\n        y.height = this.max(this.height(y.left), this.height(y.right))+1;\r\n        return y;\r\n    }\r\n    getBalance( N)\r\n    {\r\n        if (N == null)\r\n            return 0;\r\n        return this.height(N.left) - this.height(N.right);\r\n    }\r\n    __getBalance__( root)\r\n    {\r\n       let lh;\r\n       let rh;\r\n       if(root == null)\r\n        return 1; \r\n       lh = this.height(root.left);\r\n       rh = this.height(root.right);\r\n       if( Math.abs(lh-rh) <= 1)\r\n           if(this.__getBalance__(root.left)==1)\r\n            if( this.__getBalance__(root.right)==1)\r\n                return 1;\r\n       return 0;\r\n    }\r\n\r\n    minValueNode(node)\r\n    {\r\n        let current = node;\r\n        while (current.left != null)\r\n            current = current.left;\r\n     \r\n        return current;\r\n    }\r\n}",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}