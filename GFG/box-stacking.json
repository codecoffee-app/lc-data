{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 700371,
            "title": "Box Stacking",
            "titleSlug": "box-stacking",
            "content": "<p><span style=\"font-size: 18px;\">You are given a set of some types of rectangular 3-D boxes, where the ith box has height, width, and length height[i], width[i], and length[i] respectively. You have to create a stack of boxes which is as tall as possible, but you can only stack a box on top of another box if the <strong>dimensions</strong> of the 2-D base of the lower box are each strictly larger than those of the 2-D base of the higher box. Of course, you can rotate a box so that any side functions as its base. It is also allowable to use multiple instances of the same type of box. Your task is to complete the function <strong>maxHeight</strong> which returns the height of the highest possible stack so formed.</span></p>\n<p><span style=\"font-size: 18px;\">Note: Base of the lower box should be strictly larger than that of the new box we're going to place. This is in terms of both length and width, not just in terms of area. So, two boxes with same base cannot be placed one over the other.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Examples:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input: </strong>height[] = [4, 1, 4, 10], width[] = [6, 2, 5, 12], length[] = [7, 3, 6, 32]\n<strong>Output:</strong> 60\n<strong>Explanation: </strong>One way of placing the boxes isas follows in the bottom to top manner: (Denoting the boxes in (l, w, h) manner)(12, 32, 10) (10, 12, 32) (6, 7, 4) (5, 6, 4) (4, 5, 6) (2, 3, 1) (1, 2, 3) Hence, the total height of this stack is 10 + 32 + 4 + 4 + 6 + 1 + 3 = 60. No other combination of boxes produces a height greater than this.</span>\n</pre>\n<pre><span style=\"font-size: 18px;\"><strong>Input</strong>: height[] = [1, 4, 3], width[] = [2, 5, 4], length[] = [3, 6, 1]\n<strong>Output:</strong> 15</span>\n<span style=\"font-size: 18px;\"><strong>Explanation: </strong>One way of placing the boxes is as follows in the bottom to top manner: (Denoting the boxes in (l, w, h) manner)(5, 6, 4) (4, 5, 6) (3, 4, 1), (2, 3, 1) (1, 2, 3).Hence, the total height of this stack is 4 + 6 + 1 + 1 + 3 = 15 No other combination of boxes produces a height greater than this.</span>\n</pre>\n<pre><span style=\"font-size: 18px;\"><strong>Input</strong>: height[] = [3], width[] = [2], length[] = [6]\n<strong>Output:</strong> 3<br /></span><strong style=\"font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">Explanation: </strong><span style=\"font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">There is only one box so max height is the height of the given box.</span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &nbsp;&le;&nbsp; number of boxes&nbsp; &le; &nbsp;100<br />1 &nbsp;&le;&nbsp; height[i],width[i],length[i]&nbsp; &le; &nbsp;100</span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a set of rectangular 3-D boxes, where each box has height, width, and length, the goal is to create the tallest possible stack of boxes. A box can be stacked on top of another only if the dimensions of the base of the lower box are strictly larger than those of the base of the higher box. Any side of a box can serve as its base, and multiple instances of the same type of box are allowed. Determine the maximum possible height of the stack.",
                "constraints": [
                    "1 <= number of boxes <= 100",
                    "1 <= height[i], width[i], length[i] <= 100"
                ],
                "testcases": [
                    {
                        "input": "height[] = [4, 1, 4, 10], width[] = [6, 2, 5, 12], length[] = [7, 3, 6, 32]",
                        "output": "60",
                        "explanation": "One possible stack arrangement (bottom to top): (12, 32, 10), (10, 12, 32), (6, 7, 4), (5, 6, 4), (4, 5, 6), (2, 3, 1), (1, 2, 3). Total height: 10 + 32 + 4 + 4 + 6 + 1 + 3 = 60."
                    },
                    {
                        "input": "height[] = [1, 4, 3], width[] = [2, 5, 4], length[] = [3, 6, 1]",
                        "output": "15",
                        "explanation": "One possible stack arrangement (bottom to top): (5, 6, 4), (4, 5, 6), (3, 4, 1), (2, 3, 1), (1, 2, 3). Total height: 4 + 6 + 1 + 1 + 3 = 15."
                    },
                    {
                        "input": "height[] = [3], width[] = [2], length[] = [6]",
                        "output": "3",
                        "explanation": "With only one box, the maximum height is simply the height of that box."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>This<a href=\"https://www.geeksforgeeks.org/variations-of-lis-dp-21/\">&nbsp;</a>is a variation of the LIS problem. We need to build a maximum height stack.</p>\n\n<p>Following are the key points to note in the problem statement:<br />\n1) A box can be placed on top of another box only if both width and depth of the upper placed box are smaller than width and depth of the lower box respectively.<br />\n2) We can rotate boxes such that width is smaller than depth. For example, if there is a box with dimensions {1x2x3} where 1 is height, 2&times;3 is base, then there can be three possibilities, {1x2x3}, {2x1x3} and {3x1x2}<br />\n3) We can use multiple instances of boxes. What it means is, we can have two different rotations of a box as part of our maximum height stack.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [
            "amazon",
            "microsoft",
            "codenation"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function template in C++\n\nclass Solution {\n  public:\n    // Function to calculate the maximum height of stack of boxes.\n    int maxHeight(vector<int> &height, vector<int> &width, vector<int> &length) {\n        int n = height.size();\n\n        int dp[10001]; // creating a dp array to store the maximum height\n        vector<pair<pair<int, int>, int> > v; // creating a vector of pair to store all\n                                              // possible combinations of dimensions\n        memset(dp, 0, sizeof dp);             // initializing the dp array with 0 values\n        v.clear();                            // clearing the vector\n\n        // iterating through every box\n        for (int i = 0; i < n; i++) {\n            int a, b, c;\n            a = height[i];\n            b = width[i];\n            c = length[i];\n\n            // adding all possible combinations of dimensions to the vector\n            v.push_back(make_pair(make_pair(a, b), c));\n            v.push_back(make_pair(make_pair(b, a), c));\n            v.push_back(make_pair(make_pair(a, c), b));\n            v.push_back(make_pair(make_pair(c, a), b));\n            v.push_back(make_pair(make_pair(b, c), a));\n            v.push_back(make_pair(make_pair(c, b), a));\n\n            sort(v.begin(), v.end()); // sorting the vector in lexicographically\n                                      // increasing order of dimensions\n        }\n\n        sort(v.begin(), v.end()); // sorting the vector in lexicographically increasing\n                                  // order of dimensions\n\n        // iterating through all the combinations of dimensions in the vector\n        for (int i = 0; i < v.size(); i++) {\n            dp[i] = v[i].second; // setting the height of the current combination as the\n                                 // height of the box\n\n            // iterating through all the previous combinations of dimensions\n            for (int j = 0; j < i; j++) {\n                if (v[i].first.first > v[j].first.first and\n                    v[i].first.second >\n                        v[j].first\n                            .second) { // checking if the current combination can be\n                                       // stacked on top of the previous combination\n                    dp[i] =\n                        max(dp[i],\n                            dp[j] + v[i].second); // updating the maximum height if the\n                                                  // current combination can be stacked\n                }\n            }\n        }\n\n        int m = INT_MIN; // initializing the maximum height to minimum possible value\n        for (int i = 0; i < v.size(); i++)\n            m = max(dp[i], m); // finding the maximum height among all the combinations\n\n        return m; // returning the maximum height\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\nclass Solution {\n    // Function to calculate the maximum possible height of the tower\n    public static int maxHeight(int height[], int width[], int length[]) {\n        int n = height.length;\n        // Create an array to store the maximum height for each box\n        int dp[] = new int[10001];\n        // Create an ArrayList to store pairs of box dimensions and heights\n        ArrayList<Pair2> list = new ArrayList<Pair2>();\n        list.clear();\n        // Iterate through each box\n        for (int i = 0; i < n; i++) {\n            // Get the dimensions of the box\n            int a = height[i];\n            int b = width[i];\n            int c = length[i];\n\n            // Create pairs of dimensions and heights for different orientations of the\n            // box\n            Pair1 ob1 = new Pair1(a, b);\n            Pair2 ob2 = new Pair2(ob1, c);\n            list.add(ob2);\n\n            Pair1 ob3 = new Pair1(b, a);\n            Pair2 ob4 = new Pair2(ob3, c);\n            list.add(ob4);\n\n            Pair1 ob5 = new Pair1(a, c);\n            Pair2 ob6 = new Pair2(ob5, b);\n            list.add(ob6);\n\n            Pair1 ob7 = new Pair1(c, a);\n            Pair2 ob8 = new Pair2(ob7, b);\n            list.add(ob8);\n\n            Pair1 ob9 = new Pair1(b, c);\n            Pair2 ob10 = new Pair2(ob9, a);\n            list.add(ob10);\n\n            Pair1 ob11 = new Pair1(c, b);\n            Pair2 ob12 = new Pair2(ob11, a);\n            list.add(ob12);\n\n            // Sort the list based on the width and length of each box\n            Collections.sort(list, new PoP());\n        }\n\n        // Sort the list again based on the width and length of each box\n        Collections.sort(list, new PoP());\n\n        // Calculate the maximum height for each box\n        for (int i = 0; i < list.size(); i++) {\n            dp[i] = list.get(i).c;\n\n            for (int j = 0; j < i; j++) {\n                // Check if the current box can be placed on top of the previous box\n                if (list.get(i).ob.a > list.get(j).ob.a &&\n                    list.get(i).ob.b > list.get(j).ob.b) {\n                    // Update the maximum height if the current box can be placed on top\n                    dp[i] = Math.max(dp[i], dp[j] + list.get(i).c);\n                }\n            }\n        }\n\n        // Find the maximum height among all the boxes\n        int m = Integer.MIN_VALUE;\n        for (int i = 0; i < list.size(); i++) {\n            m = Math.max(dp[i], m);\n        }\n\n        // Return the maximum height\n        return m;\n    }\n}\n\n// Class to represent a pair of dimensions\nclass Pair1 {\n    int a = 0, b = 0;\n\n    Pair1(int x, int y) {\n        this.a = x;\n        this.b = y;\n    }\n}\n\n// Class to represent a pair of box dimensions and height\nclass Pair2 {\n    Pair1 ob;\n    int c = 0;\n\n    Pair2(Pair1 ob, int z) {\n        this.ob = ob;\n        this.c = z;\n    }\n}\n\n// Comparator class to compare box dimensions for sorting\nclass PoP implements Comparator<Pair2> {\n    public int compare(Pair2 p21, Pair2 p22) {\n        if (p21.ob.a == p22.ob.a)\n            return p21.ob.b - p22.ob.b;\n        else\n            return p21.ob.a - p22.ob.a;\n    }\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\n\n\nclass Solution:\n\n    def maxHeight(self, height, width, length):\n        #Code here\n        n = len(height)\n        dp = [0 for i in range(10005)]\n        rot = []\n        for i in range(n):\n            a = height[i]\n            b = width[i]\n            c = length[i]\n            rot.append([[a, b], c])\n            rot.append([[b, a], c])\n            rot.append([[a, c], b])\n            rot.append([[c, a], b])\n            rot.append([[b, c], a])\n            rot.append([[c, b], a])\n            rot.sort()\n        rot.sort\n        for i in range(len(rot)):\n            # print rot[i][0][0], rot[i][0][1], rot[i][1]\n            dp[i] = rot[i][1]\n            for j in range(i):\n                if rot[i][0][0] > rot[j][0][0] and rot[i][0][1] > rot[j][0][1]:\n                    dp[i] = max(dp[i], dp[j] + rot[i][1])\n        return max(dp)\n",
                "lang_text": "python3"
            },
            {
                "lang": "Javascript",
                "full_func": "//Back-end complete function Template for JavaScript\n\nclass Solution {\n\n    // Function to find the maximum height\n    // Input: height (array of heights), width (array of widths), length (array of\n    // lengths), n (number of elements) Output: Maximum height\n\n    // Function to calculate the maximum height\n    maxHeight(height, width, length) {\n        let n = height.length;\n        // Initialize an array to store the maximum heights\n        let dp = [];\n\n        // Initialize the array with 0s (assumes a maximum of 1001 elements)\n        for (let i = 0; i < 1001; i++) {\n            dp.push(0);\n        }\n\n        // Create a nested array to store all possible combinations of dimensions\n        let v = [];\n\n        // Iterate through the given arrays to generate the combinations\n        for (let i = 0; i < n; i++) {\n            let a = height[i];\n            let b = width[i];\n            let c = length[i];\n\n            // Add all possible combinations of dimensions to the array\n            v.push([ a, b, c ]);\n            v.push([ a, c, b ]);\n            v.push([ b, a, c ]);\n            v.push([ b, c, a ]);\n            v.push([ c, a, b ]);\n            v.push([ c, b, a ]);\n        }\n\n        // Sort the array of combinations based on the first dimension\n        v.sort((l1, l2) => {\n            if (l1[0] === l2[0]) {\n                return l1[1] - l2[1];\n            } else {\n                return l1[0] - l2[0];\n            }\n        });\n\n        // Calculate the maximum height using dynamic programming\n        for (let i = 0; i < v.length; i++) {\n            // Set the default maximum height as the current combination's height\n            dp[i] = v[i][2];\n\n            // Iterate through all previous combinations\n            for (let j = 0; j < i; j++) {\n                if (v[i][0] > v[j][0] && v[i][1] > v[j][1]) {\n                    // If the current combination's dimensions are greater, update the\n                    // maximum height\n                    dp[i] = Math.max(dp[i], dp[j] + v[i][2]);\n                }\n            }\n        }\n\n        // Find the maximum height in the dp array\n        let x = 0;\n        for (let i = 0; i < v.length; i++) {\n            x = Math.max(x, dp[i]);\n        }\n\n        // Return the maximum height\n        return x;\n    }\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}