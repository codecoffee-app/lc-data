{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 705618,
            "title": "Check Mirror in N-ary tree",
            "titleSlug": "check-mirror-in-n-ary-tree1528",
            "content": "<p><span style=\"font-size:18px\">Given two <strong>n</strong>-ary trees.&nbsp;Check if they are mirror images of each other or not. You are also given <strong>e</strong> denoting the number of edges in both trees, and two arrays, <strong>A[] </strong>and<strong> </strong><strong>B[]</strong>. </span> <span style=\"font-size:18px\">Each array has&nbsp;2*e space separated values u,v denoting an edge from u to v for the both trees.</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong></span>\r\n<span style=\"font-size:18px\"><strong>n = </strong>3, <strong>e = </strong>2</span>\r\n<span style=\"font-size:18px\"><strong>A[] = </strong>{1, 2, 1, 3}</span>\r\n<span style=\"font-size:18px\"><strong>B[] = </strong>{1, 3, 1, 2}</span>\r\n<span style=\"font-size:18px\"><strong>Output:\r\n</strong>1</span>\r\n<span style=\"font-size:18px\"><strong>Explanation:\r\n</strong></span>   <span style=\"font-size:18px\">1\\t    1\r\n / \\\\t  /  \\\r\n2   3\\t3    2</span> \r\n<span style=\"font-size:18px\">As we can clearly see, the second tree\r\nis mirror image of the first.</span>\r\n</pre>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 2:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong></span>\r\n<span style=\"font-size:18px\"><strong>n = </strong>3, <strong>e = </strong>2</span>\r\n<span style=\"font-size:18px\"><strong>A[] = </strong>{1, 2, 1, 3}</span>\r\n<span style=\"font-size:18px\"><strong>B[] = </strong>{1, 2, 1, 3}</span>\r\n<span style=\"font-size:18px\"><strong>Output:\r\n</strong>0</span>\r\n<span style=\"font-size:18px\"><strong>Explanation:\r\n</strong></span>   <span style=\"font-size:18px\">1\\t    1\r\n / \\\\t  /  \\\r\n2   3\\t2    3</span> \r\n<span style=\"font-size:18px\">As we can clearly see, the second tree\r\nisn&#39;t mirror image of the first.</span></pre>\r\n\r\n<p><br />\r\n<span style=\"font-size:18px\"><strong>Your Task:</strong><br />\r\nYou don&#39;t need to read input or print anything. Your task is to complete the function <strong>checkMirrorTree()</strong> which takes 2 Integers n, and e;&nbsp; and two arrays A[] and B[] of size 2*e as input and returns 1 if the trees are mirror images of each other and 0 if not.</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong> O(e)<br />\r\n<strong>Expected Auxiliary Space:</strong> O(e)</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-size:18px\"><strong>Constraints:</strong></span><br />\r\n<span style=\"font-size:18px\">1 &lt;= n,e &lt;= 10<sup>5</sup></span></p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">We can solve it by maintaining a queue and a stack and doing a traversal for both.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "STL",
                "slug": "stl"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Queue",
                "slug": "queue"
            }
        ],
        "companies": [
            "amazon",
            "d-e-shaw",
            "hike",
            "makemytrip"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\n\nclass Solution {\n  public:\n    //Function to check if two trees are mirror.\n    int checkMirrorTree(int n, int e, int A[], int B[]) {\n        \n        //declaring two arrays for storing adjacent nodes of tree 1 and tree 2.\n        vector<int> g1[100005];\n\t\tvector<int> g2[100005];\n\t\t\n\t\t//loop to store adjacent nodes of tree 1 in g1 array.\n\t\tfor(int i=0; i<2*e; i+=2)\n\t\t{\n\t\t\tint x = A[i];\n\t\t\tint y = A[i+1];\n\t\t\tg1[x].push_back(y);\n\t\t}\n\t\t\n\t\t//loop to store adjacent nodes of tree 2 in g2 array.\n\t\tfor(int i=0; i<2*e; i+=2)\n\t\t{\n\t\t\tint x = B[i];\n\t\t\tint y = B[i+1];\n\t\t\tg2[x].push_back(y);\n\t\t}\n\t\t\n\t\t//declaring stack and queue for tree traversal.\n\t\tstack<int> s;\n\t\tqueue<int> q;\n\t\t\n\t\t//pushing root node in stack and queue.\n\t\ts.push(1);\n\t\tq.push(1);\n\n\t\t//flag variable to check if trees are mirror or not.\n\t\tbool f=0;\n\t\t//loop until stack and queue are not empty.\n\t\twhile(!s.empty() and !q.empty())\n\t\t{\n\t\t\t//extracting top element from stack and front element from queue.\n\t\t\tint s1 = s.top();\n\t\t\ts.pop();\n\t\t\tint s2 = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\t//if the nodes are not equal, trees are not mirror.\n\t\t\tif(s1!=s2)\n\t\t\t{\n\t\t\t\tf=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t//loop to push adjacent nodes of s1 in stack.\n\t\t\tfor(auto i = 0; i<g1[s1].size(); i++)\n\t\t\t\ts.push(g1[s1][i]);\n\t\t\t\t\n\t\t\t//emptying the queue into a vector.\n\t\t\tvector<int> k;\n\t\t\twhile(!q.empty())\n\t\t\t{\n    \t\t\tk.push_back(q.front());\n    \t\t\tq.pop();\n\t\t\t}\n\t\t\t\n\t\t\t//loop to push adjacent nodes of s2 in queue.\n\t\t\tfor(auto i=0; i<g2[s2].size(); i++)\n\t\t\t\tq.push(g2[s2][i]);\n\t\t\t\t\n\t\t\t//pushing elements of vector k back into the queue.\n\t\t\tfor(int i=0; i<k.size(); i++)\n\t\t\t    q.push(k[i]);\n\t\t}\n\t\t\n\t\t//checking if both stack and queue are empty and flag is false, then trees are mirror.\n\t\tif(s.empty() and q.empty() and !f)\n\t\t\treturn 1;\n\t\telse \n\t\t    return 0;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\r\n\r\nclass Solution {\r\n    //Function to check if the given trees are mirror trees or not.\r\n    static int checkMirrorTree(int n, int e, int[] A, int[] B) {\r\n        \r\n        //Creating ArrayLists to store the adjacency lists for each node in both trees.\r\n\t    ArrayList<Stack<Integer>> ar=new ArrayList<>();\r\n\t    ArrayList<Queue<Integer>> br=new ArrayList<>();\r\n\t    \r\n\t    //Initializing the ArrayLists with empty stacks and queues.\r\n\t    for(int i=0;i<=100005;i++)\r\n\t    {\r\n\t        ar.add(new Stack<Integer>());\r\n\t    }\r\n\t    for(int i=0;i<=100005;i++)\r\n\t    {\r\n\t        br.add(new LinkedList<Integer>());\r\n\t    }\r\n\t    \r\n\t    //Filling the adjacency lists with the edges.\r\n\t    for(int i=0;i<2*e;i+=2)\r\n\t    {\r\n\t        ar.get(A[i]).add(A[i+1]);\r\n\t    }\r\n\t    for(int i=0;i<2*e;i+=2)\r\n\t    {\r\n\t        br.get(B[i]).add(B[i+1]);\r\n\t    }\r\n\r\n        //Starting from node 1, check if the corresponding adjacency lists for each node\r\n        //in both trees are mirror images.\r\n        int i=1;\r\n        Stack<Integer> st=new Stack<>();\r\n        Queue<Integer> q=new LinkedList<>();\r\n        while(i<n&&i<e)\r\n        {\r\n            st=ar.get(i);\r\n            q=br.get(i);\r\n            while(!st.isEmpty()&&!q.isEmpty())\r\n            {\r\n                if(st.peek()==q.peek())\r\n                {\r\n                    st.pop();\r\n                    q.remove();\r\n                }\r\n                else\r\n                {\r\n                    return 0;\r\n                }\r\n            }\r\n            if(!st.isEmpty()||!q.isEmpty())\r\n            {\r\n                return 0;\r\n            }\r\n            i++;\r\n        }\r\n        \r\n        //If all adjacency lists are mirror images, return 1 to indicate that the trees are mirror trees. \r\n        return 1;\r\n    }\r\n};",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "\r\nclass Solution:\r\n    def checkMirrorTree(self,n, e, A, B):\r\n        # Lists to store nodes of the tree\r\n        s = []\r\n        q = []\r\n     \r\n        # initializing both list with empty stack and queue\r\n        for i in range(n + 1):\r\n            s.append([])\r\n            queue = []\r\n            q.append(queue)\r\n     \r\n       # add all nodes of tree 1 to\r\n       # list of stack and tree 2 to list of queue\r\n        for i in range(0, 2 * e, 2):\r\n            s[A[i]].append(A[i + 1])\r\n            q[B[i]].append(B[i + 1])\r\n     \r\n        # now take out the stack and queues\r\n        # for each of the nodes and compare them\r\n        # one by one\r\n        for i in range(1, n + 1):\r\n            while (len(s[i]) > 0 and len(q[i]) > 0):\r\n                a = s[i][len(s[i]) - 1]\r\n                s[i].pop()\r\n                b = q[i][0]\r\n                q[i].pop(0)\r\n     \r\n                if (a != b):\r\n                    return 0\r\n        return 1",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "class Solution\n{\n    public int checkMirrorTree(int n, int e, int[] A, int[] B)\n    {\n        List<List<int>> g1 = new List<List<int>>();\n        List<List<int>> g2 = new List<List<int>>();\n        \n        for(int i=0; i<100005; i++)\n        {\n            g1.Add(new List<int>());\n            g2.Add(new List<int>());\n        }\n        \n        for(int i=0; i<2*e; i+=2)\n        {\n            int x = A[i];\n            int y = A[i+1];\n            g1[x].Add(y);\n        }\n        \n        for(int i=0; i<2*e; i+=2)\n        {\n            int x = B[i];\n            int y = B[i+1];\n            g2[x].Add(y);\n        }\n        \n        Stack<int> s = new Stack<int>();\n        Queue<int> q = new Queue<int>();\n        \n        s.Push(1);\n        q.Enqueue(1);\n\n        bool f= false;\n        \n        while(s.Count !=0 && q.Count !=0)\n        {\n            int s1 = s.Pop();\n            int s2 = q.Dequeue();\n            \n            if(s1!=s2)\n            {\n                f = true;\n                break;\n            }\n            \n            for(int i=0; i<g1[s1].Count; i++)\n                s.Push(g1[s1][i]);\n                \n            List<int> k = new List<int>();\n            while(q.Count !=0)\n                k.Add(q.Dequeue());\n            \n            for(int i=0; i<g2[s2].Count; i++)\n                q.Enqueue(g2[s2][i]);\n            \n            for(int i=0; i<k.Count; i++)\n                q.Enqueue(k[i]);\n        }\n        \n        if(s.Count==0 && q.Count==0 && !f)\n            return 1;\n        \n        return 0;\n    }\n}",
                "lang_text": "csharp"
            }
        ],
        "platform": "GFG"
    }
}