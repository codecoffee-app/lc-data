{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 712575,
            "title": "Chocolates Pickup",
            "titleSlug": "chocolates-pickup",
            "content": "<p><span style=\"font-size: 18px;\">You are given an <strong><code>n </code></strong><code>rows</code><strong><code> </code></strong><code>and</code><strong><code> m </code></strong><code>cols</code>&nbsp;matrix&nbsp;<strong><code>grid</code></strong> representing a field of chocolates where&nbsp;<code>grid[i][j]</code>&nbsp;represents the number of chocolates&nbsp;that you can collect from the&nbsp;<code>(i, j)</code>&nbsp;cell.</span></p>\n<p><span style=\"font-size: 18px;\">You have two robots that can collect chocolates for you:</span></p>\n<ul>\n<li><span style=\"font-size: 18px;\"><strong>Robot #1</strong>&nbsp;is located at the&nbsp;<strong>top-left corner</strong>&nbsp;<code>(0, 0)</code>, and</span></li>\n<li><span style=\"font-size: 18px;\"><strong>Robot #2</strong>&nbsp;is located at the&nbsp;<strong>top-right corner</strong>&nbsp;<code>(0, cols - 1)</code>.</span></li>\n</ul>\n<p><span style=\"font-size: 18px;\">Return&nbsp;the maximum number of chocolates collection using both robots by following the rules below:</span></p>\n<ul>\n<li><span style=\"font-size: 18px;\">From a cell&nbsp;<code>(i, j)</code>, robots can move to cell&nbsp;<code>(i + 1, j - 1)</code>,&nbsp;<code>(i + 1, j)</code>, or&nbsp;<code>(i + 1, j + 1)</code>.</span></li>\n<li><span style=\"font-size: 18px;\">When any robot passes through a cell, It picks up all chocolates, and the cell becomes an empty cell.</span></li>\n<li><span style=\"font-size: 18px;\">When both robots stay in the same cell, only one takes the chocolates.</span></li>\n<li><span style=\"font-size: 18px;\">Both robots cannot move outside of the grid at any moment.</span></li>\n<li><span style=\"font-size: 18px;\">Both robots should reach the bottom row in&nbsp;<code>grid</code>.</span></li>\n</ul>\n<p><span style=\"font-size: 18px;\"><strong>Example:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:\n</strong>n = 4, m = 3\ngrid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\n<strong>Output:</strong>\n24</span><span style=\"font-size: 18px;\">\n<strong>Explanation:</strong>\nPath of robot #1 and #2 are described in color green and blue respectively. Chocolates taken by Robot #1, (3 + 2 + 5 + 2) = 12. Chocolates taken by Robot #2, (1 + 5 + 5 + 1) = 12. Total of Chocolates: 12 + 12 = 24.</span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:</strong> O(n * m * m)</span><br /><span style=\"font-size: 18px;\"><strong>Expected Space Complexity:</strong> O(n * m * m)</span></p>\n<p><strong><span style=\"font-size: 18px;\">Constraint:</span></strong><br /><span style=\"font-size: 18px;\">2 &lt;= n, m &lt; = 70<br />0 &lt;= grid[i][j] &lt;= 100</span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "You are given an `n` rows and `m` cols matrix `grid` representing a field of chocolates where `grid[i][j]` represents the number of chocolates that you can collect from the `(i, j)` cell.\n\nYou have two robots that can collect chocolates for you:\n\n*   **Robot #1** is located at the **top-left corner** `(0, 0)`, and\n*   **Robot #2** is located at the **top-right corner** `(0, cols - 1)`.\n\nReturn the maximum number of chocolates collection using both robots by following the rules below:\n\n*   From a cell `(i, j)`, robots can move to cell `(i + 1, j - 1)`, `(i + 1, j)`, or `(i + 1, j + 1)`.  \n*   When any robot passes through a cell, it picks up all chocolates, and the cell becomes an empty cell.\n*   When both robots stay in the same cell, only one takes the chocolates.\n*   Both robots cannot move outside of the grid at any moment.\n*   Both robots should reach the bottom row in `grid`.",
                "constraints": [
                    "2 <= n, m <= 70",
                    "0 <= grid[i][j] <= 100"
                ],
                "testcases": [
                    {
                        "input": "n = 4, m = 3\ngrid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]",
                        "output": "24",
                        "explanation": "One possible optimal path is as follows: Robot 1 takes (3 + 2 + 5 + 2 = 12) chocolates, and Robot 2 takes (1 + 5 + 5 + 1 = 12) chocolates, for a total of 24 chocolates."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [],
        "relatedTopics": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class Solution {\n  public:\n    int solve(int n, int m, vector<vector<int>>& grid) {\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(m, 0)));\n\n        for (int j1 = 0; j1 < m; j1++) {\n            for (int j2 = 0; j2 < m; j2++) {\n                if (j1 == j2) {\n                    dp[n - 1][j1][j2] = grid[n - 1][j1];\n                } else {\n                    dp[n - 1][j1][j2] = grid[n - 1][j1] + grid[n - 1][j2];\n                }\n            }\n        }\n\n        for (int i = n - 2; i >= 0; i--) {\n            for (int j1 = 0; j1 < m; j1++) {\n                for (int j2 = 0; j2 < m; j2++) {\n                    int maxi = 0;\n                    for (int k = -1; k <= 1; k++) {\n                        for (int l = -1; l <= 1; l++) {\n                            int c = 0;\n                            if (j1 + k >= 0 && j1 + k < m && j2 + l >= 0 &&\n                                j2 + l < m) {\n                                if (j1 == j2) {\n                                    c = grid[i][j1] + dp[i + 1][j1 + k][j2 + l];\n                                } else {\n                                    c = grid[i][j1] + grid[i][j2] +\n                                        dp[i + 1][j1 + k][j2 + l];\n                                }\n                            }\n                            maxi = max(maxi, c);\n                        }\n                    }\n                    dp[i][j1][j2] = maxi;\n                }\n            }\n        }\n        return dp[0][0][m - 1];\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\nclass Solution {\n    public int solve(int n, int m, int grid[][]) {\n        // Initializing a 3D array to store the intermediate values\n        int[][][] dp = new int[n][m][m];\n\n        // Filling the 3D array with 0s\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                Arrays.fill(dp[i][j], 0);\n            }\n        }\n\n        // Initializing the last row of the 3D array with values from the last row of\n        // the grid\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i == j) {\n                    dp[n - 1][i][j] = grid[n - 1][i];\n\n                } else {\n                    dp[n - 1][i][j] = grid[n - 1][i] + grid[n - 1][j];\n                }\n            }\n        }\n\n        // Iterating through the remaining rows from bottom to top\n        for (int i = n - 2; i >= 0; i--) {\n            // Iterating through each cell in the row\n            for (int j1 = 0; j1 < m; j1++) {\n                for (int j2 = 0; j2 < m; j2++) {\n                    int maxi = 0;\n                    // Checking all possible combinations of adjacent cells\n                    for (int k = -1; k <= 1; k++) {\n                        for (int l = -1; l <= 1; l++) {\n                            int c = 0;\n                            // Checking if adjacent cells are within bounds\n                            if (j1 + k >= 0 && j1 + k < m && j2 + l >= 0 &&\n                                j2 + l < m) {\n                                // Handling the case when both cells are the same\n                                if (j1 == j2) {\n                                    c = grid[i][j1] + dp[i + 1][j1 + k][j2 + l];\n                                } else {\n                                    c = grid[i][j1] + grid[i][j2] +\n                                        dp[i + 1][j1 + k][j2 + l];\n                                }\n                            }\n                            // Updating the maximum value\n                            maxi = Math.max(maxi, c);\n                        }\n                    }\n                    // Storing the maximum value in the current cell of the 3D array\n                    dp[i][j1][j2] = maxi;\n                }\n            }\n        }\n        // Returning the maximum value from the top row of the 3D array\n        return dp[0][0][m - 1];\n    }\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "# Back-end complete function Template for Python 3\n\n\nclass Solution:\n    # Function to find the maximum sum of elements in a square matrix\n\n    def solve(self, n, m, grid):\n        # Initializing a dp matrix with zeros\n        dp = [[0] * m for _ in range(m)]\n\n        # gridssigning the first element of the dp matrix\n        # as the sum of the first and last element of the first row of grid\n        dp[0][m - 1] = grid[0][0] + grid[0][-1]\n\n        # Looping through each row starting from the second row\n        for i in range(1, n):\n            # Creating a new dp matrix for the current row\n            dpn = [[0] * m for _ in range(m)]\n\n            # Looping through each column of the current row\n            for j in range(m):\n                # Looping through each column of the previous row\n                for k in range(m):\n                    # Checking if the column indices are within range\n                    # and skipping if they are out of range\n                    if j > i or m - k - 1 > i: continue\n\n                    # Looping through possible increments or decrements\n                    # of the current column indices\n                    for dj in [-1, 0, 1]:\n                        for dk in [-1, 0, 1]:\n                            # Checking if the new column indices are within range\n                            # and skipping if they are out of range\n                            if 0 <= j + dj < m and 0 <= k + dk < m:\n                                # Updating the maximum value in dpn[j][k]\n                                dpn[j][k] = max(dpn[j][k], dp[j + dj][k + dk])\n\n                    # Updating the value in dpn[j][k] by adding the current element in grid\n                    # and subtracting the common element if j and k are the same\n                    dpn[j][k] += grid[i][j] + grid[i][k] - (0 if j != k else\n                                                            grid[i][j])\n\n            # Updating the dp matrix with dpn\n            dp = dpn\n\n        # Returning the maximum sum of elements in dp\n        return max(x for r in dp for x in r)\n",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "class Solution {\n    public int solve(int n, int m, List<List<int>> grid) {\n        int[][][] dp = new int [n][][];\n        for (int i = 0; i < n; i++) {\n            dp[i] = new int [m][];\n            for (int j = 0; j < m; j++) {\n                dp[i][j] = new int[m];\n            }\n        }\n\n        for (int j1 = 0; j1 < m; j1++) {\n            for (int j2 = 0; j2 < m; j2++) {\n                if (j1 == j2) {\n                    dp[n - 1][j1][j2] = grid[n - 1][j1];\n                } else {\n                    dp[n - 1][j1][j2] = grid[n - 1][j1] + grid[n - 1][j2];\n                }\n            }\n        }\n\n        for (int i = n - 2; i >= 0; i--) {\n            for (int j1 = 0; j1 < m; j1++) {\n                for (int j2 = 0; j2 < m; j2++) {\n                    int maxi = 0;\n                    for (int k = -1; k <= 1; k++) {\n                        for (int l = -1; l <= 1; l++) {\n                            int c = 0;\n                            if (j1 + k >= 0 && j1 + k < m && j2 + l >= 0 &&\n                                j2 + l < m) {\n                                if (j1 == j2) {\n                                    c = grid[i][j1] + dp[i + 1][j1 + k][j2 + l];\n                                } else {\n                                    c = grid[i][j1] + grid[i][j2] +\n                                        dp[i + 1][j1 + k][j2 + l];\n                                }\n                            }\n                            maxi = Math.Max(maxi, c);\n                        }\n                    }\n                    dp[i][j1][j2] = maxi;\n                }\n            }\n        }\n        return dp[0][0][m - 1];\n    }\n}",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "// User function Template for javascript\n/**\n * @param {number} n\n * @param {number} m\n * @param {number[][]} grid\n * @returns {number}\n */\n\nclass Solution {\n    solve(n, m, grid) {\n        // Initializing a dp matrix with zeros\n        let dp = Array(m).fill().map(() => Array(m).fill(0));\n\n        // Assigning the first element of the dp matrix\n        // as the sum of the first and last element of the first row of A\n        dp[0][m - 1] = grid[0][0] + grid[0][m - 1];\n\n        // Looping through each row starting from the second row\n        for (let i = 1; i < n; i++) {\n            // Creating a new dp matrix for the current row\n            let dpn = Array(m).fill().map(() => Array(m).fill(0));\n\n            // Looping through each column of the current row\n            for (let j = 0; j < m; j++) {\n                // Looping through each column of the previous row\n                for (let k = 0; k < m; k++) {\n                    // Checking if the column indices are within range\n                    // and skipping if they are out of range\n                    if (j > i || m - k - 1 > i) continue;\n\n                    // Looping through possible increments or decrements\n                    // of the current column indices\n                    for (let dj = -1; dj <= 1; dj++) {\n                        for (let dk = -1; dk <= 1; dk++) {\n                            // Checking if the new column indices are within range\n                            // and skipping if they are out of range\n                            if (0 <= j + dj && j + dj < m && 0 <= k + dk &&\n                                k + dk < m) {\n                                // Updating the maximum value in dpn[j][k]\n                                dpn[j][k] = Math.max(dpn[j][k], dp[j + dj][k + dk]);\n                            }\n                        }\n                    }\n\n                    // Updating the value in dpn[j][k] by adding the current element in\n                    // grid and subtracting the common element if j and k are the same\n                    dpn[j][k] += grid[i][j] + grid[i][k] - (j != k ? 0 : grid[i][j]);\n                }\n            }\n\n            // Updating the dp matrix with dpn\n            dp = dpn;\n        }\n\n        // Returning the maximum sum of elements in dp\n        let maxSum = 0;\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < m; j++) {\n                maxSum = Math.max(maxSum, dp[i][j]);\n            }\n        }\n\n        return maxSum;\n    }\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}