{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 700657,
            "title": "Construct Tree from Preorder Traversal",
            "titleSlug": "construct-tree-from-preorder-traversal",
            "content": "<p><span style=\"font-size:18px\">Construct a binary tree of size <strong>N</strong> using two&nbsp;given arrays <strong>pre[]</strong> and <strong>preLN[]</strong>. Array <strong>pre[]</strong> represents preorder traversal of a binary tree. Array <strong>preLN[]</strong> has only two possible values <strong>L</strong> and <strong>N</strong>. The value <strong>L</strong> in <strong>preLN[]</strong> indicates that the corresponding node in Binary Tree is a leaf node and value N indicates that the corresponding node is a non-leaf node.<br />\r\n<strong>Note:</strong> Every node in the binary tree has either 0 or 2 children.</span></p>\r\n\r\n<p><strong><span style=\"font-size:18px\">Example 1:</span></strong></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input :\\t</strong>\r\nN = 5\r\npre[] = {10, 30, 20, 5, 15}\r\npreLN[] = {N, N, L, L, L}</span>\r\n\r\n<span style=\"font-size:18px\"><strong>Output:</strong>\r\n\\t    10\r\n\\t  /    \\\r\n\\t30\\t15\r\n     /  \\     \r\n   20    5   </span></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Your Task: &nbsp;</strong><br />\r\nYou dont need to read input or print anything. Complete the function <strong>constructTree()</strong> which takes N, pre[] and preLN[] as input parameters and returns the root node of the constructed binary tree.</span><br />\r\n<span style=\"font-size:18px\"><strong>Note:</strong>&nbsp;The output generated by the compiler will contain the inorder traversal of the created binary tree.</span><br />\r\n&nbsp;</p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong> O(N)<br />\r\n<strong>Expected Auxiliary Space: </strong>O(N)</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-size:18px\"><strong>Constraints:</strong><br />\r\n1 &le; N &le; 10<sup>4</sup><br />\r\n1 &le; pre[i] &le; 10<sup>7</sup><br />\r\npreLN[i]: {&#39;N&#39;, &#39;L&#39;}</span></p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Construct a binary tree of size N using two given arrays `pre[]` and `preLN[]`. The `pre[]` array represents the preorder traversal of the binary tree. The `preLN[]` array contains values 'L' and 'N', where 'L' indicates that the corresponding node in the `pre[]` array is a leaf node, and 'N' indicates a non-leaf node.  Every node in the binary tree has either 0 or 2 children.",
                "constraints": [
                    "1 <= N <= 10^4",
                    "1 <= pre[i] <= 10^7",
                    "preLN[i] can be either 'N' or 'L'"
                ],
                "testcases": [
                    {
                        "input": "N = 5\npre[] = {10, 30, 20, 5, 15}\npreLN[] = {N, N, L, L, L}",
                        "output": "    10\n  /    \\\n 30    15\n /  \\     \n20    5",
                        "explanation": "The preorder traversal is {10, 30, 20, 5, 15} and the preLN array {N, N, L, L, L} indicates that 10 and 30 are non-leaf nodes and 20, 5, and 15 are leaf nodes.  The resulting binary tree follows this structure."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>The first element in pre[] will always be root. So we can easily figure out root. If left subtree is empty, the right subtree must also be empty and preLN[] entry for root must be &lsquo;L&rsquo;. We can simply create a node and return it. If left and right subtrees are not empty, then recursively call for left and right subtrees and link the returned nodes to root.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Traversal",
                "slug": "traversal"
            },
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [
            "amazon",
            "hike"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "// Function to recursively construct the tree using pre-order traversal\n// index_ptr is a pointer to maintain the current index\n// n is the number of nodes in the tree\nstruct Node *constructTreeUtil(int pre[], char preLN[], int *index_ptr, int n)\n{\n    int index = *index_ptr; // get the current index\n    if (index == n) // if index is equal to n, return NULL\n        return NULL;\n    struct Node *temp = new Node(pre[index]); // create a new node with the value of current pre-order element\n    (*index_ptr)++; // increment the index pointer\n    if (preLN[index] == 'N') // if the current element is a non-leaf node\n    {\n        temp->left = constructTreeUtil(pre, preLN, index_ptr, n); // recursively construct the left subtree\n        temp->right = constructTreeUtil(pre, preLN, index_ptr, n); // recursively construct the right subtree\n    }\n    return temp; // return the constructed tree\n}\n\n// Main function to construct the binary tree from given pre-order traversal\n// n is the number of nodes in the tree\n// pre is the pre-order traversal array\n// preLN is an array containing 'L' for leaf nodes and 'N' for non-leaf nodes\nstruct Node *constructTree(int n, int pre[], char preLN[])\n{\n    int index = 0; // initialize the index\n    return constructTreeUtil(pre, preLN, &index, n); // call the utility function to construct the tree recursively\n}",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\nclass Solution\n{\n    // initialize the index variable\n    public static int ind;\n    Solution(){ind=0;}\n\n    // function to create a node and construct the tree\n    Node make(int pre[], char preLN[], int n){\n        // if the index reaches the end of the array, return null\n        if (ind == n)return null;\n        \n        // create a new node \n        Node temp = new Node(pre[ind]);\n        \n        // increment the index\n        ind++;\n        \n        // check if index is out of range\n        if(ind>=n)\n        return temp;\n        \n        // if the previous node is 'N', recursively create left and right subtrees\n        if (preLN[ind-1] == 'N')\n        {\n            temp.left = make(pre, preLN, n);\n            temp.right =make(pre, preLN, n);\n        }\n        \n        // return the node\n        return temp;\n    }\n\n    // construct the tree using pre-order traversal\n    Node constructTree(int n, int pre[], char preLN[]){\n        return make(pre, preLN, n);\n    }\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\r\n\r\ndef constructTree(pre, preLN, n): \r\n    index = [0] \r\n    return constructTreeUtil(pre, preLN, index, n) \r\n\r\ndef constructTreeUtil(pre, preLN, index_ptr, n): \r\n      \r\n    index = index_ptr[0] # store the current value  \r\n                         # of index in pre[]  \r\n    if index == n:  \r\n        return None\r\n  \r\n    temp = Node(pre[index])  \r\n    index_ptr[0] += 1\r\n  \r\n   \r\n    if preLN[index] == 'N': \r\n        temp.left = constructTreeUtil(pre, preLN,  \r\n                                      index_ptr, n)  \r\n        temp.right = constructTreeUtil(pre, preLN,  \r\n                                       index_ptr, n)  \r\n  \r\n    return temp",
                "lang_text": "python3"
            },
            {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\r\n\r\n/*\r\nclass Node\r\n{\r\n    constructor(x){\r\n        this.data=x;\r\n        this.left=null;\r\n        this.right=null;\r\n    }\r\n}\r\n*/\r\n\r\n/**\r\n * @param {number} n\r\n * @param {number[]} pre\r\n * @param {number[]} preLN\r\n * @return {Node} \r\n*/\r\nclass Solution {\r\n  \tconstructTree(n,pre,preLN){\r\n    let index = 0;\r\n  \r\n    function constructTreeUtil(pre, preLN, index_ptr, n) {\r\n        let index = index_ptr[0];\r\n        if (index === n) return null;\r\n        let temp = new Node(pre[index]);\r\n        index_ptr[0]++;\r\n    \r\n        if (preLN[index] === 'N') {\r\n            temp.left = constructTreeUtil(pre, preLN, index_ptr, n);\r\n            temp.right = constructTreeUtil(pre, preLN, index_ptr, n);\r\n        }\r\n    \r\n        return temp;\r\n    }\r\n  \r\n    return constructTreeUtil(pre, preLN, [0], n);\r\n  }\r\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}