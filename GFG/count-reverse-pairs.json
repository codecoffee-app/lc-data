{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 712345,
            "title": "Count Reverse Pairs",
            "titleSlug": "count-reverse-pairs",
            "content": "<p><span style=\"font-size: 18px;\">You are given an array of <strong>N </strong>integers <strong>arr</strong>, find&nbsp;the count of reverse pairs.&nbsp;</span></p>\n<p><span style=\"font-size: 18px;\">A pair of indices (i, j) is said to be a&nbsp;<strong>reverse pair</strong>&nbsp;if both the following conditions are met:</span></p>\n<ul>\n<li><span style=\"font-size: 18px;\"><code>0 &lt;= i &lt; j &lt; N</code>&nbsp;</span></li>\n<li><span style=\"font-size: 18px;\"><code>arr[i] &gt; 2 * arr[j]</code></span></li>\n</ul>\n<h4><span style=\"font-size: 18px;\"><strong>Example 1</strong>:</span></h4>\n<pre><span style=\"font-size: 18px;\"><strong>Input</strong>:\nN = 6\narr = [3, 2, 4, 5, 1, 20]\n<strong>Output</strong>:\n3\n<strong>Explanation</strong>:\nThe Reverse pairs are \n(i)  (0, 4), arr[0] = 3, arr[4] = 1, 3 &gt; 2(1) \n(ii) (2, 4), arr[2] = 4, arr[4] = 1, 4 &gt; 2(1) \n(iii)(3, 4), arr[3] = 5, arr[4] = 1, 5 &gt; 2(1) </span>\n</pre>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Example 2</strong>:</span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input</strong>: \nN = 5\narr= [2, 4, 3, 5, 1]\n<strong>Output</strong>: \n3\n<strong>Explanation</strong>: </span>\n<span style=\"font-size: 18px;\">(i)   (1, 4), arr[1] = 4, arr[4] = 1, 4 &gt; 2 * 1\n(ii)  (2, 4), arr[2] = 3, arr[4] = 1, 3 &gt; 2 * 1\n(iii) (3, 4), arr[3] = 5, arr[4] = 1, 5 &gt; 2 * 1</span></pre>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Your Task:</strong><br />Complete the function <strong>countRevPairs</strong>(), which takes integer a list of N integers as input and returns the<em>&nbsp;</em>count of Reverse Pairs.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity</strong>: O(N logN)<br /><strong>Expected Auxiliary Space</strong>: O(N)</span></p>\n<p><br /><span style=\"font-size: 18px;\"><strong>Constraints:</strong></span></p>\n<p><span style=\"font-size: 18px;\">1 &lt;= N &lt;= 50000<br />1 &lt;= arr[i] &lt;= 10<sup>9</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given an array `arr` of `N` integers, find the number of reverse pairs. A pair of indices `(i, j)` is considered a reverse pair if `0 <= i < j < N` and `arr[i] > 2 * arr[j]`.",
                "constraints": [
                    "1 <= N <= 50000",
                    "1 <= arr[i] <= 10^9"
                ],
                "testcases": [
                    {
                        "input": "N = 6\narr = [3, 2, 4, 5, 1, 20]",
                        "output": "3",
                        "explanation": "The reverse pairs are (0, 4) because 3 > 2 * 1, (2, 4) because 4 > 2 * 1, and (3, 4) because 5 > 2 * 1."
                    },
                    {
                        "input": "N = 5\narr = [2, 4, 3, 5, 1]",
                        "output": "3",
                        "explanation": "The reverse pairs are (1, 4) because 4 > 2 * 1, (2, 4) because 3 > 2 * 1, and (3, 4) because 5 > 2 * 1."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [],
        "relatedTopics": [],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "// Back-end complete function Template for C++\n\nclass Solution {\n  public:\n    int ans = 0;\n    \n    // Function to merge two sorted subarrays\n    void merge(vector<int>& arr, int left, int mid, int right) {\n        int p1 = left;\n        int p2 = mid + 1;\n        vector<int> res;\n        \n        // Loop to count the number of reverse pairs\n        while (p1 <= mid && p2 <= right) \n        {\n            long long val1=arr[p1];\n            long long val2=arr[p2];\n            val2*=2;\n            if (val1 <= val2) {\n                p1 += 1;\n            } else {\n                ans += (mid - p1 + 1);  // Increment the count of reverse pairs\n                p2 += 1;\n            }\n        }\n        \n        p1 = left, p2 = mid + 1;\n        \n        // Merging the two sorted subarrays into a result array\n        while (p1 <= mid && p2 <= right) {\n            if (arr[p1] <= arr[p2]) {\n                res.push_back(arr[p1]);\n                p1 += 1;\n            } else {\n                res.push_back(arr[p2]);\n                p2 += 1;\n            }\n        }\n\n        // Copying remaining elements of left subarray (if any)\n        while (p1 <= mid) {\n            res.push_back(arr[p1]);\n            p1 += 1;\n        }\n        \n        // Copying remaining elements of right subarray (if any)\n        while (p2 <= right) {\n            res.push_back(arr[p2]);\n            p2 += 1;\n        }\n\n        // Copying the merged array back to the original array\n        for (int i = left; i <= right; i++) {\n            arr[i] = res[i - left];\n        }\n    }\n    \n    // Function to perform merge sort on the given array\n    void mergeSort(vector<int>& arr, int left, int right) {\n        if (left == right) {\n            return;  // Base case: array has only one element\n        }\n        \n        int mid = (left + right) / 2;\n        mergeSort(arr, left, mid);  // Recursively sort the left subarray\n        mergeSort(arr, mid + 1, right);  // Recursively sort the right subarray\n\n        merge(arr, left, mid, right);  // Merge the sorted subarrays\n    }\n    \n    // Function to count the number of reverse pairs in the array\n    int countRevPairs(int n, vector<int> arr) {\n        ans = 0;  // Reset the count of reverse pairs\n        mergeSort(arr, 0, n - 1);  // Sort the array using merge sort\n        return ans;  // Return the count of reverse pairs\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "// Back-end complete function Template for Java\r\n\r\nclass Solution {\r\n    int ans = 0; //initialize counter variable for reverse pairs\r\n    \r\n    // function to merge two sorted subarrays and count reverse pairs\r\n    public void merge(int arr[], int left, int mid, int right) {\r\n        int p1 = left; // pointer for first subarray\r\n        int p2 = mid + 1; // pointer for second subarray\r\n        Vector<Integer> res = new Vector<Integer>(); // vector to store sorted elements\r\n        \r\n        // comparing elements and counting reverse pairs\r\n        while (p1 <= mid && p2 <= right) \r\n        {\r\n            long val1=arr[p1];\r\n            long val2=arr[p2];\r\n            val2*=2;\r\n            if (val1 <= val2) {\r\n                p1 += 1;\r\n            } else {\r\n                ans += (mid - p1 + 1);\r\n                p2 += 1;\r\n            }\r\n        }\r\n        \r\n        p1 = left; // reset pointer for first subarray\r\n        p2 = mid + 1; // reset pointer for second subarray\r\n        \r\n        // merging two sorted subarrays\r\n        while (p1 <= mid && p2 <= right) {\r\n            if (arr[p1] <= arr[p2]) {\r\n                res.add(arr[p1]);\r\n                p1 += 1;\r\n            } else {\r\n                res.add(arr[p2]);\r\n                p2 += 1;\r\n            }\r\n        }\r\n        \r\n        // adding remaining elements from first subarray\r\n        while (p1 <= mid) {\r\n            res.add(arr[p1]);\r\n            p1 += 1;\r\n        }\r\n        \r\n        // adding remaining elements from second subarray\r\n        while (p2 <= right) {\r\n            res.add(arr[p2]);\r\n            p2 += 1;\r\n        }\r\n        \r\n        // copying sorted elements back to original array\r\n        for (int i = left; i <= right; i++) {\r\n            arr[i] = res.elementAt(i - left);\r\n        }\r\n    }\r\n\r\n    // function to perform merge sort and count reverse pairs\r\n    public void mergeSort(int arr[], int left, int right) {\r\n        if (left == right) {\r\n            return;\r\n        }\r\n        int mid = (left + right) / 2; // finding middle index\r\n        mergeSort(arr, left, mid); // recursively sorting first half\r\n        mergeSort(arr, mid + 1, right); // recursively sorting second half\r\n        merge(arr, left, mid, right); // merging two sorted halves\r\n    }\r\n\r\n    // main function to count reverse pairs\r\n    public int countRevPairs(int N, int arr[]) {\r\n        ans = 0; // reset counter\r\n        mergeSort(arr, 0, N - 1); // perform merge sort\r\n        return ans; // return total number of reverse pairs\r\n    }\r\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\r\n\r\nclass Solution:\r\n    \r\n    #Function to merge and count the reverse pairs.\r\n    def countRevPairs(self, n, arr):\r\n        def merge(a, left, mid, right):\r\n            nonlocal ans\r\n            p1, p2 = left, mid + 1\r\n            res = []\r\n            \r\n            #Iterating over both halves of the array and counting reverse pairs.\r\n            while p1 <= mid and p2 <= right:\r\n                if a[p1] <= 2*a[p2]:\r\n                    p1 += 1\r\n                else:\r\n                    ans+=(mid - p1 + 1)\r\n                    p2+=1\r\n                \r\n            p1, p2 = left, mid+1\r\n            \r\n            #Merging the two halves of the array.\r\n            while p1 <= mid and p2 <= right:\r\n                \r\n                if a[p1] < a[p2]:\r\n                    res.append(a[p1])\r\n                    p1 += 1\r\n                else:\r\n                    res.append(a[p2])\r\n                    p2 += 1\r\n            \r\n            #Adding remaining elements from the first half, if any.\r\n            while p1 <= mid:\r\n                res.append(a[p1])\r\n                p1+=1\r\n            \r\n            #Adding remaining elements from the second half, if any.\r\n            while p2 <= right:\r\n                res.append(a[p2])\r\n                p2+=1\r\n            \r\n            #Copying the sorted elements back to the original array.\r\n            for i in range(left, right+1):\r\n                a[i] = res[i - left]\r\n            \r\n        #Function to divide the array into smaller halves and merge sort them.\r\n        def mergeSort(a, left, right):\r\n            if left==right:return\r\n            \r\n            mid = (left + right)>>1\r\n            mergeSort(a, left, mid)\r\n            mergeSort(a, mid + 1, right)\r\n        \r\n            merge(a, left, mid, right)\r\n            \r\n        ans = 0\r\n        #Calling the mergeSort function to sort the array and count reverse pairs.\r\n        mergeSort(arr, 0, n-1)\r\n        return ans",
                "lang_text": "py"
            },
            {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\n/**\n * @param {number} N\n * @param {number[]} arr\n * @returns {number}\n */\n\nclass Solution {\n    //Function to merge and count the reverse pairs.\n    countRevPairs(N, arr)\n    {\n        let ans = 0;\n        \n        //Function to merge two halves of the array and count the reverse pairs.\n        function merge(a, left, mid, right) {\n            let p1 = left;\n            let p2 = mid + 1;\n            let res = [];\n            \n            //Iterating over both halves of the array and counting reverse pairs.\n            while (p1 <= mid && p2 <= right) {\n                if (a[p1] <= 2*a[p2]) {\n                    p1 += 1;\n                } else {\n                    ans += (mid - p1 + 1);\n                    p2 += 1;\n                }\n            }\n            \n            p1 = left;\n            p2 = mid + 1;\n            \n            //Merging the two halves of the array.\n            while (p1 <= mid && p2 <= right) {\n                if (a[p1] < a[p2]) {\n                    res.push(a[p1]);\n                    p1 += 1;\n                } else {\n                    res.push(a[p2]);\n                    p2 += 1;\n                }\n            }\n            \n            //Adding remaining elements from the first half, if any.\n            while (p1 <= mid) {\n                res.push(a[p1]);\n                p1 += 1;\n            }\n            \n            //Adding remaining elements from the second half, if any.\n            while (p2 <= right) {\n                res.push(a[p2]);\n                p2 += 1;\n            }\n            \n            //Copying the sorted elements back to the original array.\n            for (let i = left; i <= right; i++) {\n                a[i] = res[i - left];\n            }\n        }\n        \n        //Function to divide the array into smaller halves and merge sort them.\n        function mergeSort(a, left, right) {\n            if (left === right) {\n                return;\n            }\n            \n            let mid = Math.floor((left + right) / 2);\n            mergeSort(a, left, mid);\n            mergeSort(a, mid + 1, right);\n            \n            merge(a, left, mid, right);\n        }\n        \n        //Calling the mergeSort function to sort the array and count reverse pairs.\n        mergeSort(arr, 0, N-1);\n        \n        return ans;\n    }\n}",
                "lang_text": "javascript"
            },
            {
                "lang": "C#",
                "full_func": "\nclass Solution\n{\n    private int ans = 0;\n\n    void merge(List<int> arr, int left, int mid, int right)\n    {\n        int p1 = left;\n        int p2 = mid + 1;\n        List<int> res = new List<int>();\n\n        while (p1 <= mid && p2 <= right)\n        {\n            long val1 = arr[p1];\n            long val2 = (long)arr[p2] * 2; // Cast to long to prevent overflow\n            if (val1 <= val2)\n            {\n                p1 += 1;\n            }\n            else\n            {\n                ans += (mid - p1 + 1);\n                p2 += 1;\n            }\n        }\n\n        p1 = left;\n        p2 = mid + 1;\n\n        while (p1 <= mid && p2 <= right)\n        {\n            if (arr[p1] <= arr[p2])\n            {\n                res.Add(arr[p1]);\n                p1 += 1;\n            }\n            else\n            {\n                res.Add(arr[p2]);\n                p2 += 1;\n            }\n        }\n\n        while (p1 <= mid)\n        {\n            res.Add(arr[p1]);\n            p1 += 1;\n        }\n\n        while (p2 <= right)\n        {\n            res.Add(arr[p2]);\n            p2 += 1;\n        }\n\n        for (int i = left; i <= right; i++)\n        {\n            arr[i] = res[i - left];\n        }\n    }\n\n    void mergeSort(List<int> arr, int left, int right)\n    {\n        if (left >= right)\n        {\n            return;\n        }\n\n        int mid = left + (right - left) / 2;\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n\n        merge(arr, left, mid, right);\n    }\n\n    public int countRevPairs(int n, List<int> arr)\n    {\n        ans = 0;\n        mergeSort(arr, 0, n - 1);\n        return ans;\n    }\n}",
                "lang_text": "csharp"
            }
        ],
        "platform": "GFG"
    }
}