{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 706214,
            "title": "Covid Spread",
            "titleSlug": "covid-spread--141631",
            "content": "<p>Aterp is the head nurse at a city hospital. City hospital contains R*C&nbsp;number of wards and the structure of a hospital is in the form of a 2-D matrix.<br />Given a matrix of dimension <strong>R</strong>*<strong>C</strong> where each cell in the matrix can have values 0, 1, or 2 which has the following meaning:<br /><strong>0</strong>: Empty ward<br /><strong>1</strong>: Cells have uninfected patients<br /><strong>2</strong>: Cells have infected patients</p>\n<p>An infected patient at ward [i,j] can infect other uninfected patient at indexes [i-1,j], [i+1,j], [i,j-1], [i,j+1] (<strong>up</strong>, <strong>down</strong>, <strong>left</strong> and <strong>right</strong>) in unit time. Help Aterp&nbsp;determine the minimum units of time after which there won't remain any uninfected patient i.e all patients would be infected.&nbsp;If all patients are not infected after infinite units of time then simply return -1.</p>\n<p>&nbsp;</p>\n<p><br /><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong>\n3 5\n2 1 0 2 1\n1 0 1 2 1\n1 0 0 2 1 \n<strong>Output:</strong>\n2\n<strong>Explanation:\n</strong>Patients at positions {0,0}, {0, 3}, {1, 3}\nand {2, 3} will infect patient at {0, 1}, \n{1, 0},{0, 4}, {1, 2}, {1, 4}, {2, 4} during 1st \nunit time. And, during 2nd unit time, patient at \n{1, 0} will get infected and will infect patient \nat {2, 0}. Hence, total 2 unit of time is\nrequired to infect all patients.</pre>\n<p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong>\n3 5\n2 1 0 2 1\n0 0 1 2 1\n1 0 0 2 1\n<strong>Output:</strong>\n-1\n<strong>Explanation:</strong>\nAll patients will not be infected.</pre>\n<p>&nbsp;</p>\n<p><strong>Your Task:</strong>&nbsp;&nbsp;<br />You don't need to read input or print anything. Your task is to complete the function <strong>helpaterp</strong>()&nbsp;which takes a 2-D Matrix <strong>hospital&nbsp;</strong>as input parameter&nbsp;and returns the minimum units of time in which all patients will be infected or -1 if it is impossible.</p>\n<p><br /><strong>Constraints:</strong><br />1 &le; R,C&nbsp;&le; 1000<br />0 &le; mat[i][j]&nbsp;&le; 2</p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Aterp, the head nurse at City Hospital, faces a challenge. The hospital is structured as a 2D matrix of wards with R rows and C columns. Each ward's state is represented by a value:\n\n*   0: Empty ward\n*   1: Ward with an uninfected patient\n*   2: Ward with an infected patient\n\nInfected patients can spread the infection to adjacent uninfected patients (up, down, left, right) in one unit of time. Aterp needs to determine the minimum time required for all patients to become infected. If complete infection is impossible, return -1.",
                "constraints": [
                    "1 <= R, C <= 1000",
                    "0 <= mat[i][j] <= 2"
                ],
                "testcases": [
                    {
                        "input": "3 5\n2 1 0 2 1\n1 0 1 2 1\n1 0 0 2 1",
                        "output": "2",
                        "explanation": "Initially, patients at (0,0), (0,3), (1,3), and (2,3) are infected.  In the first time unit, they infect patients at (0,1), (1,0), (0,4), (1,2), (1,4), and (2,4). In the second time unit, the patient at (1,0) infects the patient at (2,0).  Thus, it takes 2 time units to infect all patients."
                    },
                    {
                        "input": "3 5\n2 1 0 2 1\n0 0 1 2 1\n1 0 0 2 1",
                        "output": "-1",
                        "explanation": "In this scenario, not all patients can be infected, even after infinite time."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">We can think of this problem as a shortest path problem. You need to find the shortest path of a cell which has value &quot;1&quot; from&nbsp;the nearest cell which contains the value &quot;2&quot;.</span></p>",
            "<p><span style=\"font-size:18px\">Apply multi-source BFS.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Graph",
                "slug": "graph"
            },
            {
                "name": "BFS",
                "slug": "bfs"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [
            "flipkart",
            "microsoft"
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\n\nclass Solution\n{\nprivate:\n    int R,C;\n\n    //Function to check if (i,j) is a valid coordinate\n    bool isvalid(int i, int j)\n    {\n        return (i >= 0 && j >= 0 && i < R && j < C);\n    }\n\n    //Structure to represent coordinates of a point\n    struct ele {\n        int x, y;\n    };\n\n    //Function to check if the coordinate is a delimiter\n    bool isdelim(ele temp)\n    {\n        return (temp.x == -1 && temp.y == -1);\n    }\n\n    //Function to check if there are any uninfected cells left\n    bool checkall(vector<vector<int>> hospital)\n    {\n        for (int i=0; i<R; i++)\n            for (int j=0; j<C; j++)\n                if (hospital[i][j] == 1)\n                    return true;\n        return false;\n    }\npublic:\n\n    //Function to calculate the minimum time required for all cells to be infected\n    int helpaterp(vector<vector<int>> hospital)\n    {\n        R= hospital.size();\n        C= hospital[0].size();\n        queue<ele> Q;\n        ele temp;\n        int ans = 0;\n\n        //Pushing all infected cells into the queue\n        for (int i=0; i<R; i++)\n        {\n            for (int j=0; j<C; j++)\n            {\n                if (hospital[i][j] == 2)\n                {\n                    temp.x = i;\n                    temp.y = j;\n                    Q.push(temp);\n                }\n            }\n        }\n\n        //Pushing a delimiter to mark the end of one time frame\n        temp.x = -1;\n        temp.y = -1;\n        Q.push(temp);\n\n        //BFS to infect neighboring cells\n        while (!Q.empty())\n        {\n            bool flag = false;\n\n            while (!isdelim(Q.front()))\n            {\n                temp = Q.front();\n\n                //If cell below is uninfected, infect and push into queue\n                if (isvalid(temp.x+1, temp.y) && hospital[temp.x+1][temp.y] == 1)\n                {\n                    if (!flag) ans++, flag = true;     \n                    hospital[temp.x+1][temp.y] = 2;\n                    temp.x++;\n                    Q.push(temp);\n\n                    temp.x--; \n                }\n\n                //If cell above is uninfected, infect and push into queue\n                if (isvalid(temp.x-1, temp.y) && hospital[temp.x-1][temp.y] == 1) {\n                    if (!flag) ans++, flag = true;\n                    hospital[temp.x-1][temp.y] = 2;\n                    temp.x--;\n                    Q.push(temp); \n                    temp.x++;\n                }\n\n                //If cell to the right is uninfected, infect and push into queue\n                if (isvalid(temp.x, temp.y+1) && hospital[temp.x][temp.y+1] == 1) {\n                    if (!flag) ans++, flag = true;\n                    hospital[temp.x][temp.y+1] = 2;\n                    temp.y++;\n                    Q.push(temp); \n                    temp.y--;\n                }\n\n                //If cell to the left is uninfected, infect and push into queue\n                if (isvalid(temp.x, temp.y-1) && hospital[temp.x][temp.y-1] == 1) {\n                    if (!flag) ans++, flag = true;\n                    hospital[temp.x][temp.y-1] = 2;\n                    temp.y--;\n                    Q.push(temp); \n                }\n                Q.pop();\n            }\n            Q.pop();\n\n            //If there are more cells to infect, push a delimiter\n            if (!Q.empty()) {\n                temp.x = -1;\n                temp.y = -1;\n                Q.push(temp);\n            }\n        }\n    \n        //If there are uninfected cells left, return -1, else return the minimum time required\n        return (checkall(hospital))? -1: ans;\n    }\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "// Back-end complete function Template for Java\n\nclass Solution{\n\n     // Function to calculate the minimum time required for all hospitals to be covered\n     public int helpaterp(int[][] hospital) {\n        int count=0;\n        \n        // Create a queue to store the positions of hospitals\n        Queue<pair> q=new LinkedList<>();\n        \n        // Iterate through the hospital grid and add the positions of the hospitals to the queue\n        for(int i=0;i<hospital.length;i++) {\n            for(int j=0;j<hospital[i].length;j++) {\n                if(hospital[i][j]==2)\n                    q.add(new pair(i,j,0)); // Add the position and the level (time) to the queue\n            }\n        }\n\n        int ans=0;\n        while(!q.isEmpty()) {\n            pair curr=q.poll();\n            int ni=curr.i;\n            int nj=curr.j;\n            int nlevel=curr.level;\n            int nexti=ni-1;\n            int nextj=nj;\n            \n            // Check if the next position is valid and contains an unvisited hospital\n            if(isValid(nexti,nextj,hospital) && hospital[nexti][nextj]==1) {\n                q.add(new pair(nexti,nextj,nlevel+1)); // Add the position and the updated level to the queue\n                hospital[nexti][nextj]=2; // Mark the hospital as visited\n            }\n            \n            nexti=ni;\n            nextj=nj-1;\n            \n            // Check if the next position is valid and contains an unvisited hospital\n            if(isValid(nexti,nextj,hospital) && hospital[nexti][nextj]==1) {\n                q.add(new pair(nexti,nextj,nlevel+1)); // Add the position and the updated level to the queue\n                hospital[nexti][nextj]=2; // Mark the hospital as visited\n            }\n            \n            nexti=ni+1;\n            nextj=nj;\n            \n            // Check if the next position is valid and contains an unvisited hospital\n            if(isValid(nexti,nextj,hospital)&& hospital[nexti][nextj]==1) {\n                q.add(new pair(nexti,nextj,nlevel+1)); // Add the position and the updated level to the queue\n                hospital[nexti][nextj]=2; // Mark the hospital as visited\n            }\n            \n             nexti=ni;\n             nextj=nj+1;\n            \n            // Check if the next position is valid and contains an unvisited hospital\n            if(isValid(nexti,nextj,hospital)&& hospital[nexti][nextj]==1) {\n                q.add(new pair(nexti,nextj,nlevel+1)); // Add the position and the updated level to the queue\n                hospital[nexti][nextj]=2; // Mark the hospital as visited\n            }\n            \n            ans=Math.max(ans,nlevel); // Update the maximum time taken\n            \n        }\n        \n        // Check if all hospitals have been visited, if not return -1\n        for(int i=0;i<hospital.length;i++) {\n            for(int j=0;j<hospital[0].length;j++) {\n                if(hospital[i][j]==1)\n                    return -1;\n            }\n        }\n        \n        // Return the minimum time taken to cover all hospitals\n        return  ans;\n    }\n    \n    // Class to represent a pair (x, y) with a level (time)\n    public class pair {\n        int i;\n        int j;\n        int level;\n        \n        pair(int i,int j,int level) {\n            this.i=i;\n            this.j=j;\n            this.level=level;\n        }\n    }\n    \n    // Function to check if the given position is valid\n    public boolean isValid(int i,int j,int hospital[][]) {\n        if(i>=0 && i<hospital.length && j>=0 && j<hospital[0].length)\n            return true;\n        return false;\n    }\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\n\nclass Solution:\n    #Function to find the minimum time required for all the people in the hospital to get infected.\n    def helpaterp(self,hospital):\n        #Creating two sets for positive and negative values.\n        neg = set()\n        pos = set()\n        \n        #Finding the dimensions of the hospital.\n        m = len(hospital)\n        n = len(hospital[0])\n        \n        #Adding positive and negative values to their respective sets.\n        for i in range(m):\n            for j in range(n):\n                if hospital[i][j] == 2:\n                    pos.add((i,j))\n                elif hospital[i][j] == 1:\n                    neg.add((i, j))\n                    \n        #Initializing the variable for minimum time.\n        mins = 0\n        dirs = [(1,0), (-1,0), (0,1), (0,-1)]\n        \n        #Loop until all negative values are infected.\n        while len(neg) > 0:\n            #Creating a set to store newly infected values.\n            infected = set()\n            \n            #Iterating over positive values.\n            for r in pos:\n                \n                #Getting the row and column of the positive value.\n                row = r[0]\n                col = r[1]\n\n                #Checking all four directions for infected values.\n                for dir in dirs:\n                    new_row = dir[0] + row\n                    new_col = dir[1] + col\n                    \n                    #If  negative value is found, remove it from negative set\n                    #and add it to infected set.\n                    if (new_row, new_col) in neg:\n                        neg.remove((new_row, new_col))\n                        infected.add((new_row, new_col))\n                        \n            #If no new infected values found, return -1.\n            if len(infected) == 0:\n                return -1\n            \n            #Update the positive set to infected values.\n            pos = infected\n            #Increment the minimum time.\n            mins += 1\n            \n        return mins",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\n/**\n * @param {number[][]} hospital\n * @returns {number}\n*/\n\nclass Solution {\n    //Function to return Probability.\n    helpaterp(hospital)\n    {\n        //Creating two arrays for positive and negative values.\n        let neg = [];\n        let pos = [];\n        \n        //Finding the dimensions of the hospital.\n        let m = hospital.length;\n        let n = hospital[0].length;\n        \n        //Adding positive and negative values to their respective arrays.\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < n; j++) {\n                if (hospital[i][j] == 2) {\n                    pos.push([i,j]);\n                } else if (hospital[i][j] == 1) {\n                    neg.push([i,j]);\n                }\n            }\n        }\n                    \n        //Initializing the variable for minimum time.\n        let mins = 0;\n        let dirs = [[1,0], [-1,0], [0,1], [0,-1]];\n        \n        //Loop until all negative values are infected.\n        while (neg.length > 0) {\n            //Creating an array to store newly infected values.\n            let infected = [];\n            \n            //Iterating over positive values.\n            for (let r of pos) {\n                \n                //Getting the row and column of the positive value.\n                let row = r[0];\n                let col = r[1];\n\n                //Checking all four directions for infected values.\n                for (let dir of dirs) {\n                    let new_row = dir[0] + row;\n                    let new_col = dir[1] + col;\n                    \n                    //If  negative value is found, remove it from negative array\n                    //and add it to infected array.\n                    if (this.containsCoordinate(neg, new_row, new_col)) {\n                        let index = this.findCoordinateIndex(neg, new_row, new_col);\n                        neg.splice(index, 1);\n                        infected.push([new_row, new_col]);\n                    }\n                }\n            }\n            \n            //If no new infected values found, return -1.\n            if (infected.length == 0) {\n                return -1;\n            }\n            \n            //Update the positive array to infected values.\n            pos = infected;\n            //Increment the minimum time.\n            mins += 1;\n        }\n        \n        return mins;\n    }\n    \n    //Helper function to check if a coordinate is present in the array.\n    containsCoordinate(arr, row, col) {\n        for (let i = 0; i < arr.length; i++) {\n            if (arr[i][0] == row && arr[i][1] == col) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    //Helper function to find the index of a coordinate in the array.\n    findCoordinateIndex(arr, row, col) {\n        for (let i = 0; i < arr.length; i++) {\n            if (arr[i][0] == row && arr[i][1] == col) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}