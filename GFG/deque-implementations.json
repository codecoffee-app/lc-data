{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 700904,
            "title": "Deque Implementations",
            "titleSlug": "deque-implementations",
            "content": "<p><em><span style=\"font-size: 18px;\">A deque is a double-ended queue that allows enqueue and dequeue operations from both the ends.</span></em></p>\n<p><span style=\"font-size: 18px;\">Given a deque and <strong>q</strong> queries. The task is to perform some operation on dequeue according to the queries as given below:<br />1.<strong> pb</strong>: query to <strong>push back </strong>the <strong>element x</strong>.<br />2.<strong> pf</strong>: query to<strong> push element x</strong>(given with query) to the <strong>front of the deque</strong>.<br />3<strong>. pp_b()</strong>: query to <strong>delete element from the back</strong> of the deque.<br />4.<strong> f</strong>: query to<strong> return a front element</strong> from the deque.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Examples:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input: </strong>queries = [[ pf 5 ],[ pf 10 ],[ pb 6 ],[ f ],[ pp_b ]]\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> \n1. After push front deque will be [5]\n2. After push front deque will be [10, 5]\n3. After push back deque will be [10, 5, 6]\n4. Return front element which is 10\n5. After pop back deque will be [10, 5]</span></pre>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong> queries = [[ pf 5 ],[ f ]]\n<strong>Output:</strong> 5 \n<strong>Explanation:</strong>\n1. After push front deque will be [5]\n2. Return front element which is 5\n</span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; Number of queries &le; 10<sup>5</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            ""
        ],
        "relatedTopics": [
            {
                "name": "Java",
                "slug": "java"
            },
            {
                "name": "Queue",
                "slug": "queue"
            },
            {
                "name": "STL",
                "slug": "stl"
            },
            {
                "name": "Java-Collections",
                "slug": "java-collections"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C",
                "full_func": "// Function to push an element at the front of the deque\nvoid pf(struct deque *ptr, int data) {\n    if (isFull(ptr)) {\n        printf(\"Stack Overflow\\n\");\n        return;\n    }\n\n    ptr->curr_size++;\n\n    // If deque is empty, set the front and rear to 0 and insert the data at the front\n    if (isEmpty(ptr)) {\n        ptr->rear = 0;\n        ptr->front = 0;\n        ptr->arr[ptr->front] = data;\n        return;\n    }\n\n    // Decrease front by 1 (circular decrement) and insert the data at the new front\n    // index\n    ptr->front = (ptr->front - 1 + maxi) % maxi;\n    ptr->arr[ptr->front] = data;\n}\n\n// Function to push an element at the back of the deque\nvoid pb(struct deque *ptr, int data) {\n    if (isFull(ptr)) {\n        printf(\"Stack Overflow/n\");\n        return;\n    }\n\n    ptr->curr_size++;\n\n    // If deque is empty, set the front and rear to 0 and insert the data at the rear\n    if (isEmpty(ptr)) {\n        ptr->rear = 0;\n        ptr->front = 0;\n        ptr->arr[ptr->rear] = data;\n        return;\n    }\n\n    // Increase rear by 1 (circular increment) and insert the data at the new rear index\n    ptr->rear = (ptr->rear + 1) % maxi;\n    ptr->arr[ptr->rear] = data;\n}\n\n// Function to get the front element of the deque\nint front_dq(struct deque *ptr) {\n    if (isEmpty(ptr)) {\n        return -1;\n    }\n\n    return ptr->arr[ptr->front];\n}\n\n// Function to remove an element from the back of the deque\nvoid ppb(struct deque *ptr) {\n    if (isEmpty(ptr)) {\n        return;\n    }\n\n    ptr->curr_size--;\n\n    // If only one element is present, reset the deque to empty state\n    if (ptr->rear == ptr->front) {\n        initialise(ptr);\n        return;\n    }\n\n    // Set the value at rear index as -1, then decrease rear by 1 (circular decrement)\n    ptr->arr[ptr->rear] = -1;\n    ptr->rear = (ptr->rear - 1 + maxi) % maxi;\n}",
                "lang_text": "c"
            },
            {
                "lang": "C++",
                "full_func": "class Solution {\n  public:\n    void pb(deque<int>& dq, int x) { dq.push_back(x); }\n\n    void ppb(deque<int>& dq) {\n        if (!dq.empty())\n            dq.pop_back();\n    }\n\n    int front_dq(deque<int>& dq) {\n        if (!dq.empty())\n            return dq.front();\n        return -1;\n    }\n\n    void pf(deque<int>& dq, int x) { dq.push_front(x); }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "public static void pb(ArrayDeque<Integer> dq, int x) {\n    dq.addLast(x);\n}\n\n// Function to pop element from back of the deque.\npublic static void ppb(ArrayDeque<Integer> dq) {\n    if (!dq.isEmpty())\n        dq.removeLast();\n    else\n        return;\n}\n\n// Function to return element from front of the deque.\npublic static int front_dq(ArrayDeque<Integer> dq) {\n    if (!dq.isEmpty())\n        return dq.peekFirst();\n    else\n        return -1;\n}\n\n// Function to push element x to the front of the deque.\npublic static void pf(ArrayDeque<Integer> dq, int x) {\n    dq.addFirst(x);\n}\n",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\ndef pf(dq, x):\n    dq.appendleft(x)\n\n\ndef pb(dq, x):\n    dq.append(x)\n\n\ndef front_dq(dq):\n    if dq:\n        return dq[0]\n    else:\n        return -1\n\n\ndef ppb(dq):\n    if dq:\n        dq.pop()\n",
                "lang_text": "python3"
            },
            {
                "lang": "Javascript",
                "full_func": "// Back-end complete function Template for javascript\n\n/*\nclass Deque{\n    constructor(){\n        this.arr = [];\n        this.size = 0;\n    }\n}\n*/\n\nclass Solution {\n\n    /**\n     * @param {Deque} dq\n     * @param {number} x\n    */\n    // Function to push element x to the back of the deque.\n    push_back_pb(dq, x) {\n        dq.arr.push(x);\n        dq.size++;\n    }\n\n    /**\n     * @param {Deque} dq\n    */\n    // Function to pop element from back of the deque.\n    pop_back_ppb(dq) {\n        if (dq.size > 0) {\n            dq.arr.pop();\n            dq.size--;\n        }\n    }\n\n    /**\n     * @param {Deque} dq\n     * @returns {number}\n    */\n    // Function to return element from front of the deque.\n    front_dq(dq) {\n        if (dq.size > 0) {\n            return dq.arr[0];\n        }\n        return -1;\n    }\n\n    /**\n     * @param {Deque} dq\n     * @param {number} x\n    */\n    // Function to push element x to the front of the deque.\n    push_front_pf(dq, x) {\n        dq.arr.unshift(x);\n        dq.size++;\n    }\n}\n",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}