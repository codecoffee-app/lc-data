{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 714277,
            "title": "Easy Task",
            "titleSlug": "easy-task--170647",
            "content": "<p>Given a string&nbsp;<strong>s</strong>&nbsp;whose length is&nbsp;<strong>n</strong>&nbsp;and array&nbsp;<strong>queries</strong>&nbsp;of length&nbsp;<strong>q</strong>&nbsp;where each elements of queries is either of&nbsp;<strong>type</strong>&nbsp;<strong>1</strong>&nbsp;<strong>query</strong>&nbsp;or&nbsp;<strong>type 2 query</strong>&nbsp;which is explained ahead.</p>\r\n\r\n<p>There are two types of query.<br />\r\n<br />\r\n<strong>Query type 1</strong>&nbsp;:&nbsp;<strong>[&quot;1&quot;,ind,char]</strong>&nbsp; &quot;<strong>1&quot;</strong>&nbsp;denotes this is type&nbsp;<strong>1 query</strong>. In this query you have to change the character at index&nbsp;<strong>ind&nbsp;</strong>in s<strong>&nbsp;</strong>to character&nbsp;<strong>char</strong>.<strong>(Data type of ind,char is string in input)</strong><br />\r\n<br />\r\n<strong>Query Type 2:</strong>&nbsp;<strong>[&quot;2&quot;,left,right,k]</strong>&nbsp; &quot;<strong>2&quot;&nbsp;</strong>denotes this is type&nbsp;<strong>2 query</strong>. In this query you have to return&nbsp;<strong>kth lexographically</strong>&nbsp;largest character&nbsp; in the subtring of&nbsp;<strong>s (it is the kth largest&nbsp;</strong>character<strong>&nbsp;in sorted order , not the kth distinct&nbsp;</strong>character<strong>)</strong>&nbsp;starting from index&nbsp;<strong>left</strong>&nbsp;and ending at index<strong>&nbsp;right both left and right are inclusive</strong>. <strong>(Data type of left,right,k is string in input)</strong></p>\r\n\r\n<p>You have to perform each query in the&nbsp;<strong>same order</strong>&nbsp;as given in&nbsp;<strong>&nbsp;queries</strong>&nbsp;and return an array&nbsp;<strong>res</strong>&nbsp;such that res array contains&nbsp;<strong>the answer for each type2 query</strong>&nbsp;<strong>in same order as it appeared in queries</strong>.</p>\r\n\r\n<p><strong>Note</strong>&nbsp;:&nbsp;<strong>0</strong>&nbsp;based indexing is used.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n<strong>n</strong>=4\r\n<strong>s</strong>=&quot;abab&quot;\r\n<strong>q</strong>=2\r\n<strong>queries</strong>={{&quot;1&quot;,&quot;2&quot;,&quot;d&quot;},{&quot;2&quot;,&quot;1&quot;,&quot;3&quot;,&quot;1&quot;}}\r\n<strong>Output:</strong> \r\n{&quot;d&quot;}\r\n<strong>Explanation:</strong>\r\nFirst query is of type 1 so after changing character at index 2 \r\nto d  s becomes <strong>abdb</strong> . Now Second query is of type 2 in which \r\nthe 1st(k=1) lexographically largest character is <strong>&quot;d&quot; in substring &quot;bdb&quot;(s[1:3])</strong>. So we \r\nreturned a array with result of type 2 query <strong>{&quot;d&quot;}</strong>.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n<strong>n</strong>=3\r\n<strong>s</strong>=&quot;aaa&quot;\r\n<strong>q</strong>=3\r\n<strong>querie</strong>s={{&quot;1&quot;,&quot;1&quot;,&quot;e&quot;},{&quot;1&quot;,&quot;2&quot;,&quot;c&quot;},{&quot;2&quot;,&quot;1&quot;,&quot;2&quot;,&quot;2&quot;}}\r\n<strong>Output:</strong>\r\n{&quot;c&quot;}\r\n<strong>Explanation:</strong>\r\nAfter applying first two queries s becomes <strong>aec</strong>. Now for \r\nthe last query which is a type 2 second largest character \r\nin subtring s starting from index 1 to ending at index 2 is <strong>&quot;c&quot;</strong>.</pre>\r\n\r\n<p><strong>Your Task:</strong><br />\r\nYou don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>easyTask()</strong>&nbsp;which takes an integer&nbsp;<strong>n</strong>,string&nbsp;<strong>s</strong>,an integer&nbsp;<strong>q</strong>&nbsp;and an array&nbsp;<strong>queries</strong>&nbsp;which contains &nbsp;queries of<strong>&nbsp;</strong><strong>type1</strong>&nbsp;and&nbsp;<strong>type2</strong>&nbsp;&nbsp;respectively and returns an array&nbsp;<strong>res</strong>&nbsp;such that res array contains the&nbsp;<strong>answer for each type2 query in</strong>&nbsp;<strong>same order as it appeared in queries.</strong></p>\r\n\r\n<p><strong>Expected Time Complexity: O(N+(Q*logN))<br />\r\nExpected Space Complexity: O(N)</strong></p>\r\n\r\n<p><br />\r\n<strong>Constraints:</strong><br />\r\n1&lt;=<strong>n</strong>&lt;=5*10^4<br />\r\n1&lt;=<strong>q</strong>&lt;=10^5<br />\r\n0&lt;=<strong>int(left)</strong>&lt;=<strong>int(right)</strong>&lt;=n-1<br />\r\n0&lt;=<strong>int(index)</strong>&lt;=n-1<br />\r\n1&lt;=<strong>int(k)</strong>&lt;=right-left+1<br />\r\n<strong>s</strong>&nbsp;and&nbsp;<strong>char</strong>&nbsp;contains lowercase&nbsp;<strong>english letters</strong><br />\r\nThe sum of&nbsp;<strong>n</strong>&nbsp;over all test cases won&#39;t exceed&nbsp;<strong>5*10^4.</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p>Updating character at a inderx and asking queries hints at Use of segment Trees.&nbsp;</p>"
        ],
        "relatedTopics": [
            {
                "name": "Segment-Tree",
                "slug": "segment-tree"
            },
            {
                "name": "Advanced Data Structure",
                "slug": "advanced-data-structure"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\n\nclass Solution{\npublic:\n    vector<vector<int>> seg;  // vector to store the segment tree\n\n    // Function to perform easy task\n    vector<char> easyTask(int n,string s,int q,vector<vector<string>> &queries){\n        seg.resize(4*n);  // resizing the segment tree vector\n\n        for(int i=0;i<4*n;i++){\n            seg[i].resize(26);  // resizing each vector in the segment tree to store frequencies of characters\n        }\n\n        buildTree(s,0,0,n-1);  // building the segment tree from the given string\n\n        vector<char> ans;  // vector to store the answers\n\n        for(int i=0;i<q;i++){\n            if(queries[i][0]==\"1\"){  // checking the type of query\n                int ind=stoi(queries[i][1]);  // getting the index to update in the string\n                char val=queries[i][2][0];  // getting the character to update\n                update(0,0,n-1,ind,val);  // updating the segment tree and the string\n            }\n            else{\n                int l=stoi(queries[i][1]);  // getting the left index of the query range\n                int r=stoi(queries[i][2]);  // getting the right index of the query range\n                int k=stoi(queries[i][3]);  // getting the k-th smallest frequency required\n\n                vector<int> arr=query(0,0,n-1,l,r);  // performing the query on the segment tree to get the frequencies\n\n                // iterating from highest to lowest character and adding the characters with required frequency to the answer vector\n                for(int j=25;j>=0;j--){\n                    for(int kk=0;kk<arr[j];kk++){\n                        k--;\n                        if(k==0){\n                            ans.push_back((char)(j+'a'));\n                        }\n                    }\n                }\n            }\n        }\n\n        return ans;  // returning the answer vector\n    }\n\n    // Function to build the segment tree\n    void buildTree(string a,int si,int ss,int se){\n        if(ss==se){\n            seg[si][a[ss]-'a']++;  // storing the frequency of character in the segment tree\n            return;\n        }\n        int mid=(ss+se)/2;\n        buildTree(a,2*si+1,ss,mid);  // building the left subtree of the segment tree\n        buildTree(a,2*si+2,mid+1,se);  // building the right subtree of the segment tree\n\n        // storing the frequencies of characters from the left and right subtree in the current node of the segment tree\n        vector<int> a1=seg[2*si+1];\n        vector<int> a2=seg[2*si+2];\n        for(int i=0;i<26;i++){\n            seg[si][i]=a1[i]+a2[i];\n        }\n    }\n\n    // Function to update the segment tree and the string\n    void update(int si,int ss,int se,int pos,char val){\n        if(ss==se){\n            int in=0;\n\n            // finding the index of the current character in the segment tree\n            for(int i=0;i<26;i++){\n                if(seg[si][i]>=1){\n                    in=i;\n                    break;\n                }\n            }\n\n            seg[si][in]--;  // decreasing the frequency of original character\n            seg[si][val-'a']++;  // increasing the frequency of updated character\n            return;\n        }\n        int mid=(ss+se)/2;\n        if(pos<=mid){\n            update(2*si+1,ss,mid,pos,val);  // updating the left subtree\n        }else{\n            update(2*si+2,mid+1,se,pos,val);  // updating the right subtree\n        }\n\n        // updating the frequencies of characters from the left and right subtree in the current node of the segment tree\n        vector<int> a1=seg[2*si+1];\n        vector<int> a2=seg[2*si+2];\n        for(int i=0;i<26;i++){\n            seg[si][i]=a1[i]+a2[i];\n        }\n    }\n\n    // Function to perform the query on the segment tree\n    vector<int> query(int si,int ss,int se,int qs,int qe)\n    {\n        vector<int> a(26);  // vector to store the frequencies of characters in the query range\n\n        if(qs>se || qe<ss) return a;  // base case, return a vector with all frequencies as zero if the query range is completely outside the current range\n        if(ss>=qs && se<=qe)return seg[si];  // base case, return the frequencies of characters stored in the current node if the query range completely overlaps with the current range\n        \n        int mid=(ss+se)/2;\n        vector<int> a1=query(2*si+1,ss,mid,qs,qe);  // recursive call to get the frequencies from the left subtree\n        vector<int> a2=query(2*si+2,mid+1,se,qs,qe);  // recursive call to get the frequencies from the right subtree\n\n        // storing the frequencies of characters from the left and right subtree in the answer vector\n        vector<int> ans(26);\n        for(int i=0;i<26;i++){\n            ans[i]=a1[i]+a2[i];\n        }\n        return ans;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution {\r\n    static int seg[][];\r\n    public static ArrayList<Character> easyTask(int n,String s,int q,query queries[])\r\n    {\r\n        seg=new int[4*n][26];\r\n        char c[]=s.toCharArray();\r\n        buildTree(c,0,0,n-1);\r\n        ArrayList<Character> ans=new ArrayList<>();\r\n        for(int i=0;i<q;i++){\r\n            if(queries[i].type.equals(\"1\")){\r\n                int ind=Integer.parseInt(queries[i].a);\r\n                char val=queries[i].b.charAt(0);\r\n                update(0,0,n-1,ind,val);\r\n            }else{\r\n                int l=Integer.parseInt(queries[i].a);\r\n                int r=Integer.parseInt(queries[i].b);\r\n                int k=Integer.parseInt(queries[i].c);\r\n                int arr[]=query(0,0,n-1,l,r);\r\n                for(int j=25;j>=0;j--){\r\n                    for(int kk=0;kk<arr[j];kk++){\r\n                        k--;\r\n                        if(k==0){\r\n                            ans.add((char)(j+'a'));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n    public static void buildTree(char a[],int si,int ss,int se)\r\n\t{\r\n\t\tif(ss==se){\r\n\t\t\tseg[si][a[ss]-'a']++;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint mid=(ss+se)/2;\r\n\t\tbuildTree(a,2*si+1,ss,mid);\r\n\t\tbuildTree(a,2*si+2,mid+1,se);\r\n        int a1[]=seg[2*si+1];\r\n        int a2[]=seg[2*si+2];\r\n        for(int i=0;i<26;i++){\r\n            seg[si][i]=a1[i]+a2[i];\r\n        }\r\n\t}\r\n    public static void update(int si,int ss,int se,int pos,char val)\r\n\t{\r\n\t\tif(ss==se){\r\n            int in=0;\r\n            for(int i=0;i<26;i++){\r\n                if(seg[si][i]>=1){\r\n                    in=i;\r\n                    break;\r\n                }\r\n            }\r\n            seg[si][in]--;\r\n\t\t\tseg[si][val-'a']++;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint mid=(ss+se)/2;\r\n\t\tif(pos<=mid){\r\n\t\t\tupdate(2*si+1,ss,mid,pos,val);\r\n\t\t}else{\r\n\t\t\tupdate(2*si+2,mid+1,se,pos,val);\r\n\t\t}\r\n\t\tint a1[]=seg[2*si+1];\r\n        int a2[]=seg[2*si+2];\r\n        for(int i=0;i<26;i++){\r\n            seg[si][i]=a1[i]+a2[i];\r\n        }\r\n\t}\r\n    public static int[] query(int si,int ss,int se,int qs,int qe)\r\n\t{\r\n\t\tif(qs>se || qe<ss)return new int[26];\r\n\t\tif(ss>=qs && se<=qe)return seg[si];\r\n\t\tint mid=(ss+se)/2;\r\n\t\tint a1[]=query(2*si+1,ss,mid,qs,qe);\r\n\t\tint a2[]=query(2*si+2,mid+1,se,qs,qe);\r\n\t\t// return max(p1,p2);\r\n        int ans[]=new int[26];\r\n        for(int i=0;i<26;i++){\r\n            ans[i]=a1[i]+a2[i];\r\n        }\r\n        return ans;\r\n\t}\r\n}\r\n/*In case the query is of type 1.\r\ntype=1\r\nc=null\r\n*/\r\n\r\n/*In case the query is of type 2.\r\ntype=2\r\nc=k\r\n*/\r\n\r\nclass query\r\n{\r\n    String type;\r\n    String a;\r\n    String b;\r\n    String c;\r\n    public query(String type,String a,String b,String c)\r\n    {\r\n        this.type=type;\r\n        this.a=a;\r\n        this.b=b;\r\n        this.c=c;\r\n    }\r\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "class SegmentTree:\n    def __init__(self, s):\n        n = len(s)\n        self.tree = [[0]*(26) for _ in range(4*n)]\n        self.buildTree(s, 0, n - 1, 0)\n\n    # Function to build the segment tree\n    def buildTree(self, s, left, right, index = 0):\n        if left == right:\n            self.tree[index][ord(s[left])-ord(\"a\")]+=1\n            return\n\n        # Recursively build left and right subtrees\n        mid = (left + right) // 2\n        self.buildTree(s, left, mid, 2 * index + 1)\n        self.buildTree(s, mid + 1, right, 2 * index + 2)\n\n        # Update the count of characters in the current node\n        for c in range(26):\n            self.tree[index][c] = self.tree[2 * index + 1][c] + self.tree[2 * index + 2][c]\n\n    # Function to update a character at a given position\n    def update(self, s,left, right, pos, char,index = 0):\n        if pos < left or pos > right:\n            return\n\n        # If pos is at a leaf node, update the character and\n        # update the count in the segment tree\n        if left == right:\n            self.tree[index][ord(s[pos])-ord(\"a\")] -=1\n            s[pos]=char\n            self.tree[index][ord(s[pos])-ord(\"a\")] +=1\n            return\n\n        # Recursive update in the left or right subtree\n        mid = (left + right) // 2\n        if pos <= mid:\n            self.update(s,left, mid, pos, char,2 * index + 1)\n        else:\n            self.update(s,mid + 1, right, pos, char,2 * index + 2)\n\n        # Update the count of characters in the current node\n        for c in range(26):\n            self.tree[index][c] = self.tree[2 * index + 1][c] + self.tree[2 * index + 2][c]\n\n    # Function to query the count of characters in a given range\n    def query(self, left, right, i, j, index = 0):\n        if right < i or left > j:\n            return [0]*26\n\n        if i <= left and right <= j:\n            return self.tree[index]\n\n        # Recursive query in the left and right subtrees\n        mid = (left + right) // 2\n        temp=[0]*(26)\n        \n        res1=self.query(left, mid, i, j, 2 * index + 1)\n        res2=self.query(mid + 1, right, i, j,2 * index + 2)\n        \n        # Combine the count of characters in the left and right subtrees\n        for c in range(26):\n            temp[c]=res1[c]+res2[c]\n        return temp\n\nclass Solution:\n    def easyTask(self,n,s,q,queries):\n        s=[el for el in s]\n        seg=SegmentTree(s)\n        res=[]\n\n        # Process each query\n        for quer in queries:\n            if quer[0]==\"1\":\n                # Update the character at the given position\n                seg.update(s,0,n-1,int(quer[1]),quer[2])\n            else:\n                # Query the count of characters in the given range\n                char_freq=seg.query(0,n-1,int(quer[1]),int(quer[2]))\n                k=int(quer[3])\n\n                # Find the kth character based on the count\n                for c in range(25,-1,-1):\n                    k-=min(k,char_freq[c])\n                    if k==0:\n                        res.append(chr(ord(\"a\")+c))\n                        break\n        return res",
                "lang_text": "python3"
            }
        ],
        "platform": "GFG"
    }
}