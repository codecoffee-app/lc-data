{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 706084,
            "title": "Elixir of Life",
            "titleSlug": "elixir-of-life--141631",
            "content": "<p><span style=\"font-size: 18px;\">Flamel is making the Elixir of Life but he is missing a secret ingredient, a set of <strong>contiguous</strong> plants (substring) from the Garden of Eden.<br />The garden consists of various plants represented by string <strong>S</strong>, where each letter represents a different plant.&nbsp; But the prophecy has predicted that the correct set of plants required to make the potion will appear in the same contiguous pattern (substring) at the beginning of the forest (<strong>prefix</strong>), the end of the forest (<strong>suffix</strong>), and will also be the <strong>most frequent</strong> sequence present in the entire forest.</span></p>\n<p><span style=\"font-size: 18px;\">Identify the substring of plants required to make the elixir and find out the number of times it appears in the forest.&nbsp;</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Example 1:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong> <strong>S</strong> = \"ababaaaab\"\n<strong>Output:</strong> 3\n<strong>Explanation: </strong>Substring \"ab\" is a prefix, \nIt is also a&nbsp;suffix and appears 3 times.</span>\n</pre>\n<p><br /><span style=\"font-size: 18px;\"><strong>Example 2:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input: S</strong> = \"aaaa\"\n<strong>Output:</strong> 4\n<strong>Explanation: S</strong>ubstring \"aaaa\" occurs 1 time, \nSubstring \"aaa\" occurs 2 times, substring \n\"aa\" occurs 3 times, substring \"a\" occurs \n4 times. All of them are proper prefixes \nand suffixes. But, \"a\" has the maximum \nfrequency.</span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Example 3:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong> <strong>S</strong> = \"abcdef\"\n<strong>Output:</strong> 1\n</span></pre>\n<p><br /><span style=\"font-size: 18px;\"><strong>Your Task:&nbsp;</strong><br />You don't need to read input or print anything. Complete the function <strong>maxFrequency()</strong> which takes string S as input parameter and returns the frequency of the most frequent substring of S which is also a prefix and suffix of the original string.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:&nbsp;</strong><br />1 &le; |S| &le; 10<sup>5</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Find the most frequent contiguous substring within a given string S that is both a prefix and a suffix of S.  Return the number of times this substring appears in S.",
                "constraints": [
                    "1 <= |S| <= 10^5"
                ],
                "testcases": [
                    {
                        "input": "ababaaaab",
                        "output": "3",
                        "explanation": "The substring \"ab\" is both a prefix and a suffix of \"ababaaaab\" and appears 3 times in the string."
                    },
                    {
                        "input": "aaaa",
                        "output": "4",
                        "explanation": "The substrings \"aaaa\", \"aaa\", \"aa\", and \"a\" are all both prefixes and suffixes. \"aaaa\" appears 1 time, \"aaa\" appears 2 times, \"aa\" appears 3 times, and \"a\" appears 4 times.  Therefore, \"a\" is the most frequent."
                    },
                    {
                        "input": "abcdef",
                        "output": "1",
                        "explanation": "The only substring that is both a prefix and a suffix is the empty string (or the full string itself). Thus, only single character string is a possible solution.  The correct substring is \"abcdef\" which occurs 1 time."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Use Z function algorithm</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Strings",
                "slug": "strings"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function template in C++\n\nclass Solution\n{\n    public:\n    \n    //Function to calculate the Z-function of a string.\n    vector<int> z_function(string s)\n    {\n        int n = s.size();\n        vector<int> z(n);\n        \n        //iterating over each index of the string.\n        for(int i = 1, l = 0, r = 0; i < n; i++)\n        {\n            //calculating the value of z[i] based on previous computations.\n            if(i <= r)\n                z[i] = min(r - i + 1, z[i - l]);\n\n            //updating z[i] if the characters at s[z[i]] and s[i + z[i]] match.\n            while(i + z[i] < n && s[z[i]] == s[i + z[i]])\n                z[i]++;\n\n            //updating l and r if z[i] extends beyond the current rightmost boundary.\n            if(i + z[i] - 1 > r)\n                l = i, r = i + z[i] - 1;\n        }\n\n        return z;\n    }\n\n\n    //Function to update a value at a specific index in the binary indexed tree.\n    void update(int idx, int val, vector<int> &bit, int n)\n    {\n        //return if the index is 0.\n        if(idx == 0)\n            return;\n\n        //updating the value at the given index and its subsequent indexes in the binary indexed tree.\n        while(idx <= n)\n        {\n            bit[idx] += val;\n            idx += (idx&-idx);\n        }\n    }\n\n\n    //Function to calculate the prefix sum up to a specific index in the binary indexed tree.\n    int pref(int idx, vector<int> &bit)\n    {\n        int ans = 0;\n        \n        //calculating the prefix sum using the binary indexed tree.\n        while(idx > 0)\n        {\n            ans += bit[idx];\n            idx -= (idx&-idx);\n        }    \n\n        return ans;\n    }\n\n    \n    //Function to calculate the maximum frequency of a substring in the given string.\n    int maxFrequency(string str)\n    {\n        int n = str.size();\n        \n        //calculating the Z-function for the string.\n        vector<int> z = z_function(str);\n\n        //creating a binary indexed tree of size n+5.\n        vector<int> bit(n+5, 0);\n\n        //updating the binary indexed tree based on the Z-function values.\n        for(int i = 1; i < n; i++)\n            update(z[i], 1, bit, n);\n\n        //creating a map to store the frequencies of substrings.\n        map<int, int> m;\n\n        //iterating over the Z-function values in reverse order.\n        for(int i = n-1; i >= 1; i--)\n        {\n            //if z[i] is not equal to (n-i), continue with the next iteration.\n            if(z[i] != (n-i))\n                continue;\n\n            //calculating the frequency of the substring based on the prefix sum.\n            m[z[i]] += (pref(n, bit) - pref(z[i]-1, bit) + 1);\n        }\n        \n        //storing the maximum frequency in the variable ans.\n        int ans = 1;\n        for(auto it:m)\n            ans = max(ans, it.second);\n\n        return ans;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\nclass Sol\n{\n    \n// Function to calculate the Z-function for a given string\nArrayList<Integer> z_function(String s)\n{\n    // Get the length of the string\n    int n = s.length();\n    // Create an ArrayList to store the Z-values\n    ArrayList<Integer> z = new ArrayList<Integer>(n);\n    \n    // Initialize all Z-values to 0\n    for(int i = 0 ;i<n;i++)\n        z.add(i,0);\n\n    // Iterate through the string to calculate the Z-values\n    for(int i = 1, l = 0, r = 0; i < n; i++)\n    {\n        // If i is within the right boundary, set z[i] to the minimum value between r-i+1 and z[i-l]\n        if(i <= r)\n            z.set(i , Math.min(r - i + 1, z.get(i - l)) );\n        \n        // While the current characters match, increment the Z-value and move to the next characters\n        while(i + z.get(i) < n && s.charAt(z.get(i)) == s.charAt(i + z.get(i)) )\n            z.set(i , z.get(i) + 1);\n        \n        // If the current Z-value extends beyond the right boundary, update the boundaries\n        if(i + z.get(i) - 1 > r)\n        {\n            l = i;\n            r = i + z.get(i) - 1;\n        }\n    }\n    \n    // Return the ArrayList containing the Z-values\n    return z;\n}\n        \n \n// Function to update the Binary Indexed Tree\nvoid update(int idx, int val, ArrayList<Integer> bit, int n)\n{\n    // If the index is 0, return\n    if(idx == 0)\n        return;\n\n    // Update the Binary Indexed Tree by incrementing the values at the specified index\n    while(idx <= n)\n    {\n        bit.set(idx , bit.get(idx) + val);\n        idx += (idx&-idx);\n    }\n}\n \n \n// Function to calculate the prefix sum from the Binary Indexed Tree\nint pref(int idx, ArrayList<Integer> bit)\n{\n    int ans = 0;\n    while(idx > 0)\n    {\n        ans += bit.get(idx); \n        idx -= (idx&-idx);\n    }   \n\n    return ans;\n}\n\n\n// Function to calculate the maximum frequency of any substring in a given string\nint maxFrequency(String str)\n{\n    // Get the length of the string\n    int n = str.length();\n    // Calculate the Z-values for the given string\n    ArrayList<Integer> z = z_function(str);\n    \n    // Create an ArrayList to store the Binary Indexed Tree\n    ArrayList<Integer> bit = new ArrayList<Integer>(n + 5);\n    // Initialize all values of the Binary Indexed Tree to 0\n    for(int i = 0 ;i<n + 5;i++)\n        bit.add(i,0);\n    \n    // Update the Binary Indexed Tree based on the Z-values\n    for(int i = 1; i < n; i++)\n        update(z.get(i), 1, bit, n);\n\n\n    // Create a TreeMap to store the frequencies of substrings\n    TreeMap<Integer,Integer> m = new TreeMap<Integer,Integer>();\n\n    // Iterate through the Z-values in reverse order\n    for(int i = n-1; i >= 1; i--)\n    {\n        // If the Z-value is not equal to n-i, skip the current iteration\n        if(z.get(i) != (n-i))\n            continue;\n        \n        // If the Z-value is already present in the TreeMap, update its frequency\n        if(m.containsKey(z.get(i)))\n        {\n            m.put(z.get(i), m.get(z.get(i)) +   (pref(n, bit) - pref(z.get(i) - 1, bit) + 1)  ); \n        }\n        // Otherwise, add the Z-value to the TreeMap with the corresponding frequency\n        else\n            m.put(z.get(i) , (pref(n, bit) - pref(z.get(i) - 1, bit) + 1) );\n    \n    }\n    \n    // Initialize the maximum frequency as 1\n    int ans = 1;\n    \n    // Iterate through the entries in the TreeMap to find the maximum frequency\n    for(Map.Entry<Integer,Integer> entry : m.entrySet())\n        ans = Math.max(ans, entry.getValue());\n\n    // Return the maximum frequency\n    return ans;\n}\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\n\nclass Solution:\n    #Function to calculate Z array.\n    def z_function(self, s):\n        n = len(s)\n        z = [0] * n\n        l = r = 0\n        #iterating from 1 to n-1 to calculate Z array.\n        for i in range(1, n):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n    \n            while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n    \n            if i + z[i] - 1 > r:\n                l = i\n                r = i + z[i] - 1\n    \n        return z\n    \n    #Function to update the bit array.\n    def update(self, idx, val, bit, n):\n        if idx == 0:\n            return\n        while idx <= n:\n            bit[idx] += val\n            idx += (idx & - idx)\n    \n    #Function to calculate prefix sum.\n    def pref(self, idx, bit):\n        ans = 0\n        while idx > 0:\n            ans += bit[idx]\n            idx -= (idx & - idx)\n    \n        return ans\n    \n    #Function to find maximum frequency.\n    def maxFrequency(self, s):\n        n = len(s)\n        #calculating Z array for the given string.\n        z = self.z_function(s)\n    \n        bit = [0] * (n + 5)\n    \n        #updating bit array based on the z values.\n        for i in range(1, n):\n            self.update(z[i], 1, bit, n)\n    \n        m = defaultdict(int)\n    \n        #iterating over the z array and updating the count of repeated values.\n        for i in range(n - 1, 0, -1):\n            if z[i] != n - i:\n                continue\n    \n            m[z[i]] += ((self.pref(n, bit)) - self.pref(z[i] - 1, bit) + 1)\n    \n        ans = 1\n        #finding the maximum frequency.\n        for val in m.values():\n            ans = max(ans, val)\n    \n        return ans",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "//User function Template for C#\n\nclass Solution\n{\n    //Function to calculate the Z-function of a string.\n    public int[] z_function(string s)\n    {\n        int n = s.Length;\n        int[] z = new int[n];\n        \n        //iterating over each index of the string.\n        for(int i = 1, l = 0, r = 0; i < n; i++)\n        {\n            //calculating the value of z[i] based on previous computations.\n            if(i <= r)\n                z[i] = Math.Min(r - i + 1, z[i - l]);\n\n            //updating z[i] if the characters at s[z[i]] and s[i + z[i]] match.\n            while(i + z[i] < n && s[z[i]] == s[i + z[i]])\n                z[i]++;\n\n            //updating l and r if z[i] extends beyond the current rightmost boundary.\n            if(i + z[i] - 1 > r)\n                l = i; \n                r = i + z[i] - 1;\n        }\n\n        return z;\n    }\n\n    //Function to update a value at a specific index in the binary indexed tree.\n    public void update(int idx, int val, int[] bit, int n)\n    {\n        //return if the index is 0.\n        if(idx == 0)\n            return;\n\n        //updating the value at the given index and its subsequent indexes in the binary indexed tree.\n        while(idx <= n)\n        {\n            bit[idx] += val;\n            idx += (idx&-idx);\n        }\n    }\n\n    //Function to calculate the prefix sum up to a specific index in the binary indexed tree.\n    public int pref(int idx, int[] bit)\n    {\n        int ans = 0;\n        \n        //calculating the prefix sum using the binary indexed tree.\n        while(idx > 0)\n        {\n            ans += bit[idx];\n            idx -= (idx&-idx);\n        }    \n\n        return ans;\n    }\n\n    //Function to calculate the maximum frequency of a substring in the given string.\n    public int maxFrequency(string str)\n    {\n        int n = str.Length;\n        \n        //calculating the Z-function for the string.\n        int[] z = z_function(str);\n\n        //creating a binary indexed tree of size n+5.\n        int[] bit = new int[n+5];\n        \n        //updating the binary indexed tree based on the Z-function values.\n        for(int i = 1; i < n; i++)\n            update(z[i], 1, bit, n);\n\n        //creating a map to store the frequencies of substrings.\n        Dictionary<int, int> m = new Dictionary<int, int>();\n\n        //iterating over the Z-function values in reverse order.\n        for(int i = n-1; i >= 1; i--)\n        {\n            //if z[i] is not equal to (n-i), continue with the next iteration.\n            if(z[i] != (n-i))\n                continue;\n\n            //calculating the frequency of the substring based on the prefix sum.\n            if(m.ContainsKey(z[i]))\n                m[z[i]] += (pref(n, bit) - pref(z[i]-1, bit) + 1);\n            else\n                m[z[i]] = (pref(n, bit) - pref(z[i]-1, bit) + 1);\n        }\n        \n        //storing the maximum frequency in the variable ans.\n        int ans = 1;\n        foreach(var it in m)\n            ans = Math.Max(ans, it.Value);\n\n        return ans;\n    }\n}",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\n/**\n * @param {string} S\n * @returns {number}\n*/\n\nclass Solution\n{\n    //Function to find the maximum frequency character in a string.\n    maxFrequency(S)\n    {\n        const z_function = (s) => {\n            const n = s.length;\n            const z = new Array(n).fill(0);\n            let l = 0, r = 0;\n            \n            for (let i = 1; i < n; i++) {\n                if (i <= r) {\n                    z[i] = Math.min(r - i + 1, z[i - l]);\n                }\n                \n                while (i + z[i] < n && s[z[i]] === s[i + z[i]]) {\n                    z[i] += 1;\n                }\n                \n                if (i + z[i] - 1 > r) {\n                    l = i;\n                    r = i + z[i] - 1;\n                }\n            }\n            \n            return z;\n        }\n        \n        const update = (idx, val, bit, n) => {\n            if (idx === 0) {\n                return;\n            }\n            \n            while (idx <= n) {\n                bit[idx] += val;\n                idx += (idx & -idx);\n            }\n        }\n        \n        const pref = (idx, bit) => {\n            let ans = 0;\n            \n            while (idx > 0) {\n                ans += bit[idx];\n                idx -= (idx & -idx);\n            }\n            \n            return ans;\n        }\n        \n        const n = S.length;\n        const z = z_function(S);\n        const bit = new Array(n + 5).fill(0);\n        \n        for (let i = 1; i < n; i++) {\n            update(z[i], 1, bit, n);\n        }\n        \n        const m = new Map();\n        \n        for (let i = n - 1; i > 0; i--) {\n            if (z[i] !== n - i) {\n                continue;\n            }\n            \n            if (!m.has(z[i])) {\n                m.set(z[i], ((pref(n, bit)) - pref(z[i] - 1, bit) + 1));\n            } else {\n                m.set(z[i], m.get(z[i]) + ((pref(n, bit)) - pref(z[i] - 1, bit) + 1));\n            }\n        }\n        \n        let ans = 1;\n        \n        for (const val of m.values()) {\n            ans = Math.max(ans, val);\n        }\n        \n        return ans;\n    }\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}