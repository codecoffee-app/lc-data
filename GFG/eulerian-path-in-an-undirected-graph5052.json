{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 705577,
            "title": "Eulerian Path in an Undirected Graph",
            "titleSlug": "eulerian-path-in-an-undirected-graph5052",
            "content": "<p><span style=\"font-size: 18px;\">Given an adjacency matrix representation of an unweighted undirected graph named&nbsp;<strong>graph</strong>, which has <strong>N</strong> vertices. You have to find out if there is an <a href=\"https://en.wikipedia.org/wiki/Eulerian_path\">eulerian path</a> present in the graph&nbsp;or not.<br /><strong>Note:</strong> The graph consists of a single component</span></p>\n<p><strong><span style=\"font-size: 18px;\">Example 1:</span></strong></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong> N = 5\ngraph = {{0, 1, 0, 0, 1}, \n&nbsp;\\t  {1, 0, 1, 1, 0}, \n&nbsp;\\t  {0, 1, 0, 1, 0}, \n&nbsp;\\t  {0, 1, 1, 0, 0}, \n&nbsp;\\t  {1, 0, 0, 0, 0}}\n<strong>Output:</strong> 1\n<strong>Explaination:</strong> There is an eulerian path. \nThe path is 5-&gt;1-&gt;2-&gt;4-&gt;3-&gt;2.</span></pre>\n<p><strong><span style=\"font-size: 18px;\">Example 2:</span></strong></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong> N = 5\ngraph = {{0, 1, 0, 1, 1}, \n&nbsp;\\t  {1, 0, 1, 0, 1}, \n&nbsp;\\t  {0, 1, 0, 1, 1}, \n&nbsp;\\t  {1, 0, 1, 0, 0}, \n&nbsp;\\t  {1, 1, 1, 0, 0}}\n<strong>Output:</strong> 0\n<strong>Explaination:</strong> There is no eulerian path in \nthe graph.</span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Your Task:</strong><br />You do not need to read input or print anything. Your task is to complete the function <strong>eulerPath()</strong> which takes N and graph as input parameters and returns 1 if there is an eulerian path. Otherwise returns 0.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:</strong> O(N<sup>2</sup>)<br /><strong>Expected Auxiliary Space:</strong> O(N<sup>2</sup>)</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; N &le; 50&nbsp;</span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Every node must have even number of edges. If there is any odd edged vertex then there will be 2 odd edged vertices. Otherwise there is no eulerian path.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Graph",
                "slug": "graph"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\r\n\r\nclass Solution{\r\npublic:\r\n    int eulerPath(int N, vector<vector<int>> graph){\r\n        vector<int> numofadj;\r\n        int ng[N][N];\r\n        for(int i = 0;i < N;i++)\r\n            for(int j = 0;j < N;j++)\r\n                ng[i][j] = graph[i][j];\r\n        // Find out number of edges each vertex has\r\n        for (int i = 0; i < N; i++)\r\n            numofadj.push_back(accumulate(ng[i], ng[i] + N, 0));\r\n        // Find out how many vertex has odd number edges\r\n        int startpoint = 0, numofodd = 0;\r\n        for (int i = N - 1; i >= 0; i--){\r\n            if (numofadj[i] % 2 == 1){\r\n                numofodd++;\r\n                startpoint = i;\r\n            }\r\n        }\r\n        // If number of vertex with odd number of edges\r\n        // is greater than two return \"No Solution\".\r\n        if (numofodd > 2)\r\n            return 0;\r\n        // If there is a path find the path\r\n        // Initialize empty stack and path\r\n        // take the starting current as discussed\r\n        stack<int> stack;\r\n        vector<int> path;\r\n        int cur = startpoint;\r\n        // Loop will run until there is element in the stack\r\n        // or current edge has some neighbour.\r\n        while (!stack.empty() or accumulate(ng[cur],ng[cur] + N, 0) != 0)\r\n        {\r\n            // If current node has not any neighbour\r\n            // add it to path and pop stack\r\n            // set new current to the popped element\r\n            if (accumulate(ng[cur], ng[cur] + N, 0) == 0){\r\n                path.push_back(cur);\r\n                cur = stack.top();\r\n                stack.pop();\r\n            }\r\n            // If the current vertex has at least one\r\n            // neighbour add the current vertex to stack,\r\n            // remove the edge between them and set the\r\n            // current to its neighbour.\r\n            else{\r\n                for (int i = 0; i < N; i++){\r\n                    if (ng[cur][i] == 1) {\r\n                        stack.push(cur);\r\n                        ng[cur][i] = 0;\r\n                        ng[i][cur] = 0;\r\n                        cur = i;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return 1;\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "\r\n\r\nclass Solution{\r\n    \r\n\tstatic int sum(int [] arr) {\r\n\t\tint answer = 0;\r\n\t\tfor(int k: arr)\r\n\t\t\tanswer+=k;\r\n\t\treturn answer;\r\n\t}\r\n\tstatic int eulerPath(int N, int graph[][]){\r\n        ArrayList<Integer> numofadj = new ArrayList<>();\r\n        int ng[][] = new int[N][N];\r\n        for(int i = 0;i < N;i++)\r\n            for(int j = 0;j < N;j++)\r\n                ng[i][j] = graph[i][j];\r\n        // Find out number of edges each vertex has\r\n        for (int i = 0; i < N; i++)\r\n            numofadj.add(sum(ng[i]));\r\n        // Find out how many vertex has odd number edges\r\n        int startpoint = 0, numofodd = 0;\r\n        for (int i = N - 1; i >= 0; i--){\r\n            if (numofadj.get(i) % 2 == 1){\r\n                numofodd++;\r\n                startpoint = i;\r\n            }\r\n        }\r\n        // If number of vertex with odd number of edges\r\n        // is greater than two return \"No Solution\".\r\n        if (numofodd > 2)\r\n            return 0;\r\n        // If there is a path find the path\r\n        // Initialize empty stack and path\r\n        // take the starting current as discussed\r\n        Stack<Integer> stack = new Stack<>();\r\n        ArrayList<Integer> path = new ArrayList<>();\r\n        int cur = startpoint;\r\n        // Loop will run until there is element in the stack\r\n        // or current edge has some neighbour.\r\n        while (!stack.empty() || sum(ng[cur]) != 0)\r\n        {\r\n            // If current node has not any neighbour\r\n            // add it to path and pop stack\r\n            // set new current to the popped element\r\n            if (sum(ng[cur]) == 0){\r\n                path.add(cur);\r\n                cur = stack.peek();\r\n                stack.pop();\r\n            }\r\n            // If the current vertex has at least one\r\n            // neighbour add the current vertex to stack,\r\n            // remove the edge between them and set the\r\n            // current to its neighbour.\r\n            else{\r\n                for (int i = 0; i < N; i++){\r\n                    if (ng[cur][i] == 1) {\r\n                        stack.push(cur);\r\n                        ng[cur][i] = 0;\r\n                        ng[i][cur] = 0;\r\n                        cur = i;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return 1;\r\n\t}\r\n\r\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "# Back-end complete function Template for Python3\n\nclass Solution:\n    # Function to find Eulerian Path in a graph.\n    def eulerPath(self, N, graph):\n        n = N\n        numofadj = list()\n        # Counting the number of adjacent nodes for each node.\n        for i in range(n):\n            numofadj.append(sum(graph[i]))\n        startpoint = 0\n        numofodd = 0\n        # Finding the starting point and the number of nodes with odd degree.\n        for i in range(n-1, -1, -1):\n            if (numofadj[i] % 2 == 1):\n                numofodd += 1\n                startpoint = i\n        # If there are more than 2 nodes with odd degree, there is no Eulerian path.\n        if (numofodd > 2):\n            return 0\n        stack = list()\n        path = list()\n        cur = startpoint\n        # Finding the Eulerian path using a stack to store the visited nodes.\n        while(stack != [] or sum(graph[cur]) != 0):\n            if (sum(graph[cur]) == 0):\n                path.append(cur + 1)\n                cur = stack.pop(-1)\n            else:\n                for i in range(n):\n                    if graph[cur][i] == 1:\n                        stack.append(cur)\n                        graph[cur][i] = 0\n                        graph[i][cur] = 0\n                        cur = i\n                        break\n        return 1",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "//Back-end complete function Template for C#\nclass Solution\n{\n    public int eulerPath(int N, List<List<int>> graph)\n    {\n        List<int> numofadj = new List<int>();\n        int[,] ng = new int[N, N];\n        int edgeCount = 0; // To store the total number of edges in the graph\n        \n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n            {\n                ng[i, j] = graph[i][j];\n                if (ng[i, j] == 1 && i < j) // Count each edge only once\n                    edgeCount++;\n            }\n        \n        // Find out number of edges each vertex has\n        for (int i = 0; i < N; i++)\n            numofadj.Add(ng.Cast<int>().Skip(i * N).Take(N).Sum());\n        \n        // Find out how many vertex has odd number edges\n        int startpoint = 0, numofodd = 0;\n        for (int i = N - 1; i >= 0; i--)\n        {\n            if (numofadj[i] % 2 == 1)\n            {\n                numofodd++;\n                startpoint = i;\n            }\n        }\n        \n        // If number of vertex with odd number of edges\n        // is greater than two return 0.\n        if (numofodd > 2)\n            return 0;\n        \n        // If there is a path find the path\n        // Initialize empty stack and path\n        // take the starting current as discussed\n        Stack<int> stack = new Stack<int>();\n        List<int> path = new List<int>();\n        int cur = startpoint;\n        \n        // Loop will run until there is element in the stack\n        // or current edge has some neighbor.\n        while (stack.Count > 0 || numofadj[cur] != 0)\n        {\n            // If current node has no neighbor\n            // add it to path and pop the stack\n            // set new current to the popped element\n            if (numofadj[cur] == 0)\n            {\n                path.Add(cur);\n                if (stack.Count > 0) // Checking if the stack is not empty before popping\n                    cur = stack.Pop();\n            }\n            // If the current vertex has at least one\n            // neighbor add the current vertex to stack,\n            // remove the edge between them and set the\n            // current to its neighbor.\n            else\n            {\n                for (int i = 0; i < N; i++)\n                {\n                    if (ng[cur, i] == 1)\n                    {\n                        stack.Push(cur);\n                        ng[cur, i] = 0;\n                        ng[i, cur] = 0;\n                        numofadj[cur]--;\n                        numofadj[i]--;\n                        cur = i;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        // If there is a path, add the last vertex to the path\n        if (stack.Count == 0 && numofadj[cur] == 0)\n            path.Add(cur);\n        \n        // Return the Euler Path or 0 if there is no solution\n        // Check if the path includes all edges\n        if (path.Count == edgeCount + 1)\n            return 1;\n        else\n            return 0;\n    }\n}",
                "lang_text": "csharp"
            }
        ],
        "platform": "GFG"
    }
}