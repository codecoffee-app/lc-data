{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 709904,
            "title": "Even Swap",
            "titleSlug": "even-swap",
            "content": "<p><span style=\"font-size:18px\">You are given an array<strong> a</strong> and you need to generate an array <strong>b</strong>. You are allowed to apply only one type of operation on the array <strong>a,&nbsp;</strong>any number of times. </span></p>\r\n\r\n<p><span style=\"font-size:18px\">In one operation you can swap <strong>a<sub>i</sub>&nbsp;</strong>with&nbsp;<strong>a<sub>i+1</sub></strong>&nbsp;only if <strong>a<sub>i</sub>+a<sub>i+1</sub></strong> is even.</span></p>\r\n\r\n<p><span style=\"font-size:18px\">Array <strong>b </strong>thus generated by applying above operation any number of times,&nbsp;should be lexicographically the largest among all arrays that can be generated from array <strong>a.</strong></span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong>\r\nN=3\r\na[]={1,3,5}\r\n<strong>Output:</strong>\r\n5,3,1\r\n<strong>Explanation: </strong>[1,3,5],[1,5,3],[3,1,5],[3,5,1],\r\n[5,1,3] and [5,3,1] are all possible\r\nvalues of array <strong>b</strong> while the last one is \r\nlexicographically largest.</span></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 2:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong>\r\nN=4\r\na[]={1,3,4,2}\r\n<strong>Output:</strong>\r\nb[]={3,1,4,2}\r\n<strong>Explanation:</strong> [1,3,4,2],[1,3,2,4],[3,1,2,4] and \r\n[3,1,4,2] are all possible values of <strong>b</strong> among \r\nwhich the last one is lexicographically largest one.</span></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Your Task:&nbsp;&nbsp;</strong><br />\r\nYou don&#39;t need to read input or print anything. Your task is to complete the function <strong>lexicographically Largest()</strong>&nbsp;which takes the array arr[], and its size N<strong>&nbsp;</strong>as input parameters&nbsp;and returns the array b.</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong> O(NlogN)<br />\r\n<strong>Expected Auxiliary Space:</strong> O(1)</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Constraints:</strong><br />\r\n1 &lt;= N &lt;= 10</span><sup><span style=\"font-size:15px\">5</span></sup><br />\r\n<span style=\"font-size:18px\">1&lt;= arr[i] &lt;= 10<sup>5</sup></span><br />\r\n<span style=\"font-size:18px\">Array may contain duplicate elements.&nbsp;</span></p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p>Any Subarray can be sorted using given operations if the operation can be applied between every&nbsp;consecutive elements of that subarray.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Arrays",
                "slug": "arrays"
            },
            {
                "name": "Sorting",
                "slug": "sorting"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\n\nclass Solution\n{\n    public:\n        //Function to find the lexicographically largest array.\n        vector <int> lexicographicallyLargest(vector <int> &a,int n)\n        {\n            int i=0;\n            //iterating through the array.\n            while(i<n)\n            {\n                int j=i+1;\n                //checking if the current number and next number have the same parity.\n                while(j<n && a[j]%2==a[j-1]%2)\n                {\n                    j++;\n                }\n                //sorting the subarray in descending order.\n                sort(a.begin()+i,a.begin()+j,greater<int>());\n                i=j;\n            }\n            //returning the lexicographically largest array.\n            return a;\n        }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution{\r\n    \r\n\tvoid swap(int [] arr, int i, int j) {\r\n\t\tint temp = arr[i];\r\n\t\tarr[i] = arr[j];\r\n\t\tarr[j] = temp;\r\n\t}\r\n\t\r\n\tvoid sort(int [] arr, int i, int j) {\r\n\t\t//sorting the subarray\r\n\t\tArrays.sort(arr, i, j);\r\n\t\t//reversing for descending order\r\n\t\twhile(i < j) {\r\n\t\t\tswap(arr, i++, --j);\r\n\t\t}\r\n\t}\r\n\t\r\n\tint [] lexicographicallyLargest(int [] arr, int n) {\r\n\t\tint i=0;\r\n        while(i<n)\r\n        {\r\n            int j=i+1;\r\n            while(j<n && arr[j]%2 == arr[j-1]%2)\r\n            {\r\n                j++;\r\n            }\r\n            //sorting this part in given lexicographical way\r\n            sort(arr, i, j);\r\n            i=j;\r\n        }\r\n        return arr;\r\n\t}\r\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "class Solution():\r\n    def lexicographicallyLargest(self, a, n):\r\n        i=0\r\n        ans = []   # initialize an empty list to store the final answer\r\n        \r\n        while i<n:\r\n            j=i+1   # set j as the next index after i\r\n            while j<n and a[j]%2==a[j-1]%2:   # check if consecutive elements have the same parity\r\n                j+=1   # increment j until consecutive elements have different parity\r\n            tmp = a[i:j]   # create a sublist from index i to j\r\n            tmp.sort(reverse = True)   # sort the sublist in descending order\r\n            ans.extend(tmp)   # add the sorted sublist to the final answer list\r\n            i=j   # set i as the next index after j\r\n            \r\n        return ans   # return the final answer list",
                "lang_text": "python3"
            },
            {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\n/**\n * @param {number[]} a\n * @param {number} n\n * @returns {number[]}\n*/\n\nclass Solution {\n    //Function to return the lexicographically largest array\n    lexicographicallyLargest(a, n) {\n        let i = 0;\n        let ans = []; // initialize an empty array to store the final answer\n        \n        while (i < n) {\n            let j = i + 1; // set j as the next index after i\n            while (j < n && a[j] % 2 == a[j - 1] % 2) { // check if consecutive elements have the same parity\n                j++; // increment j until consecutive elements have different parity\n            }\n            let tmp = a.slice(i, j); // create a sublist from index i to j\n            tmp.sort((x, y) => y - x); // sort the sublist in descending order\n            ans = ans.concat(tmp); // add the sorted sublist to the final answer array\n            i = j; // set i as the next index after j\n        }\n        \n        return ans; // return the final answer array\n    }\n}",
                "lang_text": "javascript"
            },
            {
                "lang": "C#",
                "full_func": "//User function Template for C#\n\nclass Solution\n{\n    //Complete this function\n    public List<int> lexicographicallyLargest(List<int> a, int n)\n    {\n        int i=0;\n        //iterating through the array.\n        while(i<n)\n        {\n            int j=i+1;\n            //checking if the current number and next number have the same parity.\n            while(j<n && a[j]%2==a[j-1]%2)\n            {\n                j++;\n            }\n            //sorting the subarray in descending order.\n            List<int> subarray = a.GetRange(i, j - i);\n            subarray.Sort((x, y) => y.CompareTo(x));\n            for (int k = i; k < j; k++)\n            {\n                a[k] = subarray[k - i];\n            }\n            i=j;\n        }\n        //returning the lexicographically largest array.\n        return a;\n    }\n}",
                "lang_text": "csharp"
            }
        ],
        "platform": "GFG"
    }
}