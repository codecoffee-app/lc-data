{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 714140,
            "title": "Anagrams in Linked List",
            "titleSlug": "find-anagrams-in-linked-list--170647",
            "content": "<p><span style=\"font-size: 12pt;\">Given a linked list of characters and a string <strong>str</strong>. Return all the anagrams of the string present in the given linked list. In case of overlapping anagrams choose the first anagram from left. <span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">If there is no anagram in the linked list, return an empty array.</span></span></p>\n<p><span style=\"font-size: 12pt;\"><strong>Examples:</strong></span></p>\n<pre><span style=\"font-size: 12pt;\"><strong>Input:</strong> Linked list:<strong> </strong>a -&gt; b -&gt; c -&gt; a -&gt; d -&gt; b -&gt; c -&gt; a, str = bac<strong>\nOutput: </strong>[a -&gt; b -&gt; c, b -&gt; c -&gt; a]<strong>\nExplanation: </strong>In the given linked list, there are three anagrams: \n1. <strong><span style=\"color: #ff0000;\">a -&gt; b -&gt; c</span></strong> -&gt; a -&gt; d -&gt; b -&gt; c -&gt; a\n2. a -&gt; <strong><span style=\"color: #ff0000;\">b -&gt; c -&gt; a</span></strong> -&gt; d -&gt; b -&gt; c -&gt; a\n3. a -&gt; b -&gt; c -&gt; a -&gt; d -&gt; <strong><span style=\"color: #ff0000;\">b -&gt; c -&gt; a<br /><img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/714140/Web/Other/blobid0_1723398166.png\" width=\"401\" height=\"169\" /><br /></span></strong><span style=\"color: #000000;\">But in 1 and 2, a -&gt; b -&gt; c and b -&gt; c-&gt; a are ovelapping.So we take a -&gt; b -&gt; c as it comes first from left.So the output is: [a-&gt;b-&gt;c,b-&gt;c-&gt;a]</span></span></pre>\n<pre><span style=\"font-size: 12pt;\"><strong><span style=\"color: #000000;\">Input: </span></strong><span style=\"color: #000000;\">Linked list:</span><strong><span style=\"color: #000000;\"> </span></strong><span style=\"color: #000000;\">a -&gt; b -&gt; d -&gt; c -&gt; a, str</span><span style=\"color: #000000;\"> = bac<br /><img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/714140/Web/Other/blobid1_1723398186.png\" width=\"400\" height=\"50\" /></span><strong><span style=\"color: #000000;\">\nOutput: </span></strong><span style=\"color: #000000;\">-1</span><strong> \nExplanation: </strong>There is no anagrams, so the output is -1</span></pre>\n<p><span style=\"font-size: 12pt;\"><strong>Expected Time Complexity:</strong> O(n)<br /><strong>Expected Space&nbsp;</strong><strong style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">Complexity</strong><strong style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">:</strong><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\"> O(1)</span></span></p>\n<p><span style=\"font-size: 12pt;\"><strong>Constraints:</strong><br />1 &lt;= size of linked list &lt;= 10<sup>6</sup><sup><br /></sup>data of nodes: Only lowercase alphabet<sup><br /></sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a linked list of characters and a string `str`, identify and return all non-overlapping anagrams of `str` that are present within the linked list. Anagrams should be chosen from left to right. If no anagrams are found, return an empty array.",
                "constraints": [
                    "1 <= size of linked list <= 10^6",
                    "Data of nodes: Only lowercase alphabet"
                ],
                "testcases": [
                    {
                        "input": "Linked list: a -> b -> c -> a -> d -> b -> c -> a, str = bac",
                        "output": "[a -> b -> c, b -> c -> a]",
                        "explanation": "The linked list contains three anagrams of 'bac': 'abc', 'bca', and 'bca'.  The first two ('abc' and 'bca') overlap. Because anagrams should be selected from left to right and we can't have overlapping anagrams, the first two anagrams are 'a -> b -> c' and 'b -> c -> a'."
                    },
                    {
                        "input": "Linked list: a -> b -> d -> c -> a, str = bac",
                        "output": "[]",
                        "explanation": "The linked list does not contain any anagrams of the string 'bac'."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span >The idea is to use a two-pointer approach.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            },
            {
                "name": "sliding-window",
                "slug": "sliding-window"
            }
        ],
        "companies": [],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\n  public:\n    // Function to check if two arrays are anagrams\n    bool checkAnagram(int A[], int B[]) {\n        for (int i = 0; i < 26; i++) {\n            if (A[i] != B[i])\n                return false;\n        }\n        return true;\n    }\n\n    // Function to check if two subarrays are anagrams and push the first subarray to\n    // the result vector\n    void checkAndPush(bool isAnagram, int len, Node*& ptr1, Node*& ptr2,\n                      vector<Node*>& res, int freq[]) {\n        if (!isAnagram)\n            return;\n\n        // Push the first subarray to the result vector\n        res.push_back(ptr1);\n\n        // Move to the next subarray\n        Node* temp = ptr2;\n        ptr2 = ptr2->next;\n        if (temp)\n            temp->next = nullptr;\n        ptr1 = ptr2;\n\n        // Reset the frequency array\n        for (int i = 0; i < 26; i++)\n            freq[i] = 0;\n\n        // Update the frequency array with the elements of the new subarray\n        Node* prev = nullptr;\n        for (int i = 0; i < len && ptr2; i++) {\n            freq[ptr2->data - 'a']++;\n            prev = ptr2;\n            if (ptr2)\n                ptr2 = ptr2->next;\n        }\n\n        ptr2 = prev;\n    }\n\n    // Function to find all anagrams of a given string in a linked list\n    vector<Node*> findAnagrams(Node* head, string str) {\n        int len = str.length();\n        int freq[26] = {};\n\n        // Count the frequency of characters in the given string\n        for (char ch : str) {\n            freq[ch - 'a']++;\n        }\n\n        int freq1[26] = {};\n\n        // Initialize pointers to traverse the linked list\n        Node* ptr1 = head;\n        Node* ptr2 = head;\n        Node* prev = nullptr;\n\n        // Initialize the frequency array with the elements of the first subarray\n        for (int i = 0; i < len && ptr2; i++) {\n            freq1[ptr2->data - 'a']++;\n            prev = ptr2;\n            ptr2 = ptr2->next;\n        }\n        ptr2 = prev;\n\n        vector<Node*> res;\n\n        // Traverse the linked list and find all anagrams\n        while (ptr2->next) {\n            bool ok = checkAnagram(freq1, freq);\n            if (ok) {\n                checkAndPush(ok, len, ptr1, ptr2, res, freq1);\n            } else {\n                freq1[ptr1->data - 'a']--;\n                ptr1 = ptr1->next;\n                ptr2 = ptr2->next;\n                freq1[ptr2->data - 'a']++;\n            }\n        }\n\n        // Check if the last subarray is an anagram and push it to the result vector\n        bool ok = checkAnagram(freq1, freq);\n        if (ok) {\n            res.push_back(ptr1);\n        }\n\n        return res;\n    }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n    // Function to check if two arrays are anagrams\n    public boolean isAna(int A[], int B[]) {\n        for (int i = 0; i < 26; i++) {\n            if (A[i] != B[i]) return false;\n        }\n        return true;\n    }\n\n    public ArrayList<Node> findAnagrams(Node head, String str) {\n        int len = str.length();   // Length of the string to find anagrams\n        int freq[] = new int[26]; // Frequency array for the string\n        char S[] = str.toCharArray();\n        for (char ch : S) {\n            freq[ch - 'a']++; // Counting frequency of characters in the string\n        }\n        int freq1[] = new int[26]; // Frequency array for the linked list segment\n        Node ptr1 = head;          // Pointer to start of the linked list segment\n        Node ptr2 = head;          // Pointer to end of the linked list segment\n        Node prev = null;          // To keep track of the last node in the segment\n\n        // Initialize the frequency array with the elements of the first segment\n        for (int i = 0; i < len && (ptr2 != null); i++) {\n            freq1[ptr2.data - 'a']++;\n            prev = ptr2;\n            ptr2 = ptr2.next;\n        }\n        ptr2 = prev;\n\n        ArrayList<Node> res =\n            new ArrayList<>(); // Result list to store anagram starting nodes\n\n        while (ptr2.next != null) {\n            boolean ok = isAna(freq1, freq); // Check if current segment is an anagram\n            if (ok) {\n                // If current segment is an anagram, push it to result and move to the\n                // next segment\n                Node prev1 = null;\n                res.add(ptr1);\n                Node temp1 = ptr2;\n                ptr2 = ptr2.next;\n                if (temp1 != null) temp1.next = null;\n                ptr1 = ptr2;\n                for (int i = 0; i < 26; i++) freq1[i] = 0;\n                for (int i = 0; i < len && (ptr2 != null); i++) {\n                    freq1[ptr2.data - 'a']++;\n                    prev1 = ptr2;\n                    if (ptr2 != null) ptr2 = ptr2.next;\n                }\n                ptr2 = prev1;\n\n            } else {\n                // If not an anagram, slide the window one step ahead\n                freq1[ptr1.data - 'a']--;\n                ptr1 = ptr1.next;\n                ptr2 = ptr2.next;\n                freq1[ptr2.data - 'a']++;\n            }\n        }\n\n        boolean ok = isAna(freq1, freq);\n        if (ok) {\n            res.add(ptr1);\n        }\n\n        return res;\n    }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Solution:\n\n    def checkAnagram(self, A, B):\n        # Check if two frequency arrays represent anagrams\n        for i in range(26):\n            if A[i] != B[i]:\n                return False\n        return True\n\n    def checkAndPush(self, isAnagram, n, ptr1, ptr2, res, freq1):\n        # If current substring is an anagram, push it to the result list\n        if (isAnagram == False):\n            return\n        prev = None\n        res.append(ptr1)\n        temp = ptr2\n        ptr2 = ptr2.next\n        if temp != None:\n            temp.next = None\n        ptr1 = ptr2\n        for i in range(26):\n            freq1[i] = 0\n        for i in range(n):\n            if ptr2 != None:\n                freq1[ord(ptr2.data) - ord('a')] += 1\n                prev = ptr2\n                if ptr2 != None:\n                    ptr2 = ptr2.next\n        ptr2 = prev\n\n    def findAnagrams(self, head, str):\n        n = len(str)  # Length of the string to find anagrams\n        freq = [0] * 26  # Frequency array for the string\n        for ch in str:\n            freq[ord(ch) - ord('a')] += 1\n        freq1 = [0] * 26  # Frequency array for the linked list segment\n        ptr1 = head  # Pointer to start of the linked list segment\n        ptr2 = head  # Pointer to end of the linked list segment\n        prev = None\n        for i in range(n):\n            if ptr2 != None:\n                freq1[ord(ptr2.data) - ord('a')] += 1\n                prev = ptr2\n                ptr2 = ptr2.next\n        ptr2 = prev\n        res = []  # Result list to store anagram starting nodes\n        while (ptr2.next != None):\n            ok = self.checkAnagram(\n                freq1, freq)  # Check if current segment is an anagram\n            if (ok):\n                # If current segment is an anagram, push it to result and move to the next segment\n                prev = None\n                res.append(ptr1)\n                temp = ptr2\n                ptr2 = ptr2.next\n                if temp != None:\n                    temp.next = None\n                ptr1 = ptr2\n                for i in range(26):\n                    freq1[i] = 0\n                for i in range(n):\n                    if ptr2 != None:\n                        freq1[ord(ptr2.data) - ord('a')] += 1\n                        prev = ptr2\n                        if ptr2 != None:\n                            ptr2 = ptr2.next\n                ptr2 = prev\n            else:\n                # If not an anagram, slide the window one step ahead\n                freq1[ord(ptr1.data) - ord('a')] -= 1\n                ptr1 = ptr1.next\n                ptr2 = ptr2.next\n                freq1[ord(ptr2.data) - ord('a')] += 1\n        ok = self.checkAnagram(freq1, freq)\n        if (ok):\n            res.append(ptr1)\n        return res\n",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "class Solution {\n    findAnagrams(head, str) {\n        const checkAnagram = (A, B) => {\n            // Check if two arrays are anagrams\n            for (let i = 0; i < 26; i++) {\n                if (A[i] !== B[i]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        const checkAndPush = (isAnagram, n, ptr1, ptr2, res, freq1) => {\n            // If current substring is an anagram, push it into the result array\n            if (!isAnagram) {\n                return;\n            }\n            let prev = null;\n            res.push(ptr1);\n            let temp = ptr2;\n            ptr2 = ptr2.next;\n            if (temp !== null) {\n                temp.next = null;\n            }\n            ptr1 = ptr2;\n            for (let i = 0; i < 26; i++) {\n                freq1[i] = 0;\n            }\n            for (let i = 0; i < n; i++) {\n                if (ptr2 !== null) {\n                    freq1[ptr2.data.charCodeAt(0) - 'a'.charCodeAt(0)] += 1;\n                    prev = ptr2;\n                    if (ptr2 !== null) {\n                        ptr2 = ptr2.next;\n                    }\n                }\n            }\n            ptr2 = prev;\n        };\n\n        const n = str.length;           // Length of the string to find anagrams\n        const freq = Array(26).fill(0); // Frequency array for the string\n        for (let ch of str) {\n            freq[ch.charCodeAt(0) - 'a'.charCodeAt(0)] += 1;\n        }\n        const freq1 = Array(26).fill(0); // Frequency array for the linked list segment\n        let ptr1 = head;                 // Pointer to start of the linked list segment\n        let ptr2 = head;                 // Pointer to end of the linked list segment\n        let prev = null;\n        for (let i = 0; i < n; i++) {\n            if (ptr2 !== null) {\n                freq1[ptr2.data.charCodeAt(0) - 'a'.charCodeAt(0)] += 1;\n                prev = ptr2;\n                ptr2 = ptr2.next;\n            }\n        }\n        ptr2 = prev;\n        const res = []; // Result array to store anagram starting nodes\n        while (ptr2.next !== null) {\n            let ok =\n                checkAnagram(freq1, freq); // Check if current segment is an anagram\n            if (ok) {\n                // If current segment is an anagram, push it to result and move to the\n                // next segment\n                let prev = null;\n                res.push(ptr1);\n                let temp = ptr2;\n                ptr2 = ptr2.next;\n                if (temp !== null) {\n                    temp.next = null;\n                }\n                ptr1 = ptr2;\n                for (let i = 0; i < 26; i++) {\n                    freq1[i] = 0;\n                }\n                for (let i = 0; i < n; i++) {\n                    if (ptr2 !== null) {\n                        freq1[ptr2.data.charCodeAt(0) - 'a'.charCodeAt(0)] += 1;\n                        prev = ptr2;\n                        if (ptr2 !== null) {\n                            ptr2 = ptr2.next;\n                        }\n                    }\n                }\n                ptr2 = prev;\n            } else {\n                // If not an anagram, slide the window one step ahead\n                freq1[ptr1.data.charCodeAt(0) - 'a'.charCodeAt(0)] -= 1;\n                ptr1 = ptr1.next;\n                ptr2 = ptr2.next;\n                freq1[ptr2.data.charCodeAt(0) - 'a'.charCodeAt(0)] += 1;\n            }\n        }\n        let ok = checkAnagram(freq1, freq);\n        if (ok) {\n            res.push(ptr1);\n        }\n        return res;\n    }\n}\n",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}