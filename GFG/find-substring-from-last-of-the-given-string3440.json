{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 703401,
            "title": "Find Substring from last of the Given String",
            "titleSlug": "find-substring-from-last-of-the-given-string3440",
            "content": "<p><span style=\"font-size:18px\">Given two strings X and Y, the task is to find the last index in X at which string Y appears, if Y does not appear then the answer is -1. </span></p>\n\n<p><span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\n\n<pre>\n<span style=\"font-size:18px\"><strong>Input:</strong> X = &quot;geeksforgeeks&quot;, Y = &quot;geeks&quot;\n<strong>output:</strong> 9\n<strong>Explanation:</strong> string &quot;geeks&quot; appears at \nindex 1 and 9</span></pre>\n\n<p><span style=\"font-size:18px\"><strong>Example 2:</strong></span></p>\n\n<pre>\n<span style=\"font-size:18px\"><strong>Input:</strong> X = &quot;geesforgees&quot;, Y = &quot;geeks&quot; \n<strong>output:</strong> -1 \n<strong>Explanation:</strong> &quot;geeks&quot; does not appear</span></pre>\n\n<p><span style=\"font-size:18px\"><strong>Your task:</strong><br />\nYou do not need to read any input or print anything. The task is to complete the function <strong>search()</strong>, which takes two strings as input and returns an integer. </span></p>\n\n<p><span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong>&nbsp;O(|X| + |Y|)<br />\n<strong>Expected Auxiliary Space:</strong>&nbsp;O(|X| + |Y|)</span></p>\n\n<p><span style=\"font-size:18px\"><strong>Constraints:</strong></span><br />\n<span style=\"font-size:18px\">1 &le; |X|, |Y| &le; 10<sup>5</sup><br />\nBoth the strings contains lower case English alphabets </span></p>\n",
            "isPaidOnly": false,
            "difficulty": "Basic",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p>1. Use kmp algorithm</p>"
        ],
        "relatedTopics": [
            {
                "name": "Strings",
                "slug": "strings"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function template for C++\n\nclass Solution{\npublic:\n\t//Function to compute the Longest Prefix Suffix (LPS) array.\n\tvoid computeLPSArray(string Y, int M, int* lps) \n\t{ \n\t\tint len = 0; \n\n\t\t//Initializing LPS of first character as 0.\n\t\tlps[0] = 0; \n\n\t\t//Iterating through the pattern to compute LPS values.\n\t\tint i = 1; \n\t\twhile (i < M) { \n\t\t\t//If characters at current positions match, increment len, \n\t\t\t//update LPS value, and move to next positions.\n\t\t\tif (Y[i] == Y[len]) { \n\t\t\t\tlen++; \n\t\t\t\tlps[i] = len; \n\t\t\t\ti++; \n\t\t\t} \n\t\t\telse \n\t\t\t{ \n\t\t\t\t//If characters don't match and len is not 0, \n\t\t\t\t//update len based on previous LPS value.\n\t\t\t\tif (len != 0) { \n\t\t\t\t\tlen = lps[len - 1]; \n\t\t\t\t} \n\t\t\t\t//If characters don't match and len is 0, set LPS value as 0, \n\t\t\t\t//and move to next positions.\n\t\t\t\telse \n\t\t\t\t{ \n\t\t\t\t\tlps[i] = 0; \n\t\t\t\t\ti++; \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} \n\n\t//Function to search pattern in given text and return the starting index of the first occurrence.\n\tint search(string X, string Y)\n\t{\n\t\tint M = Y.size(); \n\t\tint N = X.size(); \n\n\t\t//Creating LPS array.\n\t\tint lps[M]; \n\n\t\t//Computing LPS array.\n\t\tcomputeLPSArray(Y, M, lps); \n\n\t\tint i = 0; \n\t\tint j = 0; \n\t\tint ans = -1;\n\n\t\t//Matching pattern with text using LPS array.\n\t\twhile (i < N) { \n\t\t\t//If characters at current positions match, move to next positions.\n\t\t\tif (Y[j] == X[i]) { \n\t\t\t\tj++; \n\t\t\t\ti++; \n\t\t\t} \n\n\t\t\t//If all characters in pattern are matched, update ans with the starting index\n\t\t\t//of the first occurrence of the pattern and update j with LPS[j-1].\n\t\t\tif (j == M) { \n\t\t\t\tans = max(ans, i - j + 1);\n\t\t\t\tj = lps[j - 1]; \n\t\t\t} \n\n\t\t\t//If characters at current positions don't match, update j based on LPS[j-1].\n\t\t\telse if (i < N && Y[j] != X[i]) { \n\t\t\t\tif (j != 0) \n\t\t\t\t\tj = lps[j - 1]; \n\t\t\t\telse\n\t\t\t\t\ti = i + 1; \n\t\t\t} \n\t\t} \n\n\t\t//Returning the starting index of the first occurrence of the pattern.\n\t\treturn ans;\n\t}\n\t \n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": null,
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": null,
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "//User function template for C#\nclass Solution\n{\n    //Function to compute the Longest Prefix Suffix (LPS) array.\n    void computeLPSArray(string Y, int M, int[] lps) \n    { \n        int len = 0; \n\n        //Initializing LPS of first character as 0.\n        lps[0] = 0; \n\n        //Iterating through the pattern to compute LPS values.\n        int i = 1; \n        while (i < M) { \n            //If characters at current positions match, increment len, \n            //update LPS value, and move to next positions.\n            if (Y[i] == Y[len]) { \n                len++; \n                lps[i] = len; \n                i++; \n            } \n            else \n            { \n                //If characters don't match and len is not 0, \n                //update len based on previous LPS value.\n                if (len != 0) { \n                    len = lps[len - 1]; \n                } \n                //If characters don't match and len is 0, set LPS value as 0, \n                //and move to next positions.\n                else \n                { \n                    lps[i] = 0; \n                    i++; \n                } \n            } \n        } \n    } \n\n    //Function to search pattern in given text and return the starting index of the first occurrence.\n    public int search(string X, string Y)\n    {\n        int M = Y.Length; \n        int N = X.Length; \n\n        //Creating LPS array.\n        int[] lps = new int[M]; \n\n        //Computing LPS array.\n        computeLPSArray(Y, M, lps); \n\n        int i = 0; \n        int j = 0; \n        int ans = -1;\n\n        //Matching pattern with text using LPS array.\n        while (i < N) { \n            //If characters at current positions match, move to next positions.\n            if (Y[j] == X[i]) { \n                j++; \n                i++; \n            } \n\n            //If all characters in pattern are matched, update ans with the starting index\n            //of the first occurrence of the pattern and update j with LPS[j-1].\n            if (j == M) { \n                ans = Math.Max(ans, i - j + 1);\n                j = lps[j - 1]; \n            } \n\n            //If characters at current positions don't match, update j based on LPS[j-1].\n            else if (i < N && Y[j] != X[i]) { \n                if (j != 0) \n                    j = lps[j - 1]; \n                else\n                    i = i + 1; \n            } \n        } \n\n        //Returning the starting index of the first occurrence of the pattern.\n        return ans;\n    }\n}",
                "lang_text": "csharp"
            }
        ],
        "platform": "GFG"
    }
}