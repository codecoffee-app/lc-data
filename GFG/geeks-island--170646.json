{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 713595,
            "title": "Geeks Island",
            "titleSlug": "geeks-island--170646",
            "content": "<p><span style=\"font-size:18px\">Geeks Island is represented by an&nbsp;<strong>N * M</strong>&nbsp;matrix&nbsp;<strong>mat</strong>. The island is touched by the Indian Ocean from the top and left edges and the Arabian Sea from the right and bottom edges. Each element of the matrix represents the height of the cell.</span></p>\r\n\r\n<p><span style=\"font-size:18px\">Due to the rainy season, the island receives a lot of rainfall, and the water can flow in four directions(up, down, left, or right) from one cell to another one with&nbsp;<strong>height equal or lower</strong>.</span></p>\r\n\r\n<p><span style=\"font-size:18px\">You need to find the number of cells from where water can flow to both the Indian Ocean and the Arabian Sea.</span></p>\r\n\r\n<p><strong><span style=\"font-size:18px\">Example 1:</span></strong></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong></span>\r\n<span style=\"font-size:18px\">N = 5, M = 5</span>\r\n<span style=\"font-size:18px\">mat[][] =    {{1, 3, 3, 2, 4},\r\n\\t\\t   </span><span style=\"font-size:18px\">{4, 5, 6, 4, 4},</span>\r\n\\t\\t   <span style=\"font-size:18px\">{2, 4, 5, 3, 1},</span>\r\n\\t\\t   <span style=\"font-size:18px\">{6, 7, 1, 4, 5},</span>\r\n\\t\\t   <span style=\"font-size:18px\">{6, 1, 1, 3, 4}}</span>\r\n<span style=\"font-size:18px\"><strong>Output:</strong></span>\r\n<span style=\"font-size:18px\">8</span>\r\n<span style=\"font-size:18px\"><strong>Explanation:</strong></span>\r\n<span style=\"font-size:18px\">Indian    ~   ~   ~   ~   ~\r\nOcean  ~  1   3   3   2  (4) *\r\n\\t  ~  4   5  (6) (4) (4) *\r\n\\t  ~  2   4  (5)  3   1  *\r\n\\t  ~ (6) (7)  1   4   5  *\r\n\\t  ~ (6)  1   1   3   4  *\\t     \r\n&nbsp;\\t    *   *   *   *   * Arabian Sea</span>\r\n<span style=\"font-size:18px\">Water can flow to both ocean and sea from the cells\r\ndenoted by parantheses().For example at index(1,2), the height of that island is 6. If a water drop falls on that island, water can flow to up direction(as 3&lt;=6) and reach to Indian Ocean. ALso, water can flow to right direction(as 6&gt;=4&gt;=4) and reach to Arabian Sea.</span></pre>\r\n\r\n<p><strong><span style=\"font-size:18px\">Example 2:</span></strong></p>\r\n\r\n<pre>\r\n<strong><span style=\"font-size:18px\">Input:</span></strong>\r\n<span style=\"font-size:18px\">N = 2, M = 3</span>\r\n<span style=\"font-size:18px\">mat[][] =    {{1, 1, 1},</span>\r\n\\t\\t   <span style=\"font-size:18px\">{1, 1, 1}}</span>\r\n<strong><span style=\"font-size:18px\">Output:</span></strong>\r\n<span style=\"font-size:18px\">6 </span>\r\n<strong><span style=\"font-size:18px\">Explanation:</span></strong>\r\n<span style=\"font-size:18px\">Water can flow from all cells to both Indian Ocean and Arabian Sea as the height of all islands are same.</span></pre>\r\n\r\n<p><strong><span style=\"font-size:18px\">Your Task:</span></strong></p>\r\n\r\n<p><span style=\"font-size:18px\">Your task is to complete the function <strong>water_flow()&nbsp;</strong>which takes an integer array <strong>mat</strong>, integer <strong>N</strong> and integer <strong>M</strong>&nbsp;as the input parameter and returns an integer, denoting the number of cells from which water can to both ocean and sea.</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Expected Time Complexity</strong> : O(</span><span style=\"font-size:18px\">N*M</span><span style=\"font-size:18px\">)<br />\r\n<strong>Expected Auxiliary Space</strong> : O(N*M)</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Constraints:</strong></span></p>\r\n\r\n<ul>\r\n\t<li><span style=\"font-size:18px\">1 &lt;= N, M &lt;= 10<sup>3</sup></span></li>\r\n\t<li><span style=\"font-size:18px\">1 &lt;= mat[i][j] &lt;= 10<sup>6</sup></span></li>\r\n</ul>\r\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a N * M matrix representing Geeks Island, where the top and left edges are bordered by the Indian Ocean and the right and bottom edges by the Arabian Sea. Each cell's value represents its height. Water flows from a cell to adjacent cells (up, down, left, right) if the target cell's height is less than or equal to the current cell's height. Determine the number of cells from which water can flow to both the Indian Ocean and the Arabian Sea.",
                "constraints": [
                    "1 <= N, M <= 10^3",
                    "1 <= mat[i][j] <= 10^6"
                ],
                "testcases": [
                    {
                        "input": "N = 5, M = 5\nmat = {{1, 3, 3, 2, 4},\n       {4, 5, 6, 4, 4},\n       {2, 4, 5, 3, 1},\n       {6, 7, 1, 4, 5},\n       {6, 1, 1, 3, 4}}",
                        "output": "8",
                        "explanation": "Water can flow to both oceans from cells with heights 6 (at (1,2)), 4 (at (1,3) and (1,4)), 5 (at (2,2)), 7 (at (3,1)), 6 (at (4,0)).  For instance, from cell (1,2) with height 6, water can flow upwards to the Indian Ocean (3 <= 6). It can also flow to the right (4 <= 6 and 4 <= 4), eventually reaching the Arabian Sea."
                    },
                    {
                        "input": "N = 2, M = 3\nmat = {{1, 1, 1},\n       {1, 1, 1}}",
                        "output": "6",
                        "explanation": "All cells can reach both oceans because all cells have the same height.  Therefore water can flow from every cell to the edges without any height constraint issues."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:14px\">Run bfs/dfs twice, one from all the co-ordinates connected to indian ocean and other from arabian sea.<br />\nMark the visited cell and count the cell which are visited in both bfs/dfs.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "DFS",
                "slug": "dfs"
            },
            {
                "name": "Matrix",
                "slug": "matrix"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\n\nclass Solution{   \npublic:\n    //Recursive function to perform depth-first search (DFS) \n    //to mark the cells that can be reached by water flow from a given cell\n    void dfs(vector<vector<int>> &mat, vector<vector<bool>> &vis, int i, int j, int n, int m){\n\n        //Base case: If we are outside the grid or if the cell is already visited, return\n        if(i<0 || j<0 || i>=n || j>=m || vis[i][j]) return;\n        \n        //Mark the cell as visited\n        vis[i][j] = true;\n    \n        //Recursive calls to check the neighboring cells and mark them if they can be reached\n        //by water flow from the current cell\n        \n        //Check the cell above\n        if(i>0 && !vis[i-1][j] && mat[i-1][j] >= mat[i][j]){\n            dfs(mat, vis, i-1, j, n, m);\n        }\n        \n        //Check the cell below\n        if(i<n-1 && !vis[i+1][j] && mat[i+1][j] >= mat[i][j]){\n            dfs(mat, vis, i+1, j, n, m);\n        } \n        \n        //Check the cell to the left\n        if(j>0 && !vis[i][j-1] && mat[i][j-1] >= mat[i][j]){\n            dfs(mat, vis, i, j-1, n, m);\n        } \n        \n        //Check the cell to the right\n        if(j<m-1 && !vis[i][j+1] && mat[i][j+1] >= mat[i][j]){\n            dfs(mat, vis, i, j+1, n, m);\n        } \n    }\n\n    //Function to calculate the number of cells that can be reached by water flow from Indian and Arabian Ocean\n    int water_flow(vector<vector<int>> &mat,int N,int M){\n\n        //Create two 2D vectors to track the cells that can be reached from Indian and Arabian Ocean\n        vector<vector<bool>> indian(N, vector<bool>(M, false));\n        vector<vector<bool>> arabian(N, vector<bool>(M, false));\n    \n        //Mark the cells that can be reached from the Indian Ocean by performing DFS\n        //starting from the first column of the grid\n        for(int i=0;i<N;i++) dfs(mat, indian, i, 0, N, M);\n        \n        //Mark the cells that can be reached from the Indian Ocean by performing DFS\n        //starting from the first row of the grid\n        for(int i=0;i<M;i++) dfs(mat, indian, 0, i, N, M);\n        \n        //Mark the cells that can be reached from the Arabian Ocean by performing DFS\n        //starting from the last column of the grid\n        for(int i=0;i<N;i++) dfs(mat, arabian, i, M-1, N, M);\n        \n        //Mark the cells that can be reached from the Arabian Ocean by performing DFS\n        //starting from the last row of the grid\n        for(int i=0;i<M;i++) dfs(mat, arabian, N-1, i, N, M);\n    \n        //Count the number of cells that can be reached from both oceans and return the count\n        int count = 0;\n        for(int i=0;i<N;i++){\n            for(int j=0;j<M;j++){\n                if(indian[i][j] && arabian[i][j]){\n                    count++;\n                }        \n            }\n        }\n    \n        return count;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution{\n\tint water_flow(int [][] mat, int N, int M) {\n\t\t// marking cells that are reachable from the top row as Indian\n\t\tboolean indian[][]=new boolean[N][M];\n        for(int i=0;i<N;i++) dfs(mat, indian, i, 0, N, M);\n        \n        // marking cells that are reachable from the left column as Indian\n        for(int i=0;i<M;i++) dfs(mat, indian, 0, i, N, M);\n        \n        // marking cells that are reachable from the bottom row as Arabian\n        boolean arabian[][]=new boolean[N][M];\n        for(int i=0;i<N;i++) dfs(mat, arabian, i, M-1, N, M);\n        \n        // marking cells that are reachable from the right column as Arabian\n        for(int i=0;i<M;i++) dfs(mat, arabian, N-1, i, N, M);\n\n        // counting cells that are both Indian and Arabian\n        int count = 0;\n        for(int i=0;i<N;i++){\n            for(int j=0;j<M;j++){\n                if(indian[i][j] && arabian[i][j]){\n                    count++;\n                }        \n            }\n        }\n    \n        return count;\n\t}\n\n\t// implementing depth-first search to mark reachable cells\n\tvoid dfs(int mat[][], boolean vis[][], int i, int j, int n, int m){\n        // base conditions for termination of the recursive function\n        if(i<0 || j<0 || i>=n || j>=m || vis[i][j]) return;\n        vis[i][j] = true;\n    \n        // recursively visiting all valid neighbors\n        if(i>0 && !vis[i-1][j] && mat[i-1][j] >= mat[i][j]){\n            dfs(mat, vis, i-1, j, n, m);\n        }\n        if(i<n-1 && !vis[i+1][j] && mat[i+1][j] >= mat[i][j]){\n            dfs(mat, vis, i+1, j, n, m);\n        } \n        if(j>0 && !vis[i][j-1] && mat[i][j-1] >= mat[i][j]){\n            dfs(mat, vis, i, j-1, n, m);\n        } \n        if(j<m-1 && !vis[i][j+1] && mat[i][j+1] >= mat[i][j]){\n            dfs(mat, vis, i, j+1, n, m);\n        } \n    }\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "class Solution():\r\n    def isValid(self,r,c, n,m):\r\n        # Function to check if the given indices are valid or not.\r\n        if r>=n or r<0 or c>=m or c<0:\r\n            return False\r\n        return True\r\n    \r\n    def dfs(self, prev, r, c, mat, vis, n, m):\r\n        # Depth First Search function to traverse the matrix.\r\n        \r\n        # Check if the indices are invalid or already visited or the current \r\n        # element is smaller than the previous element.\r\n        if not self.isValid(r,c,n,m):\r\n            return\r\n        if vis[r][c]:\r\n            return\r\n        if mat[r][c] < prev:\r\n            return\r\n        \r\n        # Mark the current element as visited.\r\n        vis[r][c]=True\r\n        \r\n        # Recursively call DFS for the neighboring elements.\r\n        self.dfs(mat[r][c], r+1, c, mat,vis, n,m)\r\n        self.dfs(mat[r][c], r-1, c, mat,vis, n,m)\r\n        self.dfs(mat[r][c], r, c-1, mat,vis, n,m)\r\n        self.dfs(mat[r][c], r, c+1, mat,vis, n,m)\r\n\r\n\r\n    def water_flow(self, mat, n, m):\r\n        # Function to determine the number of cells where Indian and Arabian\r\n        # Ocean water can flow.\r\n        \r\n        # Initialize two matrices to keep track of cells visited by Indian and \r\n        # Arabian water.\r\n        indian = [[False for i in range(m)] for i in range(n)]\r\n        arabian = [[False for i in range(m)] for i in range(n)]\r\n        \r\n        # Call DFS to mark the cells where Indian water flows.\r\n        self.dfs(-1,0,4,mat,indian,n, m)\r\n        for i in range(n): \r\n            self.dfs(-1, i, 0, mat, indian, n, m)\r\n        for i in range(m): \r\n            self.dfs(-1, 0, i, mat, indian, n, m)\r\n            \r\n        # Call DFS to mark the cells where Arabian water flows.\r\n        for i in range(n): \r\n            self.dfs(-1, i, m-1, mat, arabian, n, m)\r\n        for i in range(m): \r\n            self.dfs(-1, n-1, i, mat, arabian, n, m)\r\n            \r\n        # Count the number of cells where both Indian and Arabian water flow.\r\n        ct  = 0\r\n        for i in range(n):\r\n            for j in range(m):\r\n                if indian[i][j] and arabian[i][j]:\r\n                    ct += 1\r\n        return ct",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "//User function Template for C#\n\nclass Solution\n{\n    //Function to perform depth-first search (DFS) \n    //to mark the cells that can be reached by water flow from a given cell\n    void dfs(List<List<int>> mat, List<List<bool>> vis, int i, int j, int n, int m)\n    {\n        //Base case: If we are outside the grid or if the cell is already visited, return\n        if (i < 0 || j < 0 || i >= n || j >= m || vis[i][j]) return;\n\n        //Mark the cell as visited\n        vis[i][j] = true;\n\n        //Recursive calls to check the neighboring cells and mark them if they can be reached\n        //by water flow from the current cell\n        \n        //Check the cell above\n        if (i > 0 && !vis[i - 1][j] && mat[i - 1][j] >= mat[i][j])\n        {\n            dfs(mat, vis, i - 1, j, n, m);\n        }\n\n        //Check the cell below\n        if (i < n - 1 && !vis[i + 1][j] && mat[i + 1][j] >= mat[i][j])\n        {\n            dfs(mat, vis, i + 1, j, n, m);\n        }\n\n        //Check the cell to the left\n        if (j > 0 && !vis[i][j - 1] && mat[i][j - 1] >= mat[i][j])\n        {\n            dfs(mat, vis, i, j - 1, n, m);\n        }\n\n        //Check the cell to the right\n        if (j < m - 1 && !vis[i][j + 1] && mat[i][j + 1] >= mat[i][j])\n        {\n            dfs(mat, vis, i, j + 1, n, m);\n        }\n    }\n\n    //Function to calculate the number of cells that can be reached by water flow from Indian and Arabian Ocean\n    public int water_flow(List<List<int>> mat, int N, int M)\n    {\n        //Create two 2D lists to track the cells that can be reached from Indian and Arabian Ocean\n        List<List<bool>> indian = new List<List<bool>>();\n        for (int i = 0; i < N; i++)\n        {\n            List<bool> row = new List<bool>();\n            for (int j = 0; j < M; j++)\n            {\n                row.Add(false);\n            }\n            indian.Add(row);\n        }\n\n        List<List<bool>> arabian = new List<List<bool>>();\n        for (int i = 0; i < N; i++)\n        {\n            List<bool> row = new List<bool>();\n            for (int j = 0; j < M; j++)\n            {\n                row.Add(false);\n            }\n            arabian.Add(row);\n        }\n\n        //Mark the cells that can be reached from the Indian Ocean by performing DFS\n        //starting from the first column of the grid\n        for (int i = 0; i < N; i++) dfs(mat, indian, i, 0, N, M);\n\n        //Mark the cells that can be reached from the Indian Ocean by performing DFS\n        //starting from the first row of the grid\n        for (int i = 0; i < M; i++) dfs(mat, indian, 0, i, N, M);\n\n        //Mark the cells that can be reached from the Arabian Ocean by performing DFS\n        //starting from the last column of the grid\n        for (int i = 0; i < N; i++) dfs(mat, arabian, i, M - 1, N, M);\n\n        //Mark the cells that can be reached from the Arabian Ocean by performing DFS\n        //starting from the last row of the grid\n        for (int i = 0; i < M; i++) dfs(mat, arabian, N - 1, i, N, M);\n\n        //Count the number of cells that can be reached from both oceans and return the count\n        int count = 0;\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < M; j++)\n            {\n                if (indian[i][j] && arabian[i][j])\n                {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n}",
                "lang_text": "csharp"
            }
        ],
        "platform": "GFG"
    }
}