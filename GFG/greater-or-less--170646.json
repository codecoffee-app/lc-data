{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 713594,
            "title": "Greater or Less",
            "titleSlug": "greater-or-less--170646",
            "content": "<p><span style=\"font-size:18px\">Given an array of&nbsp;integers of size N. For each&nbsp;<strong>ith</strong>&nbsp;element in the array, calculate the absolute difference between the count of numbers that are to the left of&nbsp;<strong>i</strong>&nbsp;and are strictly greater than&nbsp;<strong>ith</strong>&nbsp;element, and the count of numbers that are to the right of&nbsp;<strong>i</strong>&nbsp;and are strictly lesser than&nbsp;<strong>ith</strong>&nbsp;element.</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input</strong>:\r\nN = 5\r\nA[] = {5, 4, 3, 2, 1}\r\n<strong>Output:</strong>&nbsp;4 2 0 2 4&nbsp;\r\n<strong>Explanation</strong>: We can see that the \r\nrequired number for the \r\n1st element is |0-4| = 4\r\n</span></pre>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 2:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong>\r\nN = 5\r\nA[] = {1, 2, 3, 4, 5}\r\n<strong>Output:&nbsp;</strong>0 0 0 0 0\r\n<strong>Explanation</strong>: There is no greater \r\nelement on the left for any element \r\nand no lesser element on the right.</span></pre>\r\n\r\n<p><br />\r\n<span style=\"font-size:18px\"><strong>Your Task:&nbsp;&nbsp;</strong><br />\r\nYou don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>greaterLesser()</strong>&nbsp;which takes the array arr[], its size Nas input parameters&nbsp;and returns the required array.</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong> O(N log N)<br />\r\n<strong>Expected Auxiliary Space:</strong> O(N)</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-size:18px\"><strong>Constraints:</strong><br />\r\n1 &le;&nbsp;N &le; 10<sup>5</sup><br />\r\n-10<sup>9</sup><sup>&nbsp;</sup>&le;&nbsp;arr[i] &le; 10<sup>9</sup><br />\r\nArray can contain duplicate elements.&nbsp;</span></p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Use Segment trees.</span></p>",
            "<p><span style=\"font-size:18px\">The problem is basically an improvement on the inversion count concept.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Segment-Tree",
                "slug": "segment-tree"
            },
            {
                "name": "Advanced Data Structure",
                "slug": "advanced-data-structure"
            }
        ],
        "companies": [
            "makemytrip"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class Solution{   \npublic:\n    struct Seg_Tree{\n        vector<int> tree, arr;\n\t    int n;\n        public:\n\t    Seg_Tree(int _n, vector<int> _arr){\n\t        n = _n;\n\t\t    tree.resize(4 * n + 4);\n\t\t    arr = _arr;\n\t    }\n\n        // Function to build the segment tree\n        void build(int s, int e, int idx){\n            if(s == e){\n                tree[idx] = arr[s];\n                return ;\n            }\n\n            int mid = s + (e - s)/2;\n            build(s, mid , 2 * idx);\n            build(mid + 1, e, 2 * idx + 1);\n\n            tree[idx] = tree[2 * idx] + tree[2 * idx + 1];\n        }\n\n        // Function to update the segment tree\n        void update(int pos, int v, int s, int e, int idx){\n            if(pos < s || pos > e)\n                return ;\n\n            if(s == e){\n                tree[idx]++;\n                return ;\n            } \n\n            int mid = s + (e - s) / 2;\n            update(pos, v, s, mid, 2 * idx);\n            update(pos, v, mid + 1, e, 2 * idx + 1);\n\n            tree[idx] = (tree[2 * idx] + tree[2 * idx +1]);\n        }\n\n        // Function to update the segment tree\n        void update(int pos, int v){\n            update(pos, v, 1, n, 1);\n        }\n\n        // Function to query the segment tree\n        int query(int qs, int qe, int s, int e, int idx){\n            if(qs <= s && qe >= e)\n                return tree[idx];\n\n            if(qs > e || qe < s)\n                return 0;\n\n            int mid = s + (e - s)/2;\n            return query(qs, qe, s, mid, 2 * idx) + query(qs, qe, mid + 1, e, 2 * idx + 1);\n        }\n\n        // Function to query the segment tree\n        int query(int v){\n            return query(v + 1, n, 1, n, 1);\n        }\n    };\n\n    // Function to solve the problem\n    vector<int> solve(vector<int> arr, int n){\n        vector<int> A(n+1);\n        map<int,int>mp;\n        for(int i=0;i<n;i++)\n            mp[arr[i]]=0;\n        int c=0;\n        for(auto i:mp)\n            mp[i.first]=++c;\n        for(int i=1;i<=n;i++)\n            A[i]=mp[arr[i-1]];\n        vector<int> res;\n        Seg_Tree ob(n, arr);\n        for(int i = 1; i <= n; i++){\n            ob.update(A[i], 1);\n            res.push_back(ob.query(A[i]));\n        }\n        return res;\n    }\n    \n    \n    // Function to calculate the difference between greater and lesser values\n    vector<int> greaterLesser(vector<int>A, int N){\n        vector<int>left,right,ans;\n        left=solve(A,N);\n        vector<int>temp(N);\n        for(int i=0;i<N;i++)\n            temp[i]=-A[N-i-1];\n        right=solve(temp,N);\n        for(int i=0;i<N;i++)\n            ans.push_back(abs(left[i]-right[N-i-1]));\n        return ans;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "// Back-end complete function Template for Java\r\n\r\nclass Solution {\r\n    \r\n    public static int[] greaterLesser(int[] A, int N) {\r\n        // solving the problem by calling helper function\r\n        int[] left = solve(A, N);\r\n        \r\n        // creating a temporary array for storing the negation of elements in A\r\n        int[] temp = new int[N];\r\n        for (int i = 0; i < N; i++)\r\n            temp[i] = -A[N - i - 1];\r\n        \r\n        // solving the problem for the negated array\r\n        int[] right = solve(temp, N);\r\n        \r\n        // calculating the absolute difference between the left and right values \r\n        int[] ans = new int[N];\r\n        for (int i = 0; i < N; i++)\r\n            ans[i] = Math.abs(left[i + 1] - right[N - i]);\r\n        \r\n        // returning the result\r\n        return ans;\r\n\r\n    }\r\n\r\n    static int[] solve(int arr[], int n) {\r\n        // creating an array A of size n+1\r\n        int[] A = new int[n + 1];\r\n        \r\n        // creating a TreeMap for storing unique elements and their count\r\n        TreeMap<Integer, Integer> mp = new TreeMap<>();\r\n        for (int i = 0; i < n; i++)\r\n            mp.put(arr[i], 0);\r\n        \r\n        // assigning unique indices to the unique elements in the TreeMap\r\n        int c = 0;\r\n        for (Map.Entry<Integer, Integer> e : mp.entrySet())\r\n            mp.put(e.getKey(), ++c);\r\n        \r\n        // assigning the unique indices to the array A\r\n        for (int i = 1; i <= n; i++)\r\n            A[i] = mp.get(arr[i - 1]);\r\n        \r\n        // creating an array res of size n+1 and initializing a segment tree\r\n        int res[] = new int[n + 1];\r\n        Seg_Tree ob = new Seg_Tree(n, arr);\r\n        \r\n        // updating the segment tree and storing the results in the array res\r\n        for (int i = 1; i <= n; i++) {\r\n            ob.update(A[i], 1);\r\n            res[i] = ob.query(A[i]);\r\n        }\r\n        \r\n        // returning the result\r\n        return res;\r\n    }\r\n\r\n    static class Seg_Tree {\r\n        int tree[], arr[];\r\n        int n;\r\n\r\n        public Seg_Tree(int n, int arr[]) {\r\n            this.arr = arr;\r\n            this.n = n;\r\n            tree = new int[4 * n + 4];\r\n        }\r\n\r\n        // building the segment tree\r\n        void build(int s, int e, int idx) {\r\n            if (s == e) {\r\n                tree[idx] = arr[s];\r\n                return;\r\n            }\r\n\r\n            int mid = s + (e - s) / 2;\r\n            build(s, mid, 2 * idx);\r\n            build(mid + 1, e, 2 * idx + 1);\r\n\r\n            tree[idx] = tree[2 * idx] + tree[2 * idx + 1];\r\n        }\r\n\r\n        // updating the segment tree\r\n        void update(int pos, int v, int s, int e, int idx) {\r\n            if (pos < s || pos > e)\r\n                return;\r\n\r\n            if (s == e) {\r\n                tree[idx]++;\r\n                return;\r\n            }\r\n\r\n            int mid = s + (e - s) / 2;\r\n            update(pos, v, s, mid, 2 * idx);\r\n            update(pos, v, mid + 1, e, 2 * idx + 1);\r\n\r\n            tree[idx] = (tree[2 * idx] + tree[2 * idx + 1]);\r\n        }\r\n\r\n        void update(int pos, int v) {\r\n            update(pos, v, 1, n, 1);\r\n        }\r\n\r\n        // querying the segment tree\r\n        int query(int qs, int qe, int s, int e, int idx) {\r\n            if (qs <= s && qe >= e)\r\n                return tree[idx];\r\n\r\n            if (qs > e || qe < s)\r\n                return 0;\r\n\r\n            int mid = s + (e - s) / 2;\r\n            return query(qs, qe, s, mid, 2 * idx) + query(qs, qe, mid + 1, e, 2 * idx + 1);\r\n        }\r\n\r\n        int query(int v) {\r\n            return query(v + 1, n, 1, n, 1);\r\n        }\r\n    }\r\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "class Solution:\r\n    class Seg_Tree:\r\n        #Initializing the segment tree with the given size n and array arr.\r\n        def __init__(self, n, arr):\r\n            self.n = n\r\n            self.arr = arr\r\n            self.tree = [0] * (n*4 + 4)\r\n        \r\n        #Building the segment tree recursively.\r\n        def build(self, s, e, idx):\r\n            if(s == e):\r\n                self.tree[idx] = self.arr[s]\r\n                return\r\n            mid = s + (e - s)//2\r\n            self.build(s, mid , 2 * idx)\r\n            self.build(mid + 1, e, 2 * idx + 1)\r\n            self.tree[idx] = self.tree[2 * idx] + self.tree[2 * idx + 1]\r\n        \r\n        #Updating the segment tree for the given position pos.\r\n        def update(self, pos, v, s, e, idx):\r\n            if(pos < s or pos > e):\r\n                return\r\n            if(s == e):\r\n                self.tree[idx] += 1\r\n                return\r\n            mid = s + (e - s) // 2\r\n            self.update(pos, v, s, mid, 2 * idx)\r\n            self.update(pos, v, mid + 1, e, 2 * idx + 1)\r\n            self.tree[idx] = (self.tree[2 * idx] + self.tree[2 * idx +1])\r\n        \r\n        #Querying the segment tree for the given range [qs, qe].\r\n        def query(self, qs, qe, s, e, idx):\r\n            if(qs <= s and qe >= e):\r\n                return self.tree[idx]\r\n            if(qs > e or qe < s):\r\n                return 0\r\n            mid = s + (e - s) // 2\r\n            return self.query(qs, qe, s, mid, 2 * idx) + self.query(qs, qe, mid + 1, e, 2 * idx + 1)\r\n            \r\n    #Function to find the greaterLesser array.\r\n    def solve(self, arr, n):\r\n        #Initialize an array A and a dictionary mp.\r\n        A = [0]*(n+1)\r\n        mp = dict()\r\n\r\n        #Store unique elements of arr in mp and assign a corresponding number to each element.\r\n        for i in range(n):\r\n            mp[arr[i]] = 0\r\n        c = 0\r\n        for i in sorted(mp):\r\n            c += 1\r\n            mp[i] = c\r\n\r\n        #Convert arr into A by substituting each element with its corresponding number from mp.\r\n        for i in range(1,n+1):\r\n            A[i] = mp[arr[i-1]]\r\n\r\n        #Initialize an empty array res and create a segment tree object.\r\n        res = []\r\n        obj = self.Seg_Tree(n, arr)\r\n\r\n        #Iterate over each element in A and perform required operations on the segment tree.\r\n        for i in range(1,n+1):\r\n            obj.update(A[i], 1, 1, n, 1)\r\n            res.append(obj.query(A[i]+1, n, 1, n, 1))\r\n\r\n        #Return the resulting array res.\r\n        return res\r\n        \r\n    #Function to find the absolute difference between left and right arrays.\r\n    def greaterLesser (self, A, N):\r\n        #Create left and right arrays using the solve function.\r\n        left = []\r\n        right = []\r\n        ans = []\r\n        left=self.solve(A,N)\r\n        temp = []\r\n        for i in range(N):\r\n            temp.append(-A[N-i-1])\r\n        right=self.solve(temp,N)\r\n\r\n        #Take the absolute difference between corresponding elements of left and right arrays and store them in ans.\r\n        for i in range(N):\r\n            ans.append(abs(left[i]-right[N-i-1]))\r\n\r\n        #Return the resulting ans array.\r\n        return ans",
                "lang_text": "python3"
            }
        ],
        "platform": "GFG"
    }
}