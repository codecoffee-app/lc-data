{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 700592,
            "title": "Huffman Decoding",
            "titleSlug": "huffman-decoding",
            "content": "<p><span style=\"font-size: 18px;\">You are given an encoded binary string and a Huffman MinHeap tree, your task is to complete the function <strong>decodeHuffmanData</strong>(), which decodes the binary encoded string and returns the original string.&nbsp;<br /></span><span style=\"font-size: 18px;\"><strong>Note:</strong> Each node of the min heap contains 2 data members, a character, and an integer to denoting its frequency. The character '$' is the special character used for internal nodes whose min heap node only needs an integer field. The code in the chart is generated by the following rule:<br />- If we want to reach a node from the root then in the path, for right turn we use <strong>1</strong> and for left turn we use <strong>0</strong>.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Examples:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input : </strong>binaryString = 1111111111110001010101010100010010101010101\nMin Heap Tree =  \n\\t\\t    $(20)\n\\t\\t  /\\t\\\n\\t\\t/\\t    \\\n\\t   $(8)\\t\\t\\\n\\t /     \\\\t\\t \\\n    $(3)\\t\\\\t\\t$(12)\n    /  \\\\t \\\\t     /    \\\nB(1)    D(2)    E(5)    C(6)    A(6)</span>\n\n<span style=\"font-size: 18px;\"><strong>Output:</strong> AAAAAABCCCCCCDDEEEEE</span>\n<span style=\"font-size: 18px;\"><strong>Explanation:</strong>\nThe following chart can be made from the \ngiven min heap tree.\n<strong>character    frequency    code</strong>\n    A\\t\\t 6\\t  11     (because we have to move right 2 time to reach A from the root)\\t    \n    B\\t\\t 1\\t  000    \n    C\\t\\t 6\\t  10     (because we have to move right and then left to reach C from the root)\n    D\\t\\t 2\\t  001    \n    E\\t\\t 5\\t  01</span><br /><br /><span style=\"font-size: 18px;\">In the above given binaryString we replace <strong>11</strong> by <strong>A</strong> (6 times), <strong>000</strong> by <strong>B </strong>(1 time)<strong>, </strong><strong>10&nbsp;</strong>by <strong>C</strong> (6 times), <strong>001 </strong>&nbsp;by <strong>D&nbsp;</strong></span><span style=\"font-size: 18px;\">(2 times) </span><span style=\"font-size: 18px;\">and</span><strong style=\"font-size: 18px;\"> 01 </strong><span style=\"font-size: 18px;\">by</span><strong style=\"font-size: 18px;\"> E </strong><span style=\"font-size: 18px;\">(5 times)</span><strong style=\"font-size: 18px;\">.</strong><br /><br /><span style=\"font-size: 18px;\">Hence, the answer is&nbsp;</span><span style=\"font-size: 18px;\">AAAAAABCCCCCCDDEEEEE.</span></pre>\n<pre><span style=\"font-size: 18px;\"><strong>Input : </strong>binaryString = 01110100011111000101101011101000111\nMin Heap Tree =  \n\\t\\t\\t\\t $(13)\n\\t\\t\\t    /\\t  \\\n\\t\\t\\t  /\\t\\t\\\n\\t\\t\\t/\\t\\t    \\\n\\t\\t   $(5)\\t\\t\\t\\\n\\t\\t /\\t\\\\t\\t\\t\\\n\\t\\t/\\t  \\\\t\\t\\t \\\n\\t   $(3)\\t   \\\\t\\t\\t$(8)\n\\t  /    \\\\t   \\\\t\\t    /    \\\n     $(2)     \\\\t   \\\\t\\t$(4)     \\\n    /   \\\\t\\\\t   \\\\t    /   \\\\t\\\nf(1)    o(1)    r(1)    g(2)    k(2)    s(2)    e(4)</span>\n\n<span style=\"font-size: 18px;\"><strong>Output:</strong> geeksforgeeks</span>\n<span style=\"font-size: 18px;\"><strong>Explanation:</strong>\nThe following chart can be made from the \ngiven min heap tree.\n<strong>character    frequency    code</strong>\n    f\\t\\t 1\\t  0000\\t\\t     \n    o\\t\\t 1\\t  0001\n    r\\t\\t 1\\t  001\n    g\\t\\t 2\\t  01    \n    k\\t\\t 2\\t  100\n    s\\t\\t 2\\t  101\n    e\\t\\t 4\\t  11</span><br /><br /><span style=\"font-size: 18px;\">If we replace the binary numbers with the suitable characters, then we get&nbsp;</span><span style=\"font-size: 18px;\">geeksforgeeks as the output.</span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; length of input string &le; 10<sup>3</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "You are given an encoded binary string and a Huffman MinHeap tree. Your task is to decode the binary string using the provided Huffman tree and return the original string.\n\nEach node of the min-heap contains a character and its frequency. Internal nodes are represented by the special character '$' and only contain the frequency. The Huffman code for each character is determined by the path from the root to that character's node: '1' indicates a right turn, and '0' indicates a left turn.",
                "constraints": [
                    "1 <= length of input string <= 10^3"
                ],
                "testcases": [
                    {
                        "input": "binaryString = 1111111111110001010101010100010010101010101\nMin Heap Tree =\n          $(20)\n        /  \\\n       /    \\\n    $(8)       $(12)\n   /   \\     /    \\\n$(3)   (5) (6)  (6)\n    /  \\         \nB(1)  D(2) E(5) C(6) A(6)",
                        "output": "AAAAAABCCCCCCDDEEEEE",
                        "explanation": "The Huffman tree can be used to derive the following codes:\nA: 11\nB: 000\nC: 10\nD: 001\nE: 01\n\nReplacing the codes in the binary string yields the output: AAAAAABCCCCCCDDEEEEE."
                    },
                    {
                        "input": "binaryString = 01110100011111000101101011101000111\nMin Heap Tree =\n          $(13)\n        /   \\\n       /     \\\n    $(5)        $(8)\n   /   \\      /   \\\n$(3)   (1) (2) (4)\n  /  \\  (1) (1)   (1) (1)    (1)   (1)\n  (1)  (1) (1) (1)    (1)   (1)\nf(1)   o(1)    r(1)    g(2)    k(2)   s(2)   e(4)",
                        "output": "geeksforgeeks",
                        "explanation": "The Huffman tree can be used to derive the following codes:\nf: 0000\no: 0001\nr: 001\ng: 01\nk: 100\ns: 101\ne: 11\n\nReplacing the codes in the binary string yields the output: geeksforgeeks."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>To decode the binary encoded data using the Huffman tree: start at the root, traverse left for <code>0</code> and right for <code>1</code>, store the character when a leaf node is reached, and repeat from the root for the next set of bits.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Greedy",
                "slug": "greedy"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            },
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\n  public:\n    // Function to return the decoded string.\n    string decodeHuffmanData(struct MinHeapNode* root, string binaryString) {\n        string ans = \"\";\n        struct MinHeapNode* curr = root;\n\n        // iterating over the string.\n        for (int i = 0; i < binaryString.size(); i++) {\n            // if character is \"0\" then moving to left child of parent node\n            // else to the right child.\n            if (binaryString[i] == '0')\n                curr = curr->left;\n            else\n                curr = curr->right;\n\n            // if both the child of current node are null, we add the data\n            // at current node in our result and update current node.\n            if (curr->left == NULL and curr->right == NULL) {\n                ans += curr->data;\n                curr = root;\n            }\n        }\n        // returning the resultant string.\n        return ans + '\\0';\n    }\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\nclass Solution {\n    public String decodeHuffmanData(MinHeapNode root, String binaryString) {\n\n        String ans = \"\";\n        MinHeapNode curr = root;\n\n        // iterating over the string.\n        for (int i = 0; i < binaryString.length(); i++) {\n            // if character is \"0\" then moving to left child of parent node\n            // else to the right child.\n            if (binaryString.charAt(i) == '0')\n                curr = curr.left;\n            else\n                curr = curr.right;\n\n            // if both the child of current node are null, we add the data\n            // at current node in our result and update current node.\n            if (curr.left == null && curr.right == null) {\n                ans += curr.data;\n                curr = root;\n            }\n        }\n        // returning the resultant string.\n        return ans + '\\0';\n    }\n}",
                "lang_text": "java"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "// User function Template for javascript\n\n/**\n * @param {MinHeapNode} root\n * @param {string} binaryString\n * @return {string}\n */\n\nclass Solution {\n    decodeHuffmanData(root, binaryString) {\n        let ans = \"\";\n        let curr = root;\n\n        // iterating over the string.\n        for (let i = 0; i < binaryString.length; i++) {\n            // if character is \"0\" then moving to left child of parent node\n            // else to the right child.\n            if (binaryString[i] == '0')\n                curr = curr.left;\n            else\n                curr = curr.right;\n\n            // if both the child of current node are null, we add the data\n            // at current node in our result and update current node.\n            if (curr.left == null && curr.right == null) {\n                ans += curr.data;\n                curr = root;\n            }\n        }\n        // returning the resultant string.\n        return ans + '\\0';\n    }\n}",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}