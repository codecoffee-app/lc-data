{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 701345,
            "title": "Infix to Postfix",
            "titleSlug": "infix-to-postfix-1587115620",
            "content": "<p><span >Given an infix expression in the form of string <strong>s</strong>. Convert this infix expression to a postfix expression.</span></p>\n<ul>\n<li><span ><strong>Infix expression:</strong> The expression of the form a <strong>op</strong> b. When an operator is in between every pair of operands.</span></li>\n<li><span ><strong>Postfix expression:</strong> The expression of the form a b <strong>op</strong>. When an operator is followed for every pair of operands.</span></li>\n</ul>\n<p><span >Note:&nbsp;The order of precedence is: ^&nbsp;greater than&nbsp;*&nbsp;equals to&nbsp;/&nbsp;greater than&nbsp;+&nbsp;equals to&nbsp;-. Ignore the right associativity of&nbsp;<strong>^</strong>.</span></p>\n<p><span ><strong>Examples :</strong></span></p>\n<pre><span ><strong>Input</strong>: s = \"a+b*(c^d-e)^(f+g*h)-i\"\n<strong>Output</strong>: abcd^e-fgh*+^*+i-\n<strong>Explanation</strong>: After converting the infix expression into postfix expression, the resultant expression will be abcd^e-fgh*+^*+i-\n</span></pre>\n<pre><span ><strong>Input</strong>: s = \"A*(B+C)/D\"\n<strong>Output</strong>: ABC+*D/\n<strong>Explanation</strong>: After converting the infix expression into postfix expression, the resultant expression will be ABC+*D/<br /></span></pre>\n<pre><span ><strong>Input</strong>: s = \"(a+b)*(c+d)\"\n<strong>Output</strong>: ab+cd+*</span></pre>\n<p><span ><strong>Constraints:</strong><br />1 &le; s.length &le; 30</span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p>Use a <strong>stack</strong> to manage operators and parentheses, appending operands directly to the result, while respecting operator precedence and handling parentheses appropriately.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [
            "paytm",
            "vmware",
            "microsoft"
        ],
        "solutions": [
            {
                "lang": "C",
                "full_func": "#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 1000\n\n// Stack structure for characters\nstruct Stack {\n    int top;\n    unsigned capacity;\n    char* array;\n};\n\n// Function to create a stack of given capacity\nstruct Stack* createStack(unsigned capacity) {\n    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));\n    stack->capacity = capacity;\n    stack->top = -1;\n    stack->array = (char*)malloc(stack->capacity * sizeof(char));\n    return stack;\n}\n\n// Function to check if the stack is empty\nint isEmpty(struct Stack* stack) {\n    return stack->top == -1;\n}\n\n// Function to push an element onto the stack\nvoid push(struct Stack* stack, char c) {\n    stack->array[++stack->top] = c;\n}\n\n// Function to pop an element from the stack\nchar pop(struct Stack* stack) {\n    if (!isEmpty(stack)) {\n        return stack->array[stack->top--];\n    }\n    return '$'; // Return a sentinel value if the stack is empty\n}\n\n// Function to peek the top element of the stack\nchar peek(struct Stack* stack) {\n    return stack->array[stack->top];\n}\n\n// Function to get precedence of an operator\nint precedence(char c) {\n    if (c == '^')\n        return 3;\n    else if (c == '/' || c == '*')\n        return 2;\n    else if (c == '+' || c == '-')\n        return 1;\n    else\n        return -1;\n}\n\n// Function to check if the given character is an operand\nint isOperand(char c) {\n    return (isalpha(c) || isdigit(c));\n}\n\n// Function to convert infix expression to postfix expression\nchar* infixToPostfix(char* s) {\n    struct Stack* stack = createStack(MAX);\n    int i, k = 0;\n    char* result = (char*)malloc((strlen(s) + 1) * sizeof(char));\n\n    for (i = 0; s[i]; i++) {\n        char c = s[i];\n\n        // If the character is an operand, add it to output\n        if (isOperand(c)) {\n            result[k++] = c;\n        }\n        // If the character is '(', push it to the stack\n        else if (c == '(') {\n            push(stack, c);\n        }\n        // If the character is ')', pop until '(' is encountered\n        else if (c == ')') {\n            while (!isEmpty(stack) && peek(stack) != '(') {\n                result[k++] = pop(stack);\n            }\n            pop(stack); // Pop '('\n        }\n        // If an operator is encountered\n        else {\n            while (!isEmpty(stack) && precedence(c) <= precedence(peek(stack))) {\n                result[k++] = pop(stack);\n            }\n            push(stack, c);\n        }\n    }\n\n    // Pop all remaining operators from the stack\n    while (!isEmpty(stack)) {\n        result[k++] = pop(stack);\n    }\n\n    result[k] = '\\0'; // Null-terminate the result string\n    return result;\n}\n",
                "lang_text": "c"
            },
            {
                "lang": "C++",
                "full_func": "class Solution\n\n{\n  public:\n    int prec(char c) {\n        if (c == '^')\n            return 3;\n        else if (c == '/' || c == '*')\n            return 2;\n        else if (c == '+' || c == '-')\n            return 1;\n        else\n            return -1;\n    }\n\n    // The main function to convert infix expression\n\n    // Function to convert an infix expression to a postfix expression.\n    string infixToPostfix(string& s) {\n        stack<char> st; // For stack operations, we are using C++ built in stack\n        string result;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s[i];\n\n            // If the scanned character is\n            // an operand, add it to output string.\n            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||\n                (c >= '0' && c <= '9'))\n                result += c;\n\n            // If the scanned character is an\n            // \u00e2\u20ac\u02dc(\u00e2\u20ac\u02dc, push it to the stack.\n            else if (c == '(')\n                st.push('(');\n\n            // If the scanned character is an \u00e2\u20ac\u02dc)\u00e2\u20ac\u2122,\n            // pop and to output string from the stack\n            // until an \u00e2\u20ac\u02dc(\u00e2\u20ac\u02dc is encountered.\n            else if (c == ')') {\n                while (st.top() != '(') {\n                    result += st.top();\n                    st.pop();\n                }\n                st.pop();\n            }\n\n            // If an operator is scanned\n            else {\n                while (!st.empty() && prec(s[i]) <= prec(st.top())) {\n                    result += st.top();\n                    st.pop();\n                }\n                st.push(c);\n            }\n        }\n\n        // Pop all the remaining elements from the stack\n        while (!st.empty()) {\n            result += st.top();\n            st.pop();\n        }\n\n        return result;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution {\n\n    static int prec(char c) {\n        if (c == '^')\n            return 3;\n        else if (c == '/' || c == '*')\n            return 2;\n        else if (c == '+' || c == '-')\n            return 1;\n        else\n            return -1;\n    }\n\n    // The main function to convert infix expression\n\n    // Function to convert an infix expression to a postfix expression.\n    public static String infixToPostfix(String s) {\n        Stack<Character> st = new Stack<>(); // For stack operations, we are\n                                             // using C++ built in stack\n        String result = \"\";\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\n            // If the scanned character is\n            // an operand, add it to output string.\n            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||\n                (c >= '0' && c <= '9'))\n                result += c;\n\n            // If the scanned character is an\n            // \u00e2\u20ac\u02dc(\u00e2\u20ac\u02dc, push it to the stack.\n            else if (c == '(')\n                st.push('(');\n\n            // If the scanned character is an \u00e2\u20ac\u02dc)\u00e2\u20ac\u2122,\n            // pop and to output string from the stack\n            // until an \u00e2\u20ac\u02dc(\u00e2\u20ac\u02dc is encountered.\n            else if (c == ')') {\n                while (st.peek() != '(') {\n                    result += st.peek();\n                    st.pop();\n                }\n                st.pop();\n            }\n\n            // If an operator is scanned\n            else {\n                while (!st.empty() && prec(s.charAt(i)) <= prec(st.peek())) {\n                    result += st.peek();\n                    st.pop();\n                }\n                st.push(c);\n            }\n        }\n\n        // Pop all the remaining elements from the stack\n        while (!st.empty()) {\n            result += st.peek();\n            st.pop();\n        }\n\n        return result;\n    }\n}\n",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "class Solution:\n\n    # Function to return precedence of operators\n    def precedence(self, c):\n        if c == '^':\n            return 3\n        elif c == '/' or c == '*':\n            return 2\n        elif c == '+' or c == '-':\n            return 1\n        else:\n            return -1\n\n    # Function to convert an infix expression to a postfix expression\n    def InfixtoPostfix(self, s):\n        stack = []  # Stack to hold operators\n        result = \"\"  # Result to hold the postfix expression\n\n        for char in s:\n            # If the character is an operand, add it to the result\n            if char.isalnum():\n                result += char\n\n            # If the character is '(', push it to the stack\n            elif char == '(':\n                stack.append(char)\n\n            # If the character is ')', pop from stack until '(' is found\n            elif char == ')':\n                while stack and stack[-1] != '(':\n                    result += stack.pop()\n                stack.pop()  # Remove '(' from the stack\n\n            # If the character is an operator\n            else:\n                while stack and self.precedence(char) <= self.precedence(\n                        stack[-1]):\n                    result += stack.pop()\n                stack.append(char)\n\n        # Pop all the remaining operators from the stack\n        while stack:\n            result += stack.pop()\n\n        return result\n",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "class Solution\n    {\n        // Function to get precedence of\n        // operators in mathematical expression        \n        static int Prec(char ch)\n        {\n            switch (ch)\n            {\n                case '+':\n                case '-':\n                    return 1;\n\n                case '*':\n                case '/':\n                    return 2;\n\n                case '^':\n                    return 3;\n            }\n            return -1;\n        }\n\n        // The method that converts the infix expression\n        // to postfix expression\n        public string infixToPostfix(string exp)\n        {\n            // initializing empty string for result\n            string result = \"\";\n\n            // initializing empty stack\n            Stack<char> stack = new Stack<char>();\n\n            for (int i = 0; i < exp.Length; ++i)\n            {\n                char c = exp[i];\n\n                // If the scanned character is an operand, add it to output.\n                if (char.IsLetterOrDigit(c))\n                    result += c;\n\n                // If the scanned character is an '(', push it to the stack.\n                else if (c == '(')\n                    stack.Push(c);\n\n                // If the scanned character is an ')', pop and output from the stack\n                // until an '(' is encountered.\n                else if (c == ')')\n                {\n                    while (stack.Count > 0 && stack.Peek() != '(')\n                    {\n                        result += stack.Pop();\n                    }\n\n                    if (stack.Count > 0 && stack.Peek() != '(')\n                        return \"Invalid Expression\"; // invalid expression\n                    else\n                        stack.Pop();\n                }\n                else // an operator is encountered\n                {\n                    while (stack.Count > 0 && Prec(c) <= Prec(stack.Peek()))\n                    {\n                        result += stack.Pop();\n                    }\n                    stack.Push(c);\n                }\n\n            }\n\n            // pop all the operators from the stack\n            while (stack.Count > 0)\n            {\n                result += stack.Pop();\n            }\n\n            return result;\n        }\n    }",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "\r\n\r\nclass Solution{\r\n    \r\n    prec(c) {\r\n        if(c == '^')\r\n            return 3;\r\n        else if(c == '/' || c=='*')\r\n            return 2;\r\n        else if(c == '+' || c == '-')\r\n            return 1;\r\n        else\r\n            return -1;\r\n    }\r\n    \r\n    \r\n    infixToPostfix(s)\r\n    {\r\n        let st = []; //For stack operations, we are using JavaScript built in stack\r\n        let result = \"\";\r\n  \r\n        for(let i = 0; i < s.length; i++) {\r\n            let c = s[i];\r\n  \r\n            // If the scanned character is\r\n            // an operand, add it to output string.\r\n            if((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))\r\n                result += c;\r\n  \r\n            // If the scanned character is an\r\n            // \u00e2\u20ac\u02dc(\u00e2\u20ac\u02dc, push it to the stack.\r\n            else if(c == '(')\r\n                st.push('(');\r\n  \r\n            // If the scanned character is an \u00e2\u20ac\u02dc)\u00e2\u20ac\u2122,\r\n            // pop and to output string from the stack\r\n            // until an \u00e2\u20ac\u02dc(\u00e2\u20ac\u02dc is encountered.\r\n            else if(c == ')') {\r\n                while(st[st.length - 1] != '(')\r\n                {\r\n                    result += st[st.length - 1];\r\n                    st.pop();\r\n                }\r\n                st.pop();\r\n            }\r\n  \r\n            //If an operator is scanned\r\n            else {\r\n                while(st.length !== 0 && this.prec(s[i]) <= this.prec(st[st.length - 1])) {\r\n                    result += st[st.length - 1];\r\n                    st.pop(); \r\n                }\r\n                st.push(c);\r\n            }\r\n        }\r\n  \r\n        // Pop all the remaining elements from the stack\r\n        while(st.length !== 0) {\r\n            result += st[st.length - 1];\r\n            st.pop();\r\n        }\r\n  \r\n        return result;\r\n        \r\n    }\r\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}