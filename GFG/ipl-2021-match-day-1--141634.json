{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 707041,
            "title": "IPL 2021 - Match Day 1",
            "titleSlug": "ipl-2021-match-day-1--141634",
            "content": "<p><span style=\"font-size:18px\">Due to the rise of covid-19 cases in India, this year BCCI decided to organize knock-out matches in IPL rather than a league. </span></p>\r\n\r\n<p><span style=\"font-size:18px\">Today is matchday 1 and it is between previous year winners Mumbai Indians and the city of Joy - Kolkata Knight Riders. Eoin Morgan the new captain of the team KKR, thinks that death overs are very important to win a match. He decided to end MI&#39;s innings with his most trusted bowler Pat Cummins to minimize the target. There must be at least 4 players inside the 30-yard circle in death overs. Positions of 3 players are already decided which are given as 2-D integer points <strong>A</strong>, <strong>B</strong>, and <strong>C</strong>,&nbsp; the task is to find the missing point <strong>D</strong> such that <strong>ABCD</strong> should be a parallelogram. If there are multiple such points, find the lexicographically smallest coordinate.</span><br />\r\n&nbsp;</p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong>\r\nA = (3, 2)\r\nB = (3, 4)\r\nc = (2, 2)\r\n<strong>Output:\r\n</strong>2.000000 0.000000\r\n<strong>Explanation</strong>: There are two options for \r\npoint D : (2, 4) and (2, 0) such that ABCD \r\nforms a parallelogram. Since (2, 0) is \r\nlexicographically smaller than (2, 4). Hence,\r\n(2, 0) is the answer.</span>\r\n</pre>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Your Task:</strong><br />\r\nYou don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>findPoint()&nbsp;</strong>which takes three lists of integers <strong>A[]</strong>, <strong>B[] </strong>and <strong>C[]</strong> and return <strong>D[]</strong> list of two numbers with a precision of 6 decimal places where first element of <strong>D[ ] </strong>denote x coordinate and second&nbsp;element of <strong>D[ ] </strong>denote y&nbsp;coordinate.</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Constraints:</strong><br />\r\n1 &le; x, y &le; 1000, where x and y denote coordinates of points A, B, and C.<br />\r\nThe order of points in the parallelogram doesnt matter.<br />\r\nThe given points are not collinear.</span></p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given three distinct points A, B, and C on a 2D plane, find the fourth point D such that ABCD forms a parallelogram. The points A, B, and C are provided as coordinates. If multiple points D exist that satisfy the condition, return the lexicographically smallest coordinate. It is guaranteed that the given points are not collinear.",
                "constraints": [
                    "1 <= x, y <= 1000, where x and y denote the coordinates of points A, B, and C.",
                    "The order of points in the parallelogram doesn't matter.",
                    "The given points are not collinear."
                ],
                "testcases": [
                    {
                        "input": "A = (3, 2)\nB = (3, 4)\nC = (2, 2)",
                        "output": "2.000000 0.000000",
                        "explanation": "There are two possible points for D that form a parallelogram with A, B, and C: (2, 4) and (2, 0). Since (2, 0) is lexicographically smaller than (2, 4), the answer is (2, 0)."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">As we&rsquo;re given three points of the parallelogram A, B&nbsp;and C, we can find the slope of the missing sides as well as their lengths.<br />\nThe algorithm can be explained as follows:<br />\nLet D&nbsp;be the missing point. Now from definition, we have</span></p>\n\n<ul>\n\t<li><span style=\"font-size:18px\">Length of AC&nbsp;= Length of BD&nbsp;= L1 (Opposite sides are equal)</span></li>\n\t<li><span style=\"font-size:18px\">Slope of AC = Slope of BD = M1 (Opposite sides are parallel)</span></li>\n\t<li><span style=\"font-size:18px\">Length of AB = Length of CD = L2 (Opposite sides are equal)</span></li>\n\t<li><span style=\"font-size:18px\">Slope of AB = Slope of CD = M2 (Opposite sides are parallel)</span></li>\n</ul>\n\n<p><span style=\"font-size:18px\">Thus we can find the points at a distance L1 from A&nbsp;having slope M1.<br />\nNow we can check which point is lexicographically smallest among all possibilities.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Mathematical",
                "slug": "mathematical"
            },
            {
                "name": "Geometric",
                "slug": "geometric"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "//Structure to represent a point with x and y coordinates\nstruct Point {\n    double x, y;\n    Point()\n    {\n        x = y = 0;\n    }\n    Point(double a, double b)\n    {\n        x = a, y = b;\n    }\n};\n\nclass Solution{\n    public:\n     \n    //Function to find two points on a line given a starting point, slope, and distance\n    pair<Point, Point> findPoints(Point source,\n                                  double m, double l)\n    {\n        Point a, b;\n        //Case when slope is 0\n        if (m == 0) {\n            a.x = source.x + l;\n            a.y = source.y;\n     \n            b.x = source.x - l;\n            b.y = source.y;\n        }\n        //Case when slope is infinity (vertical line)\n        else if (m == std::numeric_limits<float>::max()) {\n            a.x = source.x;\n            a.y = source.y + l;\n     \n            b.x = source.x;\n            b.y = source.y - l;\n        }\n        //General case\n        else {\n            double dx = (l / sqrt(1 + (m * m)));\n            double dy = m * dx;\n            a.x = source.x + dx, a.y = source.y + dy;\n            b.x = source.x - dx, b.y = source.y - dy;\n        }\n     \n        return pair<Point, Point>(a, b);\n    }\n    \n    //Function to find slope between two points\n    double findSlope(Point p, Point q)\n    {\n        if (p.y == q.y)\n            return 0;\n        if (p.x == q.x)\n            return std::numeric_limits<float>::max();\n        return (q.y - p.y) / (q.x - p.x);\n    }\n    \n    //Function to find distance between two points\n    double findDistance(Point p, Point q)\n    {\n        return sqrt(pow((q.x - p.x), 2) + pow((q.y - p.y), 2));\n    }\n    \n    //Function to find the missing point given three points\n    pair<double,double > findMissingPoint(Point a, Point b, Point c)\n    {\n        pair <double ,double> ans;\n        pair<Point, Point> d = findPoints(a, findSlope(b, c),findDistance(b, c));\n        //Check if the distance between the missing point and c is equal to the distance between a and b\n        if (findDistance(d.first, c) == findDistance(a, b))\n        \tans.first=d.first.x,ans.second=d.first.y;\n        //Otherwise, the missing point is the other point from the pair\n        else\n        \tans.first=d.second.x,ans.second=d.second.y;\n        return ans;\n    }\n    \n    //Main function to find the missing points given three sets of coordinates\n    vector<double> findPoint(int A[], int B[], int C[])\n    {\n        vector <pair<double,double> >ans;\n        Point a = Point(A[0],A[1]);\n        Point b = Point(B[0],B[1]);\n        Point c = Point(C[0],C[1]);\n        //Find the missing point using each set of two points\n        ans.push_back(findMissingPoint(a,b,c));\n        ans.push_back(findMissingPoint(a,c,b));\n        ans.push_back(findMissingPoint(b,a,c));\n        ans.push_back(findMissingPoint(b,c,a));\n        ans.push_back(findMissingPoint(c,a,b));\n        ans.push_back(findMissingPoint(c,b,a));\n        \n        //Sort the points lexicographically and return the first point\n\t\tsort(ans.begin(),ans.end());\n\t\treturn {ans[0].first,ans[0].second};\n    } \n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n    public class Point {\n        double x,y;\n        Point(double x,double y){\n            this.x=x;this.y=y;\n        }\n    }\n    public class CustomSort implements Comparator<Point>{\n        public int compare(Point a, Point b){\n            if(a.x<b.x)\n                return -1;\n            else if(a.x>b.x)\n                return 1;\n            else\n            {\n                if(a.y<b.y)\n                    return -1;\n                else return 1;\n            }\n        }\n    }\n    // method to calculate the distance between two points\n    public double dis(Point a, Point b){\n        double ans=Math.pow(a.x-b.x,2)+Math.pow(a.y-b.y,2);\n        return Math.sqrt(ans);\n    }\n    // method to calculate the slope between two points\n    public double slope(Point a, Point b){\n        if(a.x==b.x)\n            return Double.MAX_VALUE;\n        double ans=(a.y-b.y)/(a.x-b.x);\n        return ans;\n    }\n    // method to find the missing point given two other points\n    public Point findMissingPoint(Point A, Point B, Point C){\n        double dis = dis(B,C);\n        double m = slope(B,C);\n        Point a1=new Point(0.0d,0.0d);\n        Point a2=new Point(0.0d,0.0d); \n        if(m==Double.MAX_VALUE)\n        {\n            a1.x=A.x; a1.y=A.y+dis;\n            a2.x=A.x; a2.y=A.y-dis;\n        }\n        else\n        {\n            a1.x=A.x+(dis/Math.sqrt(1+(m*m)));\n            a2.x=A.x-(dis/Math.sqrt(1+(m*m)));\n            a1.y=m*(a1.x-A.x)+A.y;\n            a2.y=m*(a2.x-A.x)+A.y;\n        }\n        if(dis(C,a1)==dis(A,B))\n            return a1;\n        else\n            return a2;\n    }\n    // main method to find the missing point in a triangle\n    public double[] findPoint(int[]A,int[]B,int[]C){\n        ArrayList<Point>l1=new ArrayList<>();\n        Point a=new Point((double)A[0],(double)A[1]);\n        Point b=new Point((double)B[0],(double)B[1]);\n        Point c=new Point((double)C[0],(double)C[1]);\n        l1.add(findMissingPoint(a,b,c));\n        l1.add(findMissingPoint(a,c,b));\n        l1.add(findMissingPoint(b,a,c));\n        l1.add(findMissingPoint(b,c,a));\n        l1.add(findMissingPoint(c,a,b));\n        l1.add(findMissingPoint(c,b,a));\n        // sorting the points in ascending order\n        Collections.sort(l1,new CustomSort());\n        double[] ans={l1.get(0).x,l1.get(0).y};\n        return ans;\n    }\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for python3\n\nimport math\n\nclass Solution:\n    #Function to find the two points on the line segment.\n    def findPoints(self, source, m, l):\n        a = [0]*2\n        b = [0]*2\n        \n        #If slope is 0, then move l units on the x-axis in both directions.\n        if (m == 0):\n            a[0] = source[0] + l\n            a[1] = source[1]\n            \n            b[0] = source[0] - l\n            b[1] = source[1]\n        \n        #If slope is infinity, then move l units on the y-axis in both directions.\n        elif (m == float(\"inf\")):\n            a[0] = source[0]\n            a[1] = source[1] + l\n            \n            b[0] = source[0]\n            b[1] = source[1] - l\n        \n        #For other slopes, calculate the change in x and y coordinates\n        #using the slope and l.\n        else:\n            dx = (l / math.sqrt(1 + (m * m)))\n            dy = m * dx\n            a[0] = source[0] + dx\n            a[1] = source[1] + dy\n            b[0] = source[0] - dx\n            b[1] = source[1] - dy\n        \n        return [a, b]\n    \n    #Function to find the slope of a line given two points on the line.\n    def findSlope(self, p, q):\n        #If y-coordinates are equal, the line is horizontal.\n        if (p[1] == q[1]):\n            return 0\n        #If x-coordinates are equal, the line is vertical.\n        if (p[0] == q[0]):\n            return float(\"inf\")\n        #Otherwise, calculate the slope using the formula.\n        return (q[1] - p[1]) / (q[0] - p[0])\n    \n    #Function to find the distance between two points using the distance formula.\n    def findDistance(self, p, q):\n        return math.sqrt(math.pow((q[0] - p[0]), 2) + pow((q[1] - p[1]), 2))\n    \n    #Function to find the missing point on the line segment.\n    def findMissingPoint(self, a, b, c):\n        ans = [0]*2\n        d = self.findPoints(a, self.findSlope(b, c), self.findDistance(b, c))\n        #Check if the distance between d and c is equal to the distance between a and b.\n        if (self.findDistance(d[0], c) == self.findDistance(a, b)):\n            ans[0] = d[0][0]\n            ans[1] = d[0][1]\n        else:\n            ans[0] = d[1][0]\n            ans[1] = d[1][1]\n        return ans\n    \n    #Function to find the point that is closest to the origin.\n    def findPoint(self, A, B, C):\n        ans = []\n        #Find the missing point for each combination of points.\n        ans.append(self.findMissingPoint(A, B, C));\n        ans.append(self.findMissingPoint(A, C, B));\n        ans.append(self.findMissingPoint(B, A, C));\n        ans.append(self.findMissingPoint(B, C, A));\n        ans.append(self.findMissingPoint(C, B, A));\n        ans.append(self.findMissingPoint(C, A, B));\n        #Sort the points and return the first (closest to the origin).\n        ans.sort()\n        return ans[0]",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "\nclass Solution{\n  findPoint(A, B, C) {\n    const a = {x: A[0], y: A[1]};\n    const b = {x: B[0], y: B[1]};\n    const c = {x: C[0], y: C[1]};\n\n    const missingPoints = [\n      this.findMissingPoint(a, b, c),\n      this.findMissingPoint(a, c, b),\n      this.findMissingPoint(b, a, c),\n      this.findMissingPoint(b, c, a),\n      this.findMissingPoint(c, a, b),\n      this.findMissingPoint(c, b, a)\n    ];\n\n    missingPoints.sort((p1, p2) => {\n      if (p1.x === p2.x) {\n        return p1.y - p2.y;\n      } else {\n        return p1.x - p2.x;\n      }\n    });\n\n    const res = missingPoints[0];\n    return [res.x.toFixed(6), res.y.toFixed(6)];\n  }\n\n  findMissingPoint(a, b, c) {\n    const slope = this.findSlope(b, c);\n    const distance = this.findDistance(b, c);\n    const missingPoints = this.findPoints(a, slope, distance);\n\n    if (this.findDistance(missingPoints.first, c) === this.findDistance(a, b)) {\n      return missingPoints.first;\n    } else {\n      return missingPoints.second;\n    }\n  }\n\n  findPoints(source, m, l) {\n    const a = {x: 0, y: 0}, b = {x: 0, y: 0};\n\n    if (m === 0) {\n      a.x = source.x + l;\n      a.y = source.y;\n      b.x = source.x - l;\n      b.y = source.y;\n    } else if (m === Number.POSITIVE_INFINITY) {\n      a.x = source.x;\n      a.y = source.y + l;\n      b.x = source.x;\n      b.y = source.y - l;\n    } else {\n      const dx = (l / Math.sqrt(1 + (m * m)));\n      const dy = m * dx;\n      a.x = source.x + dx;\n      a.y = source.y + dy;\n      b.x = source.x - dx;\n      b.y = source.y - dy;\n    }\n\n    return {first: a, second: b};\n  }\n\n  findSlope(p, q) {\n    if (p.y === q.y) {\n      return 0;\n    }\n    if (p.x === q.x) {\n      return Number.POSITIVE_INFINITY;\n    }\n    return (q.y - p.y) / (q.x - p.x);\n  }\n\n  findDistance(p, q) {\n    return Math.sqrt(Math.pow((q.x - p.x), 2) + Math.pow((q.y - p.y), 2));\n  }\n}",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}