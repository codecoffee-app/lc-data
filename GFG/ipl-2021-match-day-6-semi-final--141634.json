{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 707054,
            "title": "IPL 2021 - Match Day 6 - Semi Final",
            "titleSlug": "ipl-2021-match-day-6-semi-final--141634",
            "content": "<p><span style=\"font-size:18px\">IPL 2021 knockouts are over, teams MI, CSK, DC, and RCB are qualified for the semis. </span></p>\r\n\r\n<p><span style=\"font-size:18px\">Today is matchday 6 and it is between Delhi Capitals and Royal Challengers Banglore. Glenn Maxwell of RCB playing flawlessly. Rishabh Pant, the new captain of the team who is also a wicket-keeper wants to send a message to the bowler. But, he can&#39;t&nbsp;shout message directly as a batsman can hear. So, he decided to encrypt the message by putting &#39;*&#39;s in the message. And this is how the bowler decrypts the message. Bowler iterates over the message string from left to right, if he finds a <strong>&#39;*&#39;</strong>, he removes it and adds all the letters read so far to the message. He keeps on doing this till he gets rid of all the <strong>&#39;*&#39;</strong>. Given a decrypted message in the form of the string, the task is to find the encrypted</span> <span style=\"font-size:18px\">message</span>.</p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Note:</strong> If the string can be encrypted in multiple ways, find&nbsp;the encrypted string of smallest length.</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong> s = &quot;ababcababcd&quot;\r\n<strong>Output:</strong> ab*c*d\r\n<strong>Explanation: </strong>We can encrypt the string \r\nin following way : &quot;ababcababcd&quot;&nbsp;-&gt; \r\n&quot;ababc*d&quot; -&gt; &quot;ab*c*d&quot;</span>\r\n</pre>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 2:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input: </strong>s = &quot;zzzzzzz&quot;\r\n<strong>Output:</strong> z*z*z\r\n<strong>Explanation: </strong>The string can be encrypted \r\nin 2 ways: &quot;z*z*z&quot; and &quot;z**zzz&quot;. Out of \r\nthe two &quot;z*z*z&quot; is smaller in length.</span></pre>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Your Task:&nbsp;</strong><br />\r\nYou don&#39;t need to read input or print anything. Complete the function <strong>compress()</strong> which takes the message string <strong>s</strong> as input parameter and returns the shortest possible encrypted&nbsp;string.</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Constraints:&nbsp;</strong><br />\r\n1 &le; |s| &le; 10<sup>5</sup></span></p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Rishabh Pant, the captain and wicket-keeper, needs to send an encrypted message to the bowler during the IPL match between Delhi Capitals and Royal Challengers Bangalore. He encrypts the message by inserting '*' characters. The bowler decrypts it by iterating through the encrypted message. Whenever a '*' is encountered, it's removed, and all characters read so far are appended to the decrypted message. Given a decrypted message (string), the task is to find the shortest possible encrypted message.",
                "constraints": [
                    "1 <= |s| <= 10^5"
                ],
                "testcases": [
                    {
                        "input": "ababcababcd",
                        "output": "ab*c*d",
                        "explanation": "The original string can be encrypted in the following way : \"ababcababcd\" -> \"ababc*d\" -> \"ab*c*d\""
                    },
                    {
                        "input": "zzzzzzz",
                        "output": "z*z*z",
                        "explanation": "The string can be encrypted in 2 ways: \"z*z*z\" and \"z**zzz\". Out of the two \"z*z*z\" is smaller in length."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Find the longest proper prefix which is also a proper suffix for each prefix of the string.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\r\n\r\nclass Solution{\r\n    \r\n    private:\r\n    void fill_array(string s, int a[])\r\n    {\r\n        a[0] = 0;\r\n        for(int i=1 ; i<s.size() ; i++)\r\n        {\r\n            int series = a[i-1];\r\n            while(series)\r\n            {\r\n                if( s[series] == s[i] )\r\n                {\r\n                    a[i] = series+1;\r\n                    break;\r\n                }\r\n                series = a[series-1];\r\n            }\r\n            if(!series)\r\n                a[i] = ( s[i] == s[0] );\r\n        }\r\n    }\r\n    \r\n    public:\r\n    string compress(string s)\r\n    {\r\n        int a[(int)s.size()];\r\n        // ith element of array a stores the length of longest\r\n        // proper suffix which is also a proper prefix\r\n        // for substr s[0] to s[i]\r\n        fill_array( s, a );\r\n        \r\n        stack <char> shortened;\r\n        \r\n        for(int i=s.size()-1 ; i>0 ; i--)\r\n        // we start checking string from last index\r\n        {\r\n            if(i%2==0) { shortened.push(s[i]); continue; }\r\n            // for even index, string length is odd\r\n            // hence it cannot be divided into two\r\n            // so we simply push ith character in stack\r\n            \r\n            bool star_here=0;\r\n            // star_here will be made TRUE if substring s[0] to s[i]\r\n            // can be divided into identical halves\r\n            int suffix = a[i];\r\n            int substrlen = i+1;\r\n            // suffix and substring length are also meant for\r\n            // substring s[0] to s[i]\r\n            \r\n            if(suffix*2 >= substrlen)\r\n                if( substrlen % (substrlen-suffix) == 0 )\r\n                    if( ( substrlen / (substrlen-suffix) ) % 2 == 0 )\r\n                    // these conditions, if true, imply that, substring\r\n                    // can be divided into 2 identical halves\r\n                        star_here = 1;\r\n            \r\n            if(star_here)\r\n                { shortened.push('*'); i = i/2 + 1; }\r\n                // adding * to stack and moving index as required\r\n            else\r\n                shortened.push(s[i]);\r\n                // else, simply adding character to stack\r\n        }\r\n        \r\n        string ret;\r\n        ret.push_back( s[0] );\r\n        \r\n        while( !shortened.empty() )\r\n        {\r\n            // since we analysed input string from end to start\r\n            // removing elements from stack and pushing back to\r\n            // output string will reverse them back to required order\r\n            ret.push_back( shortened.top() );\r\n            shortened.pop();\r\n        }\r\n        \r\n        return ret;\r\n    }\r\n      \r\n};\r\n",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\r\n\r\nclass Solution {\r\n\tvoid fillArray(String s, int[] a) {\r\n\t\ta[0] = 0;\r\n\t\tfor (int i = 1; i<s.length(); i++) {\r\n\t\t\tint series = a[i - 1];\r\n\t\t\twhile (series > 0) {\r\n\t\t\t\tif (s.charAt(series) == s.charAt(i)) {\r\n\t\t\t\t\ta[i] = series + 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tseries = a[series - 1];\r\n\t\t\t}\r\n\t\t\tif (series == 0) {\r\n\t\t\t\tif (s.charAt(i) == s.charAt(0))\r\n\t\t\t\t\ta[i] = 1;\r\n\t\t\t\telse\r\n\t\t\t\t\ta[i] = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tpublic String compress(String s) {\r\n\t\tint[] a = new int[s.length()];\r\n\t\t\r\n\t\t// ith element of array a stores the length of longest\r\n        // proper suffix which is also a proper prefix\r\n        // for substr s[0] to s[i]\r\n\t\tfillArray(s, a);\r\n\r\n\t\tStack<Character> shortened = new Stack<Character>();\r\n\t\t\r\n        // for even index, string length is odd\r\n        // hence it cannot be divided into two\r\n        // so we simply push ith character in stack\r\n\t\tfor (int i = s.length() - 1; i > 0; i--) {\r\n\t\t\tif (i % 2 == 0) {\r\n\t\t\t\tshortened.push(s.charAt(i));\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n            // star_here will be made TRUE if substring s[0] to s[i]\r\n            // can be divided into identical halves\r\n\t\t\tboolean star_here = false;\r\n\t\t\t\r\n\t\t\t// suffix and substring length are also meant for\r\n            // substring s[0] to s[i]\r\n\t\t\tint suffix = a[i];\r\n\t\t\tint substrlen = i + 1;\r\n            \r\n            // these conditions, if true, imply that, substring\r\n            // can be divided into 2 identical halves\r\n\t\t\tif (suffix * 2 >= substrlen)\r\n\t\t\t\tif (substrlen % (substrlen - suffix) == 0)\r\n\t\t\t\t\tif ((substrlen / (substrlen - suffix)) % 2 == 0)\r\n\t\t\t\t\t\tstar_here = true;\r\n            \r\n            // adding * to stack and moving index as required\r\n\t\t\tif (star_here == true) {\r\n\t\t\t\tshortened.push('*');\r\n\t\t\t\ti = i / 2 + 1;\r\n\t\t\t} \r\n\t\t\t\r\n            // else, simply adding character to stack\r\n\t\t\telse\r\n\t\t\t\tshortened.push(s.charAt(i));\r\n\t\t}\r\n\r\n\t\tStringBuilder ret = new StringBuilder();\r\n\t\tret.append(s.charAt(0));\r\n\r\n        // since we analysed input string from end to start\r\n        // removing elements from stack and pushing back to\r\n        // output string will reverse them back to required order\r\n\t\twhile (!shortened.empty()) {\r\n\t\t\tret.append(shortened.peek());\r\n\t\t\tshortened.pop();\r\n\t\t}\r\n\r\n\t\treturn ret.toString();\r\n\t}\r\n}\r\n\r\n\r\n\r\n",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\r\n\r\nclass Solution:\r\n    def fillarray(self, s, a):\r\n        a[0]=0\r\n        for i in range(1,len(s)):\r\n            series=a[i-1]\r\n            while(series):\r\n                if(s[series]==s[i]):\r\n                    a[i]=series+1\r\n                    break\r\n                series=a[series-1]\r\n            if(series==0):\r\n                a[i]=(int(s[i]==s[0]))\r\n        return a\r\n        \r\n    def compress(self, s):\r\n        a=[0]*len(s)\r\n        \r\n        #  ith element of array a stores the length of longest\r\n        #  proper suffix which is also a proper prefix\r\n        #  for substr s[0] to s[i]\r\n        a = self.fillarray(s, a)\r\n        #print(a)\r\n        shortened=[]\r\n        n=len(s)\r\n        i=n-1\r\n        \r\n        #  for even index, string length is odd\r\n        #  hence it cannot be divided into two\r\n        #  so we simply push ith character in stack\r\n        while(i>0):\r\n            if(i%2==0):\r\n                shortened.append(s[i])\r\n                i=i-1\r\n                continue\r\n            \r\n            # star_here will be made TRUE if substring s[0] to s[i]\r\n            # can be divided into identical halves\r\n            star_here=False\r\n            \r\n            #  suffix and substring length are also meant for\r\n            #  substring s[0] to s[i]\r\n            suffix=a[i]\r\n            substrlen=i+1\r\n            \r\n            #  these conditions, if true, imply that, substring\r\n            #  can be divided into 2 identical halves\r\n            if(suffix*2>=substrlen):\r\n                if(substrlen%(substrlen-suffix)==0):\r\n                    if((substrlen/(substrlen-suffix))%2==0):\r\n                        star_here=True\r\n                        \r\n            \r\n            #  adding * to stack and moving index as required\r\n            if(star_here==True):\r\n                shortened.append('*')\r\n                i=(i//2)+1\r\n                \r\n            #  else, simply adding character to stack\r\n            else:\r\n                shortened.append(s[i])\r\n            i=i-1\r\n        ret=\"\"\r\n        ret=ret+s[0]\r\n        n=len(shortened)\r\n        \r\n        #  since we analysed input string from end to start\r\n        #  removing elements from stack and pushing back to\r\n        #  output string will reverse them back to required order\r\n        while(n):\r\n            ret=ret+shortened[n-1]\r\n            shortened.pop()\r\n            n=n-1\r\n        return ret\r\n    \r\n",
                "lang_text": "py"
            },
            {
                "lang": "Javascript",
                "full_func": "class Solution {\r\n\r\n\r\n    fillArray(s, a) {\r\n        a[0] = 0;\r\n        for (let i = 1; i<s.length; i++) {\r\n            let series = a[i - 1];\r\n            while (series > 0) {\r\n                if (s[series] == s[i]) {\r\n                    a[i] = series + 1;\r\n                    break;\r\n                }\r\n                series = a[series - 1];\r\n            }\r\n            if (series === 0) {\r\n                if (s[i] == s[0])\r\n                    a[i] = 1;\r\n                else\r\n                    a[i] = 0;\r\n            }\r\n        }\r\n    }\r\n    compress(s){\r\n        let a = new Array(s.length);\r\n        \r\n        // ith element of array a stores the length of longest\r\n        // proper suffix which is also a proper prefix\r\n        // for substr s[0] to s[i]\r\n        this.fillArray(s, a);\r\n\r\n        let shortened = [];\r\n        \r\n        // for even index, string length is odd\r\n        // hence it cannot be divided into two\r\n        // so we simply push ith character in stack\r\n        for (let i = s.length - 1; i > 0; i--) {\r\n            if (i % 2 === 0) {\r\n                shortened.push(s[i]);\r\n                continue;\r\n            }\r\n            // star_here will be made TRUE if substring s[0] to s[i]\r\n            // can be divided into identical halves\r\n            let star_here = false;\r\n            \r\n            // suffix and substring length are also meant for\r\n            // substring s[0] to s[i]\r\n            let suffix = a[i];\r\n            let substrlen = i + 1;\r\n            \r\n            // these conditions, if true, imply that, substring\r\n            // can be divided into 2 identical halves\r\n            if (suffix * 2 >= substrlen)\r\n                if (substrlen % (substrlen - suffix) === 0)\r\n                    if ((Math.floor(substrlen / (substrlen - suffix))) % 2 === 0)\r\n                        star_here = true;\r\n            \r\n            // adding * to stack and moving index as required\r\n            if (star_here === true) {\r\n                shortened.push('*');\r\n                i = Math.floor(i / 2) + 1;\r\n            } \r\n            \r\n            // else, simply adding character to stack\r\n            else\r\n                shortened.push(s[i]);\r\n        }\r\n\r\n        let ret = \"\";\r\n        ret+=s[0];\r\n\r\n        // since we analysed input string from end to start\r\n        // removing elements from stack and pushing back to\r\n        // output string will reverse them back to required order\r\n        while (shortened.length > 0) {\r\n            ret+=shortened[shortened.length-1];\r\n            shortened.pop();\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}