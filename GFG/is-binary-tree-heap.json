{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 700311,
            "title": "Is Binary Tree Heap",
            "titleSlug": "is-binary-tree-heap",
            "content": "<p><span >You are given a binary tree, and the task is to determine whether it satisfies the properties of a max-heap.</span></p>\n<p><span >A binary tree is considered a max-heap if it satisfies the following conditions:</span></p>\n<ol>\n<li><span ><strong>Completeness</strong>: Every level of the tree, except possibly the last, is completely filled, and all nodes are as far left as possible.</span></li>\n<li><span ><strong>Max-Heap Property</strong>: The value of each node is greater than or equal to the values of its children.</span></li>\n</ol>\n<p><span ><strong>Examples:</strong></span></p>\n<pre><span ><strong>Input:</strong> root[] = [97, 46, 37, 12, 3, 7, 31, 6, 9]\n<img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/881982/Web/Other/blobid0_1733648140.jpg\" width=\"300\" height=\"268\" /> <br /><strong>Output: </strong>true\n<strong>Explanation:</strong> The tree is complete and satisfies the max-heap property.\n</span></pre>\n<pre><span ><strong>Input:</strong> root[] = [97, 46, 37, 12, 3, 7, 31, N, 2, 4] <br /><img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/881982/Web/Other/blobid1_1733648320.jpg\" width=\"300\" height=\"268\" /> <br /><strong>Output:</strong> false<br /><strong style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">Explanation:</strong><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\"> </span>The tree is not complete, hence it is not a max-heap.</span></pre>\n<pre><span ><strong>Input: </strong>root[] = [5, 2, 3]<strong><br /></strong> &nbsp;&nbsp;&nbsp;&nbsp; 5<br /> &nbsp;&nbsp;&nbsp;/  \\<br />&nbsp;&nbsp; 2    3<br /><strong>Output: </strong>true\n<strong>Explanation:</strong> The tree follows the max-heap <span class=\"hljs-keyword\" style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">property</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\"> because the root node (</span><span class=\"hljs-number\" style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">5</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">) </span><span class=\"hljs-built_in\" style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">is</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\"> greater than both </span><span class=\"hljs-keyword\" style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">of</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\"> its children (</span><span class=\"hljs-number\" style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">2</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\"> </span><span class=\"hljs-built_in\" style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">and</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\"> </span><span class=\"hljs-number\" style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">3</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">).</span></span></pre>\n<p><span ><strong>Constraints:</strong><br />1 &le; number of nodes &le; 10<sup>3</sup><br />1 &le; node-&gt;data &le;&nbsp;10<sup>3</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a binary tree represented as an array, determine if it satisfies the properties of a max-heap. A max-heap must be a complete binary tree where the value of each node is greater than or equal to the values of its children.",
                "constraints": [
                    "1 <= number of nodes <= 10^3",
                    "1 <= node->data <= 10^3"
                ],
                "testcases": [
                    {
                        "input": "[97, 46, 37, 12, 3, 7, 31, 6, 9]",
                        "output": "true",
                        "explanation": "The given array represents a complete binary tree that satisfies the max-heap property. Each node's value is greater than or equal to its children's values."
                    },
                    {
                        "input": "[97, 46, 37, 12, 3, 7, 31, null, 2, 4]",
                        "output": "false",
                        "explanation": "The given array represents an incomplete binary tree, as there's a 'null' value before the level is fully populated. Therefore, it cannot be a max-heap."
                    },
                    {
                        "input": "[5, 2, 3]",
                        "output": "true",
                        "explanation": "The given array represents a complete binary tree where the root (5) is greater than both of its children (2 and 3), satisfying the max-heap property."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size: 18px;\">First, check completeness using level order traversal, then verify heap property by comparing parent-child node values.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Binary Search Tree",
                "slug": "binary-search-tree"
            },
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Heap",
                "slug": "heap"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [
            "hike"
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "//Back-end Complete Function template for C++\n\nclass Solution {\n  public:\n    // Function to count the number of nodes in a binary tree\n    int countNodes(Node* root) {\n        if (root == NULL)\n            return (0);\n        return (1 + countNodes(root->left) + countNodes(root->right));\n    }\n\n    // Function to check if the binary tree is a valid heap\n    bool isValid(Node* tree, int level, int no) {\n        if (tree == NULL)\n            return true;\n        if (level >= no)\n            return false;\n        return isValid(tree->left, 2 * level + 1, no) and\n               isValid(tree->right, 2 * level + 2, no);\n    }\n\n    /* Function to get diameter of a binary tree */\n\n    // Function to check if each node in the binary tree satisfies the heap property\n    bool propHoldes(Node* root) {\n        if (!root->left and !root->right)\n            return true;\n        if (root->right == NULL)\n            return root->data > root->left->data;\n        else {\n            if (root->data >= root->left->data and root->data >= root->right->data)\n                return propHoldes(root->left) and propHoldes(root->right);\n            else\n                return false;\n        }\n    }\n\n    // Function to check if the binary tree is a valid heap\n    bool isHeap(Node* tree) {\n        if (tree == NULL)\n            return true;\n        int no_of_nodes = countNodes(tree);\n\n        // Check if tree is a valid heap and satisfies the heap property\n        if (isValid(tree, 0, no_of_nodes) and propHoldes(tree))\n            return true;\n        return false;\n    }\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "//Back-end Complete Function template for JAVA\n\nclass Solution {\n    // Function to count the number of nodes in the tree\n    int countNodes(Node root) {\n        if (root == null) return 0;\n        return (1 + countNodes(root.left) + countNodes(root.right));\n    }\n\n    // Function to check if the tree is valid based on level and number of nodes\n    boolean isValid(Node tree, int level, int no) {\n        if (tree == null) return true;\n        if (level >= no) return false;\n        return isValid(tree.left, 2 * level + 1, no) &&\n            isValid(tree.right, 2 * level + 2, no);\n    }\n\n    // Function to check if the heap property holds for every node\n    boolean propHoldes(Node root) {\n        if (root.left == null && root.right == null) return true;\n        if (root.right == null)\n            return root.data > root.left.data;\n        else {\n            if (root.data >= root.left.data && root.data >= root.right.data)\n                return propHoldes(root.left) && propHoldes(root.right);\n            else\n                return false;\n        }\n    }\n\n    // Function to check if the tree is a valid heap\n    boolean isHeap(Node tree) {\n        if (tree == null) return true;\n        int no_of_nodes = countNodes(tree);\n\n        if (isValid(tree, 0, no_of_nodes) == true && propHoldes(tree) == true)\n            return true;\n        return false;\n    }\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for python3\n\n\nclass Solution:\n\n    def size_bt(self, node):\n        if node is None:\n            return 0\n        else:\n            return (self.size_bt(node.left) + 1 + self.size_bt(node.right))\n\n    def isValid(self, root, level, n):\n        if root is None:\n            return True\n        if level >= n:\n            return False\n        return self.isValid(root.right, 2 * level + 2, n) and self.isValid(\n            root.left, 2 * level + 1, n)\n\n    def propHolder(self, root):\n        if not root.left and not root.right:\n            return True\n        if root.right is None:\n            return root.data > root.left.data\n        else:\n            if root.data >= root.left.data and root.data >= root.right.data:\n                return self.propHolder(root.left) and self.propHolder(\n                    root.right)\n            else:\n                return False\n\n    #Your Function Should return True/False or 1/0\n    def isHeap(self, root):\n        #Code Here\n        if root is None:\n            return True\n        noOfNodes = self.size_bt(root)\n        return self.isValid(root, 0, noOfNodes) and self.propHolder(root)\n",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "// User function Template for javascript\n\n/**\n * @param {Node} root\n * @returns {boolean}\n */\n\nclass Solution {\n    isHeap(root) {\n        if (root == null) return true;\n\n        // Helper function to check if the tree is complete\n        function isComplete(root) {\n            if (root == null) return true;\n\n            let queue = [];\n            let flag = false;\n\n            queue.push(root);\n\n            while (queue.length > 0) {\n                let node = queue.shift();\n\n                if (node.left) {\n                    // If flag is set, the tree is not complete\n                    if (flag) return false;\n\n                    queue.push(node.left);\n                } else {\n                    // If flag is unset, it means we have encountered a non-complete\n                    // node\n                    flag = true;\n                }\n\n                if (node.right) {\n                    // If flag is set, the tree is not complete\n                    if (flag) return false;\n\n                    queue.push(node.right);\n                } else {\n                    // If flag is unset, it means we have encountered a non-complete\n                    // node\n                    flag = true;\n                }\n            }\n\n            return true;\n        }\n\n        // Helper function to check if the heap property holds\n        function maxHeapProperty(root) {\n            if (root == null) return true;\n\n            let leftChild = root.left;\n            let rightChild = root.right;\n\n            if (leftChild && leftChild.data > root.data) return false;\n            if (rightChild && rightChild.data > root.data) return false;\n\n            return maxHeapProperty(leftChild) && maxHeapProperty(rightChild);\n        }\n\n        return isComplete(root) && maxHeapProperty(root);\n    }\n}",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}