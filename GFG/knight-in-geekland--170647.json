{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 714000,
            "title": "Knight in Geekland",
            "titleSlug": "knight-in-geekland--170647",
            "content": "<p><span style=\"font-size: 18px;\">Knight is at <strong>(start_x,start_y)</strong> in Geekland which is represented by an <strong>NxM</strong> 2D matrix.<br />Each cell in the matrix contains some points. In the ith step, the knight can collect all the points from all the cells that can be visited in exactly i steps without revisiting any cell.<br />Also, the knight has some magical powers that enable him to fetch coins from the future i.e. If the knight can collect y coins in the xth step he can fetch all the coins that he will collect in the (x + y)th step and if the knight can collect z coins in the (x + y)th step he can fetch all the coins that he will collect in the (x + y + z)th step and so on without increasing the step count i.e. knight will stay on xth step and will get all the coins of the future steps mentioned above((x + y)th step coins + (x + y+z)th steps + ...).</span></p>\n<p><span style=\"font-size: 18px;\"><strong>For example</strong>, If in 1st step knight can collect 1 point, then knight will also collect all the points which are at (1+1)th step i.e. 2 steps, and if knight can collect 3 points in (1+1)th step then knight will also collect all the points at (1+1+3)th step and so on. Hence being only at the first step knight can collect overall 1+3 = 4 points if there are no points available at (1+1+3)th step.</span></p>\n<p><span style=\"font-size: 18px;\">Find the minimum number of steps required to collect the maximum points.<br /><strong>Note:</strong> The <a href=\"https://en.wikipedia.org/wiki/Knight_(chess)#:~:text=Compared%20to%20other%20chess%20pieces,pieces%20to%20reach%20its%20destination.\">knight moves</a> exactly the same as the knight on a chess board. Please follow 0 indexing.</span></p>\n<p><span style=\"font-size: 18px;\">Example 1:</span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong>\nn = 9\nm = 10\nstart_x = 4, start_y = 5\narr =\n0 0 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 0\n0 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0\n0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 0 <span style=\"color: #ff0000;\"><strong>1</strong></span> <span style=\"color: #00ff00;\"><strong>2</strong></span> <span style=\"color: #ff0000;\"><strong>0</strong></span> 0 0 <span style=\"color: #00ff00;\"><strong>2</strong></span>\n0 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> <span style=\"color: #ff0000;\"><strong>0</strong></span> <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> <span style=\"color: #ff0000;\"><strong>0</strong></span> <span style=\"color: #00ff00;\"><strong>2</strong></span> 0\n0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #000000;\"><strong><span style=\"background-color: #ffff00;\">0</span></strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span>\n0 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> <span style=\"color: #ff0000;\"><strong>0</strong></span> <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> <span style=\"color: #ff0000;\"><strong>0</strong></span> <span style=\"color: #00ff00;\"><strong>2</strong></span> 0\n0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 0 <span style=\"color: #ff0000;\"><strong>0</strong></span> <span style=\"color: #00ff00;\"><strong>2</strong></span> <span style=\"color: #ff0000;\"><strong>0</strong></span> 0 0 <span style=\"color: #00ff00;\"><strong>2</strong></span>\n0 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0\n0 0 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 <span style=\"color: #00ff00;\"><strong>2</strong></span> 0 0\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> minimum knight have to take 1 steps to gain maximum points.\nInitially, the knight has 0 coins, he will take 1 step to collect 1 point (sum of cells denoted in red color).\nNow in the second step, he can collect points from all the cells colored green i.e. 64 points.\nBut with his magical power, at the 1st step, he can fetch points from the (1 + 1)th step. Therefore he can collect 1 + 64 coins at step 1 only. Hence answer is 1.</span>\n</pre>\n<p><span style=\"font-size: 18px;\">Example 2:</span></p>\n<pre><span style=\"font-size: 18px;\">Input:\nn = 3 \nm = 3\nstart_x = 2, start_y = 1\narr =\n7 6 8\n9 1 4\n6 2 8\nOutput:0\nExplanation:\nInitially, the knight has 2 points, or more formally we can say that at the 0th step knight has 2 points.\nIn the first step, he can collect points from cells (0, 0) and (0, 2) i.e. 15 points.\nIn the second step, he can collect points from cells (1, 0) and (1, 2) i.e. 13 coins.\nIn the third step, he can collect points from cells (2, 0) and (2, 2) i.e. 14 points.\nIn the fourth step, he can collect points from the cell (0, 1) i.e. 6 points.\nSo in each step, he can collect coins like -You can see in the below image  Knight can collect 15 coins in the 0th step only\n<img style=\"height: 430px; width: 500px;\" src=\"https://media.geeksforgeeks.org/img-practice/rect46213-1668840290.png\" alt=\"\" /></span>\n</pre>\n<p><span style=\"font-size: 18px;\"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function knightInGeekland() which takes 2-d array <strong>arr[][],</strong>&nbsp;starting coordinates of knight <strong>start_x, and start_y&nbsp;</strong>as input, and return an integer value as min steps to gain max points.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:</strong>&nbsp;O(N*M)<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N*M)</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />&nbsp;&nbsp;&nbsp;1 &lt;= len(arr), len(arr[0])&nbsp;&lt;&nbsp;10<sup>3</sup><br />&nbsp; &nbsp;0&nbsp;&lt;= values in arr &lt;=100</span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "A knight is positioned at `(start_x, start_y)` on a Geekland grid of size `NxM`. Each cell in the grid contains a certain number of points. The knight can move according to standard chess knight moves. In each step `i`, the knight collects points from all cells reachable in exactly `i` steps, without revisiting any cell.\n\nThe knight also possesses magical powers. If the knight collects `y` points in the `x`th step, they can instantly collect all points from the `(x + y)`th step. If they collect `z` points in the `(x + y)`th step, they can further collect points from the `(x + y + z)`th step, and so on, all without increasing the step count.  These future collections happen instantaneously at the current step `x`.\n\nThe goal is to determine the minimum number of steps the knight needs to take to collect the maximum possible points.",
                "constraints": [
                    "1 <= len(arr), len(arr[0]) < 10^3",
                    "0 <= values in arr <= 100"
                ],
                "testcases": [
                    {
                        "input": "n = 9\nm = 10\nstart_x = 4, start_y = 5\narr =\n0 0 0 2 0 2 0 2 0 0\n0 0 2 0 2 0 2 0 2 0\n0 2 0 0 1 2 0 0 0 2\n0 0 2 0 2 0 2 0 2 0\n0 2 0 2 0 0 0 2 0 2\n0 0 2 0 2 0 2 0 2 0\n0 2 0 0 0 2 0 0 0 2\n0 0 2 0 2 0 2 0 2 0\n0 0 0 2 0 2 0 2 0 0",
                        "output": "1",
                        "explanation": "The knight starts at (4, 5). In the first step, the knight collects 1 point (red cells in the example).  Using the magical power, the knight can then immediately collect the 64 points collected in the second step (green cells), resulting in a total of 1 + 64 = 65 points after just one step. Thus, the minimum number of steps to get maximum points is 1."
                    },
                    {
                        "input": "n = 3\nm = 3\nstart_x = 2, start_y = 1\narr =\n7 6 8\n9 1 4\n6 2 8",
                        "output": "0",
                        "explanation": "Initially, the knight has 2 points at (2,1).  Because knight is starting at step 0, then the answer is 0."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Use bfs to find points at each step</span></p>",
            "<p><span style=\"font-size:18px\">Use dp to find minimum step to gain maximum points</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            },
            {
                "name": "Matrix",
                "slug": "matrix"
            },
            {
                "name": "BFS",
                "slug": "bfs"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class Solution{\npublic:\n    // Function to find the maximum score starting from given position\n    int knightInGeekland(int start_x,int start_y,vector<vector<int>> &arr){\n        int n=arr.size(); // number of rows\n        int m=arr[0].size(); // number of columns\n        \n        vector<vector<int>> vis(n,vector<int>(m)); // create a visited matrix to keep track of visited positions\n        vis[start_x][start_y] = 1; // mark the starting position as visited\n        queue<pair<int,int>> q; // create a queue to perform breadth-first search\n        q.push({start_x, start_y}); // push the starting position into the queue\n        \n        vector<int> list; // create a list to store the score obtained at each level\n        int points = 0; // initialize the points to 0\n        \n        int dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2}; // array to store possible x-direction moves\n        int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1}; // array to store possible y-direction moves\n        \n        // helper function to check if the given position is safe or not\n        auto isSafe=[&](int i, int j){\n            return (i>=0 and j>=0 and i<n and j<m); // returns true if the position is within the matrix bounds\n        };\n        \n        while(q.size()){ // while the queue is not empty\n            \n            int size = q.size(); // get the current size of the queue\n           \n            points = 0; // reset the points for each level\n            \n            for(int i = 0; i < size; i++){ // process all the elements in the current level\n                auto tmp = q.front(); // get the front element\n                q.pop(); // remove the front element from the queue\n                int x = tmp.first, y = tmp.second; // get the x and y coordinates\n                \n                points += arr[x][y]; // add the score at the current position to the points\n                \n                // check all possible moves from the current position\n                for(int k = 0; k < 8; k++){\n                    int xi = x + dx[k]; // get the new x coordinate\n                    int xj = y + dy[k]; // get the new y coordinate\n                    \n                    // if the new position is safe and not visited, mark it as visited and push it into the queue\n                    if(isSafe(xi, xj) && !vis[xi][xj]){\n                        vis[xi][xj] = 1; // mark the new position as visited\n                        q.push({xi, xj}); // push the new position into the queue\n                    }\n                }\n            }\n            list.push_back(points); // add the points obtained at the current level to the list\n        }\n        \n        int max = -1, ans = -1; // variables to store the maximum score and the answer position\n        \n        // iterate backwards through the list\n        for(int i = list.size() - 1; i >= 0; i--){\n            \n            // if the next position is within the list bounds, add it to the current score\n            if(list[i] + i < list.size())\n                list[i]+=list[i + list[i]];\n        }\n        \n        // find the maximum score and its position\n        for(int i = 0; i < list.size(); i++){\n            if(list[i] > max){\n                max = list[i]; // update the maximum score\n                ans = i; // update the answer position\n            }\n        }\n        return ans; // return the answer position\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution {\n    public int knightInGeekland(int arr[][], int start_x, int start_y) {\n        int n = arr.length;\n        int m = arr[0].length;\n        boolean visited[][] = new boolean[n][m];\n        visited[start_x][start_y] = true;\n\n        Queue<int[]> q = new LinkedList<>();\n        q.add(new int[] {start_x, start_y});\n        List<Integer> list = new ArrayList<>();\n        int points = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            points = 0;\n\n            for (int i = 0; i < size; i++) {\n                int temp[] = q.poll();\n                int x = temp[0], y = temp[1];\n                points += arr[x][y];\n                for (int k = 0; k < 8; k++) {\n                    int xi = x + dx[k];\n                    int xj = y + dy[k];\n                    if (isSafe(xi, xj, n, m) && !visited[xi][xj]) {\n                        visited[xi][xj] = true;\n                        q.add(new int[] {xi, xj});\n                    }\n                }\n            }\n            list.add(points);\n        }\n        int max = -1, ans = -1;\n\n        for (int i = list.size() - 1; i > -1; i--) {\n            if (list.get(i) + i < list.size())\n                list.set(i, list.get(i) + list.get(i + list.get(i)));\n        }\n        for (int i = 0; i < list.size(); i++) {\n            if (list.get(i) > max) {\n                max = list.get(i);\n                ans = i;\n            }\n        }\n        return ans;\n    }\n\n    static boolean isSafe(int i, int j, int n, int m) {\n        return i > -1 && i < n && j > -1 && j < m;\n    }\n\n    static int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\n    static int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};\n}\n",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\n\nfrom collections import deque\nclass Solution:\n    #Function to find the maximum number of points the knight can collect.\n    def knightInGeekland(self, arr, start):\n        q = deque([(start[0], start[1])])\n        n = len(arr)\n        m = len(arr[0])\n        s = set()\n        s.add((start[0], start[1]))\n        dist = [[-1,-2], [1,-2], [2,-1], [2,1], [1,2], [-1,2], [-2,1], [-2,-1]]\n        points = []\n        res = 0\n        mmax = -1e9\n        cnt = 1\n\n        #Function to check if the cell is safe to move.\n        def isSafe(a,b):\n            if a >= 0 and a < m and b >= 0 and b <= n:\n                return True\n            return False\n        \n        while q:\n            temp = 0\n            #Checking the maximum number of points for each move.\n            for _ in range(cnt):\n                x,y = q.popleft()\n                temp += arr[x][y]\n                for a,b in dist:\n                    if ((x+a) >= 0 and (x+a) < n and (y+b) >= 0 and (y+b) < m) and (x+a,y+b) not in s:\n                        s.add((x+a, y+b))\n                        res += 1\n                        q.append((x+a, y+b))\n            cnt = len(q)\n            points.append(temp)\n        \n        #Calculating the maximum points for each cell using dynamic programming.\n        for i in range(len(points)-1, -1, -1):\n            if i + points[i] < len(points):\n                points[i] += points[i+points[i]]\n        \n        #Finding the position with maximum points.\n        for i in range(len(points)):\n            if mmax >= points[i]:\n                continue\n            else:\n                res = i\n                mmax = points[i]\n        \n        return res",
                "lang_text": "python3"
            }
        ],
        "platform": "GFG"
    }
}