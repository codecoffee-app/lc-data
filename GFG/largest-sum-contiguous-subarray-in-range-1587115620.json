{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 700703,
            "title": "Largest Sum Contiguous Subarray in Range",
            "titleSlug": "largest-sum-contiguous-subarray-in-range-1587115620",
            "content": "<p><span style=\"font-size:18px\">Given an Array <strong>arr</strong> of size <strong>N</strong>, and <strong>Q</strong> queries of two types <strong>1</strong> and <strong>2</strong>. In </span><span style=\"font-size:18px\">the type-1</span><span style=\"font-size:18px\"> query, you will be given a range (left, right) and </span><span style=\"font-size:18px\">the task</span><span style=\"font-size:18px\"> is to print the <a href=\"https://www.geeksforgeeks.org/maximum-subarray-sum-given-range/\" rel=\"noopener\">Largest sum Contiguous Subarray</a> from the Array arr between the range (left, right). For type 2 queries, you will be given </span><span style=\"font-size:18px\">the index</span><span style=\"font-size:18px\">, an integer value, you need to update value to </span><strong><span style=\"font-size:18px\">arr</span></strong><strong><sub>index</sub></strong>.</p>\n\n<p><span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\n\n<pre>\n<span style=\"font-size:18px\"><strong>Input:\n</strong>N = 8, Q = 3\narr[] = {-2,-3,4,-1,-2,1,5,-3}\nQueries: query(5,8)\n&nbsp;\\t  update(1,11)\n&nbsp;\\t  query(1,3)\n<strong>Output:\n</strong>6\n12<strong>\nExplanation: </strong>In the first query, the task\nis to print the largest sum of contiguous\nsubarray in range 5-8, which consists of\n{-2, 1, 5, -3}. The largest sum is 6,\nwhich is formed by the subarray {1, 5}.\nIn the second query, an update operation\nis done, which updates a[1] to 10, hence\nthe sequence is {10,-3,4,-1,-2,1,5,-3}. \nIn the third query, the task is to print \nthe largest sum of a contiguous subarray\nin range 1-3, which consists of {10,-3,4}\nThe largest sum is 11, which is formed by\nthe subarray {10, -3, 4}.</span></pre>\n\n<p><span style=\"font-size:18px\"><strong>Your Task:</strong><br />\nYour task is to complete the function <strong>query()</strong> that should return the Largest Sum Contiguous Subarray in the given range and <strong>update() </strong>that should update the value in the array. A Tree has been already implemented for you(see driver&#39;s code)</span></p>\n\n<p><span style=\"font-size:18px\"><strong>Constraints:</strong><br />\n1 &lt;= N &lt;= 10<sup>3</sup><br />\n1 &lt;= Q &lt;= 500<br />\n-10<sup>3 </sup>&lt;= A[] &lt;= 10<sup>3</sup><br />\n1 &lt;= left,right &lt;= N&nbsp;<br />\n1 &lt;= Index &lt;= N</span></p>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given an array `arr` of size `N` and `Q` queries of two types:\n\n*   **Type 1 (Query):** Given a range (left, right), find and return the largest sum of a contiguous subarray within the range [left, right] (inclusive) in `arr`.\n*   **Type 2 (Update):** Given an index and an integer value, update the element at `arr[index]` with the given value.",
                "constraints": [
                    "1 <= N <= 10^3",
                    "1 <= Q <= 500",
                    "-10^3 <= A[i] <= 10^3 for all elements A[i] in arr",
                    "1 <= left, right <= N",
                    "1 <= Index <= N"
                ],
                "testcases": [
                    {
                        "input": "N = 8, Q = 3\narr[] = {-2,-3,4,-1,-2,1,5,-3}\nQueries: query(5,8)\n\t  update(1,11)\n\t  query(1,3)",
                        "output": "6\n12",
                        "explanation": "First query (5,8): The subarray from index 5 to 8 is {-2, 1, 5, -3}. The largest contiguous subarray sum is 6 (from {1, 5}).\nSecond query (update 1, 11): Update arr[1] to 11.  The array becomes {11, -3, 4, -1, -2, 1, 5, -3}.\nThird query (1,3): The subarray from index 1 to 3 is {11, -3, 4}. The largest contiguous subarray sum is 12 (from {11, -3, 4})."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            ""
        ],
        "relatedTopics": [
            {
                "name": "Segment-Tree",
                "slug": "segment-tree"
            },
            {
                "name": "Advanced Data Structure",
                "slug": "advanced-data-structure"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\n\n\n\nvoid updateUtil(int arr[], int index, int low, int high, int idx, int value)\n{\n\tif (low == high) \n\t{\n\t\ttree[index].sum = value;\n\t\ttree[index].prefixsum = value;\n\t\ttree[index].suffixsum = value;\n\t\ttree[index].maxsum = value;\n\t} \n\telse\n\t{\n\t\tint mid = (low + high) / 2;\n\t\t\n\t\t//if node to be updated is in left subtree.\n\t\tif (idx <= mid)\n\t\t    updateUtil(arr, 2 * index + 1, low, mid, idx, value);\n\t\t//else node to be updated is in right subtree.\n\t\telse \n\t\t    updateUtil(arr, 2 * index + 2, mid + 1, high, idx, value);\n\t\t\n\t\ttree[index].sum = tree[2 * index + 1].sum + tree[2 * index + 2].sum;\n\t\ttree[index].prefixsum = max(tree[2 * index + 1].prefixsum, tree[2 * index + 1].sum + tree[2 * index + 2].prefixsum);\n\t\ttree[index].suffixsum = max(tree[2 * index + 2].suffixsum, tree[2 * index + 2].sum + tree[2 * index + 1].suffixsum);\n\t\ttree[index].maxsum = max(tree[index].prefixsum, max(tree[index].suffixsum, max(tree[2 * index + 1].maxsum, max(tree[2 * index + 2].maxsum, tree[2 * index + 1].suffixsum + tree[2 * index + 2].prefixsum))));\n\t}\n}\n\nnode queryUtil(int arr[], int index, int low, int high, int l, int r)\n{\n    node result;\n    //initially all the values are equal to INT_MIN.\n    result.sum = result.prefixsum = result.suffixsum = result.maxsum = INT_MIN;\n    \n    //if segment of this node is outside the given range, we return result.\n    if (r < low || high < l)\n    return result;\n    \n    //if segment of this node is a part of given range, we return tree[index].\n    if (l <= low && high <= r)\n    return tree[index];\n    \n    //if a part of this segment overlaps with the given range, we call\n    //the function recursively for the children nodes accordingly.\n    int mid = (low + high) / 2;\n    if (l > mid) \n    return queryUtil(arr, 2 * index + 2, mid + 1, high, l, r);\n    if (r <= mid) \n    return queryUtil(arr, 2 * index + 1, low, mid, l, r);\n    \n    node left = queryUtil(arr, 2 * index + 1, low, mid, l, r);\n    node right = queryUtil(arr, 2 * index + 2, mid + 1, high, l, r);\n    \n    //finding the maximum and returning it.\n    result.sum = left.sum + right.sum;\n    result.prefixsum = max(left.prefixsum, left.sum + right.prefixsum);\n    result.suffixsum = max(right.suffixsum, right.sum + left.suffixsum);\n    \n    result.maxsum = max(result.prefixsum,max(result.suffixsum,max(left.maxsum,\n                    max(right.maxsum,left.suffixsum + right.prefixsum))));\n    return result;\n}\n\n//Function to update a value in input array and segment tree.\nvoid update(int arr[], int arrSize, int index, int value) \n{\n\tarr[index-1]=value;\n\t\n\t//updating the value of nodes in segment tree.\n\tupdateUtil(arr, 0, 0, arrSize-1, index-1, value);\n}\n\n//Funciton to return the Maximum-Sum in the range.\nint query(int arr[], int n, int l, int r)\n{\n\treturn queryUtil(arr, 0, 0, n-1, l-1, r-1).maxsum;\n}\n\n\n\n",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\n\nstatic void updateUtil(int arr[],int index,int low,int high,int idx,int value) \n{ \n    if (low == high) \n    { \n        tree[index].sum = value; \n        tree[index].prefixsum = value; \n        tree[index].suffixsum = value; \n        tree[index].maxsum = value; \n    }  \n    else\n    { \n        int mid = (low + high) / 2; \n  \n        //if node to be updated is in left subtree.\n        if (idx <= mid) \n        { \n            updateUtil(arr, 2 * index + 1, low, mid, idx, value); \n        }  \n        //else node to be updated is in right subtree.\n        else \n        { \n            updateUtil(arr, 2 * index + 2, mid + 1, high, idx, value); \n        } \n  \n        // parent node's sum is the summation of left  \n        // and rigth child \n        tree[index].sum = tree[2 * index + 1].sum + \n                          tree[2 * index + 2].sum; \n  \n        // parent node's prefix sum will be equivalent \n        // to maximum of left child's prefix sum or left  \n        // child sum + right child prefix sum. \n        tree[index].prefixsum = Math.max(tree[2 * index + 1].prefixsum,  \n                                         tree[2 * index + 1].sum +  \n                                         tree[2 * index + 2].prefixsum); \n  \n        // parent node's suffix sum will be equal to right \n        // child suffix sum or rigth child sum + suffix  \n        // sum of left child \n        tree[index].suffixsum = Math.max(tree[2 * index + 2].suffixsum,  \n                                         tree[2 * index + 2].sum +  \n                                         tree[2 * index + 1].suffixsum); \n  \n        // maxum will be the maximum of prefix, suffix of \n        // parent or maximum of left child or right child \n        // and summation of left child's suffix and  \n        // right child's prefix. \n        tree[index].maxsum = Math.max(tree[index].prefixsum,  \n                             Math.max(tree[index].suffixsum, \n                             Math.max(tree[2 * index + 1].maxsum,  \n                             Math.max(tree[2 * index + 2].maxsum, \n                                      tree[2 * index + 1].suffixsum +  \n                                      tree[2 * index + 2].prefixsum)))); \n    } \n} \n\n\nstatic node queryUtil(int arr[], int index, int low, int high, int l, int r)  \n{ \n    node result = new node(); \n    \n    //initially all the values are Integer.MIN_VALUE. \n    result.sum=result.prefixsum=result.suffixsum=result.maxsum=Integer.MIN_VALUE; \n  \n    //if segment of this node is outside the given range, we return result.\n    if (r < low || high < l) \n    { \n        return result; \n    } \n  \n    //if segment of this node is a part of given range, we return tree[index].\n    if (l <= low && high <= r) \n    { \n        return tree[index]; \n    } \n  \n    //if a part of this segment overlaps with the given range, we call\n    //the function recursively for the children nodes accordingly.\n    int mid = (low + high) / 2; \n    if (l > mid)  \n    { \n        return queryUtil(arr, 2 * index + 2, mid + 1, high, l, r); \n    } \n    if (r <= mid) \n    { \n        return queryUtil(arr, 2 * index + 1,low, mid, l, r); \n    } \n  \n    node left = queryUtil(arr, 2 * index + 1,low, mid, l, r); \n    node right = queryUtil(arr, 2 * index + 2, mid + 1, high, l, r); \n  \n    //finding the maximum and returning it.\n    result.sum = left.sum + right.sum; \n    result.prefixsum = Math.max(left.prefixsum,left.sum + right.prefixsum); \n  \n    result.suffixsum = Math.max(right.suffixsum,right.sum + left.suffixsum);\n    \n    result.maxsum = Math.max(result.prefixsum, \n                    Math.max(result.suffixsum, \n                    Math.max(left.maxsum, \n                    Math.max(right.maxsum, left.suffixsum + \n                             right.prefixsum)))); \n  \n    return result; \n} \n\n//Function to update a value in input array and segment tree.\nstatic void update(int arr[], int arrSize, int index, int value)\n{\n\tarr[index-1]=value;\n\t\n\t//updating the value of nodes in segment tree.\n\tupdateUtil(arr, 0, 0, arrSize-1, index-1, value);\n}\n\n//Funciton to return the Maximum-Sum in the range.\nstatic int query(int arr[], int n, int left, int right) \n{\n\treturn queryUtil(arr, 0, 0, n - 1, left - 1, right - 1).maxsum;\n}\n  ",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\n\n\n\ndef updateu(tree,arr,index,low,high,idx,value):\n    \n    if low==high:\n        tree[index].sm = value\n        tree[index].prefixsm = value\n        tree[index].suffixsm = value\n        tree[index].maxsm = value\n    else:\n        mid = (low + high) // 2\n        \n        #if node to be updated is in left subtree.\n        if idx <= mid:\n            updateu(tree,arr, 2 * index + 1, low, mid, idx, value)\n            \n        #else node to be updated is in right subtree.\n        else:\n            updateu(tree,arr, 2 * index + 2, mid + 1, high, idx, value)\n\t   \n\t   \n        tree[index].sm = tree[2 * index + 1].sm + tree[2 * index + 2].sm\n        tree[index].prefixsm = max(tree[2 * index + 1].prefixsm, tree[2 * index + 1].sm + tree[2 * index + 2].prefixsm)\n        tree[index].suffixsm = max(tree[2 * index + 2].suffixsm, tree[2 * index + 2].sm + tree[2 * index + 1].suffixsm)\n        tree[index].maxsm = max(tree[index].prefixsm, max(tree[index].suffixsm, max(tree[2 * index + 1].maxsm, max(tree[2 * index + 2].maxsm, tree[2 * index + 1].suffixsm + tree[2 * index + 2].prefixsm))))\n\ndef queryu(tree,arr,index,low,high,l,r):\n    \n    result=node()\n    \n    #if segment of this node is outside the given range, we return result.\n    if (r < low or high < l):\n        return result\n        \n    #if segment of this node is a part of given range, we return tree[index].\n    if (l <= low and high <= r):\n        return tree[index]\n    \n    #if a part of this segment overlaps with the given range, we call\n    #the function recursively for the children nodes accordingly.\n    mid = (low + high) // 2\n    if (l > mid):\n        return queryu(tree,arr, 2 * index + 2, mid + 1, high, l, r)\n    if (r <= mid):\n        return queryu(tree,arr, 2 * index + 1, low, mid, l, r)\n        \n    left = queryu(tree,arr, 2 * index + 1, low, mid, l, r)\n    right = queryu(tree,arr, 2 * index + 2, mid + 1, high, l, r)\n    \n    #finding the maximum and returning it.\n    result.sm = left.sm + right.sm\n    result.prefixsm = max(left.prefixsm, left.sm + right.prefixsm)\n    result.suffixsm = max(right.suffixsm, right.sm + left.suffixsm)\n    result.maxsm = max(result.prefixsm,max(result.suffixsm,max(left.maxsm,max(right.maxsm,left.suffixsm + right.prefixsm))))\n    return result\n\n#Function to update a value in input array and segment tree.\ndef update(tree,arr,arrSize,index,value):\n\tarr[index-1]=value\n\t\n\t#updating the value of nodes in segment tree.\n\tupdateu(tree,arr, 0, 0, arrSize-1, index-1, value)\n\n\n#Funciton to return the Maximum-Sum in the range.\t\ndef query(tree,arr,n,l,r):\n    \n\treturn queryu(tree,arr, 0, 0, n-1, l-1, r-1).maxsm\n\t\n\t",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": null,
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "//Back-end complete function Template for javascript\n\n/**\n * update\n * @param {number[]} arr\n * @param {number} arrSize\n * @param {number} index\n * @param {number} value\n * \n * query\n * @param {number[]} arr\n * @param {number} arrSize\n * @param {number} l\n * @param {number} r\n * @returns {number}\n*/\nclass Solution \n{\n    updateUtil(arr, index, low, high, idx, value)\n    {\n    \tif (low == high) {\n    \t\ttree[index].sum = value;\n    \t\ttree[index].prefixsum = value;\n    \t\ttree[index].suffixsum = value;\n    \t\ttree[index].maxsum = value;\n    \t} \n    \telse\n    \t{\n    \t\tlet mid = Math.floor((low + high) / 2);\n    \t\t\n    \t\t//if node to be updated is in left subtree.\n    \t\tif (idx <= mid) \n    \t\t    this.updateUtil(arr, 2 * index + 1, low, mid, idx, value);\n    \t\t//else node to be updated is in right subtree.\n    \t\telse\n    \t\t    this.updateUtil(arr, 2 * index + 2, mid + 1, high, idx, value);\n    \t\t    \n    \t\ttree[index].sum = tree[2 * index + 1].sum + tree[2 * index + 2].sum;\n    \t\ttree[index].prefixsum = Math.max(tree[2 * index + 1].prefixsum, tree[2 * index + 1].sum + tree[2 * index + 2].prefixsum);\n    \t\ttree[index].suffixsum = Math.max(tree[2 * index + 2].suffixsum, tree[2 * index + 2].sum + tree[2 * index + 1].suffixsum);\n    \t\ttree[index].maxsum = Math.max(tree[index].prefixsum, Math.max(tree[index].suffixsum, Math.max(tree[2 * index + 1].maxsum, Math.max(tree[2 * index + 2].maxsum, tree[2 * index + 1].suffixsum + tree[2 * index + 2].prefixsum))));\n    \t}\n    }\n    \n    queryUtil(arr, index, low, high, l, r)\n    {\n        let result = new node();\n        result.sum=result.prefixsum=result.suffixsum=result.maxsum=-1000000000;\n                     \n        //if segment of this node is outside the given range, we return result.\n        if (r < low || high < l)return result;\n        \n        //if segment of this node is part of given range, we return tree[index].\n        if (l <= low && high <= r){  \n            return tree[index];\n        }\n        \n        //if a part of this segment overlaps with the given range, we call\n        //the function recursively for the children nodes accordingly.\n        let mid = Math.floor((low + high) / 2);\n        if (l > mid) \n        return this.queryUtil(arr, 2 * index + 2, mid + 1, high, l, r);\n        if (r <= mid)\n        return this.queryUtil(arr, 2 * index + 1, low, mid, l, r);\n        \n        \n        let left = this.queryUtil(arr, 2 * index + 1, low, mid, l, r);\n        let right = this.queryUtil(arr, 2 * index + 2, mid + 1, high, l, r);\n        \n        //finding the maximum and returning it.\n        result.sum = left.sum + right.sum;\n        result.prefixsum = Math.max(left.prefixsum, left.sum + right.prefixsum);\n        result.suffixsum = Math.max(right.suffixsum, right.sum + left.suffixsum);\n        result.maxsum = Math.max(result.prefixsum, Math.max(result.suffixsum,\n                        Math.max(left.maxsum,Math.max(right.maxsum,\n                        left.suffixsum + right.prefixsum))));\n        \n        return result;\n    }\n    \n    //Function to update a value in input array and segment tree.\n    update(arr, arrSize, index, value)\n    {\n        arr[index-1]=value;\n        \n        //updating the value of nodes in segment tree.\n\t    this.updateUtil(arr, 0, 0, arrSize-1, index-1, value);\n    }\n    \n    //Funciton to return the Maximum-Sum in the range.\n    query(arr, arrSize, l, r)\n    {\n        return this.queryUtil(arr, 0, 0, arrSize-1, l-1, r-1).maxsum;\n    }\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}