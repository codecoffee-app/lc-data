{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 703604,
            "title": "Last Match",
            "titleSlug": "last-match1928",
            "content": "<p><span style=\"font-size:18px\">Given two strings A and B, you need to find the last&nbsp;occurrence ( 1 based indexing) of string B in string A.</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong>\r\nA = abcdefghijklghifghsd\r\nB = ghi\r\n<strong>Output:</strong>\r\n13<span style=\"font-size:20px\">\r\n</span><strong>Explanation:</strong>\r\nghi occurs at position 13 for the\r\nlast time in string A.\r\n</span></pre>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 2:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong>\r\nA = abdbccaeab\r\nB = abc</span><span style=\"font-size:18px\">\r\n<strong>Output:</strong>\r\n-1\r\n<strong>Explanation:</strong></span>\r\n<span style=\"font-size:18px\">abc is not a substring of A</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Your Task:</strong><br />\r\nYou don&#39;t need to read input or print anything. Your task is to complete the function<strong> findLastOccurence() </strong>which takes two strings A and B&nbsp;as input parameters and returns the position of the last occurrence of B in A. If B&nbsp;is not present in A, return -1.</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong> O(len(A))<br />\r\n<strong>Expected Space Complexity:</strong> O(len(A))</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Constarints:</strong><br />\r\n1&lt;=T&lt;=100<br />\r\n1&lt;=len(B)&lt;=10<sup>5</sup><br />\r\n1&lt;=len(A)&lt;=10<sup>6</sup><br />\r\nlen(A)&gt;=len(B)</span><br />\r\n&nbsp;</p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given two strings, A and B, find the 1-based index of the last occurrence of string B within string A. If string B is not found within string A, return -1.",
                "constraints": [
                    "1 <= T <= 100",
                    "1 <= len(B) <= 10^5",
                    "1 <= len(A) <= 10^6",
                    "len(A) >= len(B)"
                ],
                "testcases": [
                    {
                        "input": "A = abcdefghijklghifghsd\nB = ghi",
                        "output": "13",
                        "explanation": "The last occurrence of 'ghi' in 'abcdefghijklghifghsd' starts at index 13."
                    },
                    {
                        "input": "A = abdbccaeab\nB = abc",
                        "output": "-1",
                        "explanation": "The substring 'abc' is not present in 'abdbccaeab'."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Use the Knuth-Morris-Pratt algorithm&nbsp;for this problem.</span></p>\n\n<h3>&nbsp;</h3>"
        ],
        "relatedTopics": [
            {
                "name": "Strings",
                "slug": "strings"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class Solution{   \r\npublic:\r\n    int findLastOccurence(string A,string B){\r\n       \r\n        int M = B.length(); \r\n        int N = A.length(); \r\n      \r\n        // create lps[] that will hold the longest prefix suffix \r\n        // values for pattern \r\n        int lps[M]; \r\n      \r\n        // Preprocess the pattern (calculate lps[] array) \r\n        computeLPSArray(B, M, lps); \r\n        int ans = -2;\r\n        int i = 0; // index for txt[] \r\n        int j = 0; // index for pat[] \r\n        while (i < N) { \r\n            if (B[j] == A[i]) { \r\n                j++; \r\n                i++; \r\n            } \r\n            if (j == M) { \r\n                ans = i - j; \r\n                j = lps[j - 1]; \r\n            } \r\n            // mismatch after j matches \r\n            else if (i < N && B[j] != A[i]) { \r\n                // Do not match lps[0..lps[j-1]] characters, \r\n                // they will match anyway \r\n                if (j != 0) \r\n                    j = lps[j - 1]; \r\n                else\r\n                    i = i + 1; \r\n            } \r\n        } \r\n        return ans+1;\r\n    }\r\n    void computeLPSArray(string pat, int M, int lps[]) \r\n    { \r\n    \t// length of the previous longest prefix suffix \r\n    \tint len = 0; \r\n    \r\n    \tlps[0] = 0; // lps[0] is always 0 \r\n    \r\n    \t// the loop calculates lps[i] for i = 1 to M-1 \r\n    \tint i = 1; \r\n    \twhile (i < M) { \r\n    \t\tif (pat[i] == pat[len]) { \r\n    \t\t\tlen++; \r\n    \t\t\tlps[i] = len; \r\n    \t\t\ti++; \r\n    \t\t} \r\n    \t\telse // (pat[i] != pat[len]) \r\n    \t\t{ \r\n    \t\t\t// This is tricky. Consider the example. \r\n    \t\t\t// AAACAAAA and i = 7. The idea is similar \r\n    \t\t\t// to search step. \r\n    \t\t\tif (len != 0) { \r\n    \t\t\t\tlen = lps[len - 1]; \r\n    \r\n    \t\t\t\t// Also, note that we do not increment \r\n    \t\t\t\t// i here \r\n    \t\t\t} \r\n    \t\t\telse // if (len == 0) \r\n    \t\t\t{ \r\n    \t\t\t\tlps[i] = 0; \r\n    \t\t\t\ti++; \r\n    \t\t\t} \r\n    \t\t} \r\n    \t} \r\n    }\r\n};\r\n",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": null,
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": null,
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "class Solution\n{\n    //Complete this function\n    //Function to find the last occurrence of string B in string A.\n    public int findLastOccurence(string A,string B)\n    {\n        int M = B.Length; \n        int N = A.Length; \n  \n        // create lps[] that will hold the longest prefix suffix \n        // values for pattern \n        int[] lps = new int[M]; \n  \n        // Preprocess the pattern (calculate lps[] array) \n        computeLPSArray(B, M, lps); \n        int ans = -2;\n        int i = 0; // index for txt[] \n        int j = 0; // index for pat[] \n        while (i < N) { \n            if (B[j] == A[i]) { \n                j++; \n                i++; \n            } \n            if (j == M) { \n                ans = i - j; \n                j = lps[j - 1]; \n            } \n            // mismatch after j matches \n            else if (i < N && B[j] != A[i]) { \n                // Do not match lps[0..lps[j-1]] characters, \n                // they will match anyway \n                if (j != 0) \n                    j = lps[j - 1]; \n                else\n                    i = i + 1; \n            } \n        } \n        return ans+1;\n    }\n    void computeLPSArray(string pat, int M, int[] lps) \n    { \n        // length of the previous longest prefix suffix \n        int len = 0; \n    \n        lps[0] = 0; // lps[0] is always 0 \n    \n        // the loop calculates lps[i] for i = 1 to M-1 \n        int i = 1; \n        while (i < M) { \n            if (pat[i] == pat[len]) { \n                len++; \n                lps[i] = len; \n                i++; \n            } \n            else // (pat[i] != pat[len]) \n            { \n                // This is tricky. Consider the example. \n                // AAACAAAA and i = 7. The idea is similar \n                // to search step. \n                if (len != 0) { \n                    len = lps[len - 1]; \n    \n                    // Also, note that we do not increment \n                    // i here \n                } \n                else // if (len == 0) \n                { \n                    lps[i] = 0; \n                    i++; \n                } \n            } \n        } \n    }\n}",
                "lang_text": "csharp"
            }
        ],
        "platform": "GFG"
    }
}