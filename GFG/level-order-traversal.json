{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 700511,
            "title": "Level order traversal",
            "titleSlug": "level-order-traversal",
            "content": "<p><span >Given a&nbsp;<strong>root</strong>&nbsp;of a binary tree with&nbsp;<strong>n</strong> nodes, the task is to find its level order traversal. </span><span >Level order traversal of a tree is&nbsp;<a href=\"http://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/\"><span style=\"text-decoration: underline; color: #3598db;\">breadth-first traversal</span></a>&nbsp;for the tree.</span></p>\n<p><span ><strong>Examples:</strong></span></p>\n<pre><span ><strong>Input:</strong> root[] = [1, 2, 3]<br /><img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700511/Web/Other/blobid0_1738405019.png\" width=\"348\" height=\"312\" />\n<strong>Output: </strong>[[1], [2, 3]]\n</span></pre>\n<pre><span ><strong>Input:</strong> root[] = [10, 20, 30, 40, 50]<br /><img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700511/Web/Other/blobid2_1738405085.png\" width=\"352\" height=\"315\" />\n<strong>Output: </strong>[[10], [20, 30], [40, 50]]</span></pre>\n<pre><span ><strong>Input:</strong> root[] = [1, 3, 2, N, N, N, 4, 6, 5]<br /><img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700511/Web/Other/blobid3_1738405128.png\" width=\"349\" height=\"309\" />\n<strong>Output: </strong>[[1], [3, 2], [4], [6, 5]]</span></pre>\n<p><span ><strong>Constraints:</strong></span></p>\n<ul>\n<li><span >1 &le; number of nodes &le; 10<sup>5</sup></span></li>\n<li><span >0 &le; node-&gt;data &le; 10<sup>9</sup></span></li>\n</ul>",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p><span >Use queue for doing BFS.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [
            "flipkart",
            "morgan-stanley",
            "accolite",
            "amazon",
            "microsoft",
            "samsung",
            "d-e-shaw",
            "ola-cabs",
            "payu",
            "adobe",
            "cisco",
            "qualcomm"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class Solution {\n  public:\n    // Function to return the level order traversal of a tree.\n    vector<vector<int>> levelOrder(Node *root) {\n        if (root == nullptr)\n            return {};\n\n        // Create an empty queue for level order traversal\n        queue<Node *> q;\n        vector<vector<int>> res;\n\n        // Enqueue Root\n        q.push(root);\n        int currLevel = 0;\n\n        while (!q.empty()) {\n            int len = q.size();\n            res.push_back({});\n\n            for (int i = 0; i < len; i++) {\n\n                // Add front of queue and remove it from queue\n                Node *node = q.front();\n                q.pop();\n\n                res[currLevel].push_back(node->data);\n\n                // Enqueue left child\n                if (node->left != nullptr)\n                    q.push(node->left);\n\n                // Enqueue right child\n                if (node->right != nullptr)\n                    q.push(node->right);\n            }\n            currLevel++;\n        }\n        return res;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\nclass Solution {\n    // Function to return the level order traversal of a tree.\n    public ArrayList<ArrayList<Integer>> levelOrder(Node root) {\n        if (root == null) return new ArrayList<>();\n\n        // Create an empty queue for level order traversal\n        Queue<Node> q = new LinkedList<>();\n        ArrayList<ArrayList<Integer>> res = new ArrayList<>();\n\n        // Enqueue Root\n        q.add(root);\n        int currLevel = 0;\n\n        while (!q.isEmpty()) {\n            int len = q.size();\n            res.add(new ArrayList<>());\n\n            for (int i = 0; i < len; i++) {\n                // Add front of queue and remove it from queue\n                Node node = q.poll();\n                res.get(currLevel).add(node.data);\n\n                // Enqueue left child\n                if (node.left != null) q.add(node.left);\n\n                // Enqueue right child\n                if (node.right != null) q.add(node.right);\n            }\n            currLevel++;\n        }\n        return res;\n    }\n}\n",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\n\"\"\"\nclass Node:\n    def __init__(self, value):\n        self.left = None\n        self.data = value\n        self.right = None\n\"\"\"\n\n\nclass Solution:\n\n    #Function to return the level order traversal of a tree.\n    def levelOrder(self, root):\n        if root is None:\n            return []\n\n        # Create an empty queue for level order traversal\n        q = deque()\n        res = []\n\n        # Enqueue Root\n        q.append(root)\n        currLevel = 0\n\n        while q:\n            len_q = len(q)\n            res.append([])\n\n            for _ in range(len_q):\n                # Add front of queue and remove it from queue\n                node = q.popleft()\n                res[currLevel].append(node.data)\n\n                # Enqueue left child\n                if node.left is not None:\n                    q.append(node.left)\n\n                # Enqueue right child\n                if node.right is not None:\n                    q.append(node.right)\n            currLevel += 1\n\n        return res\n",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "class Solution {\n    // Function to return the level order traversal of a tree.\n    public List<List<int>> levelOrder(Node root) {\n        List<List<int>> res = new List<List<int>>();\n        if (root == null) return res;\n\n        // Create an empty queue for level order traversal\n        Queue<Node> q = new Queue<Node>();\n\n        // Enqueue Root\n        q.Enqueue(root);\n        int currLevel = 0;\n\n        while (q.Count > 0) {\n            int len = q.Count;\n            res.Add(new List<int>());\n\n            for (int i = 0; i < len; i++) {\n                // Add front of queue and remove it from queue\n                Node node = q.Dequeue();\n                res[currLevel].Add(node.data);\n\n                // Enqueue left child\n                if (node.left != null) q.Enqueue(node.left);\n\n                // Enqueue right child\n                if (node.right != null) q.Enqueue(node.right);\n            }\n            currLevel++;\n        }\n        return res;\n    }\n}",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "//Back-end complete function Template for javascript\n\n/**\n * @param {Node} node\n * @returns {number[][]}\n */\n\n/*\nclass Node{\n    constructor(data){\n        this.data = data;\n        this.left = null;\n        this.right = null;\n    }\n}\n*/\n\nclass Solution {\n    // Function to return the level order traversal of a tree.\n    levelOrder(root) {\n        if (root === null) return [];\n\n        // Create an empty queue for level order traversal\n        const q = [];\n        const res = [];\n\n        // Enqueue Root\n        q.push(root);\n        let currLevel = 0;\n\n        while (q.length > 0) {\n            const len = q.length;\n            res.push([]);\n\n            for (let i = 0; i < len; i++) {\n                // Add front of queue and remove it from queue\n                const node = q.shift();\n                res[currLevel].push(node.data);\n\n                // Enqueue left child\n                if (node.left !== null) q.push(node.left);\n\n                // Enqueue right child\n                if (node.right !== null) q.push(node.right);\n            }\n            currLevel++;\n        }\n        return res;\n    }\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}