{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 712324,
            "title": "LFU cache",
            "titleSlug": "lfu-cache-1665050355",
            "content": "<p dir=\"ltr\"><span >Design and implement an LFU (Least Frequently Used) cache. Here <strong>cap</strong> denotes the capacity of the cache and <strong>Q</strong> denotes the number of queries. Query can be of two types <strong>GET(x)</strong> and <strong>PUT(x, y)</strong>.&nbsp;</span></p>\n<p dir=\"ltr\"><span >The LRU cache should support the following operations:</span></p>\n<ul>\n<li dir=\"ltr\"><span ><strong>LFUCache(cap)</strong>: initializes the cache with a given capacity.</span></li>\n<li dir=\"ltr\"><span ><strong>get(key)</strong>: returns the value associated with the key if it exists; otherwise, returns <strong>-1</strong>.</span></li>\n<li dir=\"ltr\"><span ><strong>put(key, value)</strong>: inserts or updates the key with value. If the cache has reached its capacity, the least frequently used (LFU) key should be removed. If there is a tie between keys with the same frequency, the least recently used (LRU) key among them should be removed.</span></li>\n</ul>\n<p><span style=\"font-size: 14pt; font-family: arial, helvetica, sans-serif;\"><strong>Examples:</strong></span></p>\n<pre><span style=\"font-size: 14pt; font-family: arial, helvetica, sans-serif;\"><strong style=\"font-family: arial, helvetica, sans-serif; font-size: 14pt;\">Input: </strong><span style=\"font-family: arial, helvetica, sans-serif; font-size: 14pt;\">cap = 2, Q = 9, Queries = [[\"PUT\", 1, 1], [\"PUT\", 2, 2], [\"GET\", 1], [\"PUT\", 3, 3], [\"GET\", 2], [\"PUT\", 4, 4], [\"GET\", 3], [\"GET\", 4], [\"PUT\", 5, 5]]<br /></span><strong style=\"font-family: arial, helvetica, sans-serif; font-size: 14pt;\">Output: </strong><span style=\"font-family: arial, helvetica, sans-serif;\"><span style=\"font-size: 18.6667px;\">[1 , -1, -1, 4]</span></span><strong style=\"font-family: arial, helvetica, sans-serif; font-size: 14pt;\"><br />Explanation: </strong><span style=\"font-family: arial, helvetica, sans-serif;\"><span style=\"font-size: 18.6667px;\">Cache Size = 2</span></span><strong style=\"font-family: arial, helvetica, sans-serif; font-size: 14pt;\"><br /></strong></span><span style=\"font-size: 14pt; font-family: arial, helvetica, sans-serif;\"><span style=\"font-family: arial, helvetica, sans-serif; font-size: 14pt;\">[\"PUT\", 1, 1]: inserts the key-value pair (1, 1).\n[\"PUT\", 2, 2]: inserts the key-value pair (2, 2).\n[\"GET\", 1]: the cache retrieves the value for key 1, which is 1. After accessing key 1, its frequency increases to 2.\n[\"PUT\", 3, 3]: The cache is now full (capacity = 2). To insert the new key-value pair (3, 3), the least frequently used key must be removed. key 2 have a frequency of 1. As a result, key 2 (the least recently accessed key) is removed and key-value pair (3, 3) is inserted with frequency 1.\n[\"GET\", 2]: cache returns -1 indicating that key 2 is not found.\n[\"PUT\", 4, 4]: key 3 is removed as it has frequency of 1 and key-value pair (4, 4) is inserted with frequency 1.\n[\"GET\", 3]: returns -1 (key 3 not found)\n[\"GET\", 4]: the cache retrieves the value for key 4, which is 4. After accessing key 4, its frequency increases to 2.\n[\"PUT\", 5, 5]: key 1 and key 4 both have a frequency of 2 . Now, key 1 will be removed as key 4 is most recently used and key-value pair (5, 5) is inserted with frequency 1.</span></span></pre>\n<pre><span style=\"font-size: 14pt; font-family: arial, helvetica, sans-serif;\"><strong style=\"font-family: arial, helvetica, sans-serif; font-size: 14pt;\">Input: </strong><span style=\"font-family: arial, helvetica, sans-serif;\"><span >cap = </span></span><code style=\"font-family: arial, helvetica, sans-serif; font-size: 14pt;\">3,</code> <span style=\"font-family: arial, helvetica, sans-serif;\"><span >Q = 10, Queries = [[\"PUT\", 5, 7], [\"PUT\", 4, 6], [\"PUT\", 3, 5], [\"PUT\", 2, 4], [\"PUT\", 1, 3], [\"GET\", 1], [\"GET\", 2], [\"GET\", 3], [\"GET\", 4], [\"GET\", 5]]<br /></span></span><strong style=\"font-family: arial, helvetica, sans-serif; font-size: 14pt;\">Output: </strong><span style=\"font-family: arial, helvetica, sans-serif;\"><span >[3, 4, 5, -1, -1]<br /></span></span><strong style=\"font-family: arial, helvetica, sans-serif; font-size: 14pt;\">Explanation: </strong><span style=\"font-size: 18.6667px;\">[\"PUT\", 2, 4]</span><span style=\"font-weight: 400;\">&nbsp;evicts&nbsp;<code>(5,7)</code> as it is the least frequently used. [\"PUT\", 1, 3] </span><span style=\"font-weight: 400;\">evicts&nbsp;<code>(4,6)</code>. </span><span style=\"font-weight: 400;\">After all operations, the cache contains keys&nbsp;</span><code style=\"font-weight: 400;\">1</code><span style=\"font-weight: 400;\">,&nbsp;</span><code style=\"font-weight: 400;\">2</code><span style=\"font-weight: 400;\">, and&nbsp;</span><code style=\"font-weight: 400;\">3</code><span style=\"font-weight: 400;\">.</span></span></pre>\n<p><span style=\"font-size: 14pt; font-family: arial, helvetica, sans-serif;\"><strong>Constraints:<br /></strong><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"mord\">0 </span><span class=\"mrel\">&le; </span></span><span class=\"base\"><span class=\"mord text\"><span class=\"mord\">cap </span></span><span class=\"mrel\">&le; </span></span><span class=\"base\"><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0<sup>4</sup></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\"><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><br /><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"mord\">0 </span><span class=\"mrel\">&le; </span></span><span class=\"base\"><span class=\"mord text\"><span class=\"mord\">key </span></span><span class=\"mrel\">&le; </span></span><span class=\"base\"><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0<sup>5</sup></span></span></span></span><span class=\"katex-mathml\"><br /></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"mord\">0 </span><span class=\"mrel\">&le; </span></span><span class=\"base\"><span class=\"mord text\"><span class=\"mord\">value </span></span><span class=\"mrel\">&le; </span></span><span class=\"base\"><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0<sup>6</sup></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\"><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><br /></span></span></span></span></span></span></span></span></span>Up to <span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"mord\">2</span><span class=\"mbin\">&times;</span></span><span class=\"base\"><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0<sup>5</sup></span></span></span></span></span>&nbsp;calls will be made to&nbsp;<code>get</code>&nbsp;and&nbsp;<code>put</code>.</span></span></span></span></span></span></span></span></span></span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Design and implement a Least Frequently Used (LFU) cache. The cache has a fixed capacity.  It supports two operations: GET(key) and PUT(key, value).\n\n- LFUCache(capacity): Initializes the cache with the given capacity.\n- get(key): Returns the value associated with the key if it exists; otherwise, returns -1.  Also, increment the frequency of the key if found.\n- put(key, value): Inserts or updates the key with the value. If the cache is full, evict the least frequently used key. If there is a tie in frequency, evict the least recently used key.",
                "constraints": [
                    "0 <= cap <= 10^4",
                    "0 <= key <= 10^5",
                    "0 <= value <= 10^6",
                    "Up to 2 * 10^5 calls will be made to get and put."
                ],
                "testcases": [
                    {
                        "input": "cap = 2, Q = 9, Queries = [[\"PUT\", 1, 1], [\"PUT\", 2, 2], [\"GET\", 1], [\"PUT\", 3, 3], [\"GET\", 2], [\"PUT\", 4, 4], [\"GET\", 3], [\"GET\", 4], [\"PUT\", 5, 5]]",
                        "output": "[1, -1, -1, 4]",
                        "explanation": "Cache starts with capacity 2. (1, 1) and (2, 2) are added. GET(1) returns 1 and increments frequency of key 1. PUT(3, 3) evicts (2, 2) because it's least frequent. GET(2) returns -1 because (2, 2) was evicted. PUT(4, 4) evicts (3, 3). GET(3) returns -1. GET(4) returns 4 and increments frequency of key 4. PUT(5, 5) evicts (1, 1) because frequency of 1 and 4 is 1 and 1 is less recently used."
                    },
                    {
                        "input": "cap = 3, Q = 10, Queries = [[\"PUT\", 5, 7], [\"PUT\", 4, 6], [\"PUT\", 3, 5], [\"PUT\", 2, 4], [\"PUT\", 1, 3], [\"GET\", 1], [\"GET\", 2], [\"GET\", 3], [\"GET\", 4], [\"GET\", 5]]",
                        "output": "[3, 4, 5, -1, -1]",
                        "explanation": "Cache starts with capacity 3. After putting (5,7), (4,6), (3,5), (2,4) and (1,3), (5,7) and (4,6) are evicted based on the LFU and LRU criteria."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span >Use hash maps to track key frequencies and maintain groups of keys by frequency to enable O(1) updates and evictions.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Hash",
                "slug": "hash"
            },
            {
                "name": "doubly-linked-list",
                "slug": "doubly-linked-list"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Design-Pattern",
                "slug": "design-pattern"
            }
        ],
        "companies": [],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\n\n/* struct Node:\n   - Represents a node in the doubly linked list.\n   - Contains key, value, and frequency count of an element.\n   - Has pointers to the next and previous nodes.\n*/\n\nstruct Node {\n    int key, value, cnt;\n    Node* next;\n    Node* prev;\n\n    Node(int _key, int _value) {\n        key = _key;\n        value = _value;\n        cnt = 1;\n    }\n};\n\n/* struct List:\n   - Represents a doubly linked list.\n   - Contains a head and tail node.\n   - Keeps track of the size of the list.\n*/\n\nstruct List {\n    int size;\n    Node* head;\n    Node* tail;\n\n    List() {\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        head->next = tail;\n        tail->prev = head;\n        size = 0;\n    }\n\n    // Function to add a node to the front of the list.\n    void addFront(Node* node) {\n        Node* temp = head->next;\n        node->next = temp;\n        node->prev = head;\n        head->next = node;\n        temp->prev = node;\n        size++;\n    }\n\n    // Function to remove a given node from the list.\n    void removeNode(Node* delnode) {\n        Node* delprev = delnode->prev;\n        Node* delnext = delnode->next;\n        delprev->next = delnext;\n        delnext->prev = delprev;\n        size--;\n    }\n};\n\nclass LFUCache {\n    map<int, Node*> keyNode; // Map to store the nodes based on key.\n    map<int, List*>\n        freqListMap;  // Map to store the doubly linked lists based on frequency.\n    int maxSizeCache; // Maximum size of the cache.\n    int minFreq;      // Minimum frequency of elements in the cache.\n    int curSize;      // Current size of the cache.\n  public:\n    LFUCache(int cap) {\n        maxSizeCache = cap;\n        minFreq = 0;\n        curSize = 0;\n    }\n\n    // Function to update the frequency list map after accessing a node.\n    void updateFreqListMap(Node* node) {\n        keyNode.erase(node->key); // Remove the node from the key-node map.\n        freqListMap[node->cnt]->removeNode(\n            node); // Remove the node from the frequency list.\n\n        // If the minimum frequency list becomes empty, increment the minimum frequency.\n        if (node->cnt == minFreq && freqListMap[node->cnt]->size == 0) {\n            minFreq++;\n        }\n\n        // Get the next higher frequency list.\n        List* nextHigherFreqList = new List();\n        if (freqListMap.find(node->cnt + 1) != freqListMap.end()) {\n            nextHigherFreqList = freqListMap[node->cnt + 1];\n        }\n\n        // Increase the frequency of the node and add it to the next higher frequency\n        // list.\n        node->cnt += 1;\n        nextHigherFreqList->addFront(node);\n\n        // Update the frequency list map and the key-node map with the new node.\n        freqListMap[node->cnt] = nextHigherFreqList;\n        keyNode[node->key] = node;\n    }\n\n    // Function to get the value of a node based on its key.\n    int get(int key) {\n        if (keyNode.find(key) != keyNode.end()) {\n            Node* node = keyNode[key];\n            int val = node->value;\n            // Update the frequency list map after accessing the node.\n            updateFreqListMap(node);\n            return val;\n        }\n        return -1;\n    }\n\n    // Function to add or update a node in the cache.\n    void put(int key, int value) {\n        if (maxSizeCache == 0) {\n            return;\n        }\n        if (keyNode.find(key) != keyNode.end()) {\n            Node* node = keyNode[key];\n            node->value = value;\n            // Update the frequency list map after updating the node.\n            updateFreqListMap(node);\n        } else {\n            // If the cache is full, remove the least frequently used node.\n            if (curSize == maxSizeCache) {\n                List* list = freqListMap[minFreq];\n                keyNode.erase(list->tail->prev->key);\n                freqListMap[minFreq]->removeNode(list->tail->prev);\n                curSize--;\n            }\n            curSize++;\n            // Add the new node to the cache with frequency equal to 1.\n            minFreq = 1;\n            List* listFreq = new List();\n            if (freqListMap.find(minFreq) != freqListMap.end()) {\n                listFreq = freqListMap[minFreq];\n            }\n            Node* node = new Node(key, value);\n            listFreq->addFront(node);\n            // Update the frequency list map and the key-node map with the new node.\n            keyNode[key] = node;\n            freqListMap[minFreq] = listFreq;\n        }\n    }\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\nclass LFUCache {\n\n    final int capacity;\n    int curSize;\n    int minFrequency;\n    Map<Integer, DLLNode> cache;\n    Map<Integer, DoubleLinkedList> frequencyMap;\n\n    /*.*/\n    /*\n     * @param capacity: total capacity of LFU Cache\n     * @param curSize: current size of LFU cache\n     * @param minFrequency: frequency of the last linked list (the minimum frequency of\n     *     entire LFU cache)\n     * @param cache: a hash map that has key to Node mapping, which used for storing all\n     *     nodes by their keys\n     * @param frequencyMap: a hash map that has key to linked list mapping, which used\n     *     for storing all\n     * double linked list by their frequencies\n     * */\n    public LFUCache(int cap) {\n        this.capacity = cap;\n        this.curSize = 0;\n        this.minFrequency = 0;\n\n        this.cache = new HashMap<>();\n        this.frequencyMap = new HashMap<>();\n    }\n\n    /**\n     * get node value by key, and then update node frequency as well as relocate that\n     * node *\n     */\n    public int get(int key) {\n        DLLNode curNode = cache.get(key);\n        if (curNode == null) {\n            return -1;\n        }\n        updateNode(curNode);\n        return curNode.val;\n    }\n\n    /**\n     * add new node into LFU cache, as well as double linked list\n     * condition 1: if LFU cache has input key, update node value and node position in\n     * list condition 2: if LFU cache does NOT have input key\n     *  - sub condition 1: if LFU cache does NOT have enough space, remove the Least\n     * Recent Used node in minimum frequency list, then add new node\n     *  - sub condition 2: if LFU cache has enough space, add new node directly\n     * *\n     */\n    public void put(int key, int value) {\n        // corner case: check cache capacity initialization\n        if (capacity == 0) {\n            return;\n        }\n\n        if (cache.containsKey(key)) {\n            DLLNode curNode = cache.get(key);\n            curNode.val = value;\n            updateNode(curNode);\n        } else {\n            curSize++;\n            if (curSize > capacity) {\n                // get minimum frequency list\n                DoubleLinkedList minFreqList = frequencyMap.get(minFrequency);\n                cache.remove(minFreqList.tail.prev.key);\n                minFreqList.removeNode(minFreqList.tail.prev);\n                curSize--;\n            }\n            // reset min frequency to 1 because of adding new node\n            minFrequency = 1;\n            DLLNode newNode = new DLLNode(key, value);\n\n            // get the list with frequency 1, and then add new node into the list, as\n            // well as into LFU cache\n            DoubleLinkedList curList =\n                frequencyMap.getOrDefault(1, new DoubleLinkedList());\n            curList.addNode(newNode);\n            frequencyMap.put(1, curList);\n            cache.put(key, newNode);\n        }\n    }\n\n    public void updateNode(DLLNode curNode) {\n        int curFreq = curNode.frequency;\n        DoubleLinkedList curList = frequencyMap.get(curFreq);\n        curList.removeNode(curNode);\n\n        // if current list the the last list which has lowest frequency and current node\n        // is the only node in that list we need to remove the entire list and then\n        // increase min frequency value by 1\n        if (curFreq == minFrequency && curList.listSize == 0) {\n            minFrequency++;\n        }\n\n        curNode.frequency++;\n        // add current node to another list has current frequency + 1,\n        // if we do not have the list with this frequency, initialize it\n        DoubleLinkedList newList =\n            frequencyMap.getOrDefault(curNode.frequency, new DoubleLinkedList());\n        newList.addNode(curNode);\n        frequencyMap.put(curNode.frequency, newList);\n    }\n\n    /*\n     * @param key: node key\n     * @param val: node value\n     * @param frequency: frequency count of current node\n     * (all nodes connected in same double linked list has same frequency)\n     * @param prev: previous pointer of current node\n     * @param next: next pointer of current node\n     * */\n    class DLLNode {\n        int key;\n        int val;\n        int frequency;\n        DLLNode prev;\n        DLLNode next;\n\n        public DLLNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n            this.frequency = 1;\n        }\n    }\n\n    /*\n     * @param listSize: current size of double linked list\n     * @param head: head node of double linked list\n     * @param tail: tail node of double linked list\n     * */\n    class DoubleLinkedList {\n        int listSize;\n        DLLNode head;\n        DLLNode tail;\n\n        public DoubleLinkedList() {\n            this.listSize = 0;\n            this.head = new DLLNode(0, 0);\n            this.tail = new DLLNode(0, 0);\n            head.next = tail;\n            tail.prev = head;\n        }\n\n        /** add new node into head of list and increase list size by 1 **/\n        public void addNode(DLLNode curNode) {\n            DLLNode nextNode = head.next;\n            curNode.next = nextNode;\n            curNode.prev = head;\n            head.next = curNode;\n            nextNode.prev = curNode;\n            listSize++;\n        }\n\n        /** remove input node and decrease list size by 1**/\n        public void removeNode(DLLNode curNode) {\n            DLLNode prevNode = curNode.prev;\n            DLLNode nextNode = curNode.next;\n            prevNode.next = nextNode;\n            nextNode.prev = prevNode;\n            listSize--;\n        }\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\n\nimport collections\n\n\nclass LFUCache:\n    #Initializing the LFUCache class\n    def __init__(self, cap: int):\n        self.capacity = cap\n        self.minfreq = None\n        self.keyfreq = {}\n        self.freqkeys = collections.defaultdict(collections.OrderedDict)\n\n    #Get the value of a key in the LFUCache\n    def get(self, key: int) -> int:\n        #If key not found, return -1\n        if key not in self.keyfreq:\n            return -1\n\n        #Get the frequency and value of the key\n        freq = self.keyfreq[key]\n        val = self.freqkeys[freq][key]\n\n        #Remove the key from its current frequency\n        del self.freqkeys[freq][key]\n\n        #If the current frequency has no other keys, update the minfreq\n        if not self.freqkeys[freq]:\n            if freq == self.minfreq:\n                self.minfreq += 1\n            del self.freqkeys[freq]\n\n        #Update the key's frequency to current frequency + 1\n        self.keyfreq[key] = freq + 1\n        #Add the key and value to the new frequency\n        self.freqkeys[freq + 1][key] = val\n\n        #Return the value of the key\n        return val\n\n    #Put a key-value pair in the LFUCache\n    def put(self, key: int, value: int) -> None:\n        #If capacity is 0 or negative, do nothing\n        if self.capacity <= 0:\n            return\n        #If the key already exists in the LFUCache\n        if key in self.keyfreq:\n            #Get the current frequency of the key\n            freq = self.keyfreq[key]\n            #Update the value of the key in its current frequency\n            self.freqkeys[freq][key] = value\n            #Call get method to update the frequency of the key\n            self.get(key)\n            return\n\n        #If the LFUCache is full, remove the least frequently used key\n        if self.capacity == len(self.keyfreq):\n            #Remove the least recently used key from the minfreq frequency\n            delkey, delval = self.freqkeys[self.minfreq].popitem(last=False)\n            #Remove the key from the keyfreq dictionary\n            del self.keyfreq[delkey]\n\n        #Add the new key-value pair with frequency 1\n        self.keyfreq[key] = 1\n        self.freqkeys[1][key] = value\n        #Update the minfreq to 1\n        self.minfreq = 1\n",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "//Back-end complete function Template for javascript\n\nclass LFUCache {\n    constructor(cap) {\n        this.capacity = cap;\n        this.minFreq = null;\n        this.keyFreq = new Map(); // Maps key to frequency\n        this.freqKeys =\n            new Map(); // Maps frequency to OrderedDict (Map preserving insertion order)\n    }\n\n    get(key) {\n        if (!this.keyFreq.has(key)) {\n            return -1;\n        }\n\n        let freq = this.keyFreq.get(key);\n        let val = this.freqKeys.get(freq).get(key);\n\n        this.freqKeys.get(freq).delete(key);\n        if (this.freqKeys.get(freq).size === 0) {\n            if (freq === this.minFreq) {\n                this.minFreq++;\n            }\n            this.freqKeys.delete(freq);\n        }\n\n        this.keyFreq.set(key, freq + 1);\n        if (!this.freqKeys.has(freq + 1)) {\n            this.freqKeys.set(freq + 1, new Map());\n        }\n        this.freqKeys.get(freq + 1).set(key, val);\n\n        return val;\n    }\n\n    put(key, value) {\n        if (this.capacity <= 0) {\n            return;\n        }\n\n        if (this.keyFreq.has(key)) {\n            this.freqKeys.get(this.keyFreq.get(key)).set(key, value);\n            this.get(key);\n            return;\n        }\n\n        if (this.keyFreq.size >= this.capacity) {\n            let minFreqKeys = this.freqKeys.get(this.minFreq);\n            let delKey = minFreqKeys.keys().next().value;\n            minFreqKeys.delete(delKey);\n\n            if (minFreqKeys.size === 0) {\n                this.freqKeys.delete(this.minFreq);\n            }\n            this.keyFreq.delete(delKey);\n        }\n\n        this.keyFreq.set(key, 1);\n        if (!this.freqKeys.has(1)) {\n            this.freqKeys.set(1, new Map());\n        }\n        this.freqKeys.get(1).set(key, value);\n        this.minFreq = 1;\n    }\n}",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}