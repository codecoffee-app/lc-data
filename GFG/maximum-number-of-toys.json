{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 708157,
            "title": "Maximum Number of Toys",
            "titleSlug": "maximum-number-of-toys",
            "content": "<p><span style=\"font-size:18px\">You are given <strong>N</strong> toys&nbsp;in a shop&nbsp;.<br />\r\nThe cost of each toy is represented by an array <strong>A[]</strong>. You are given Q queries, For ith&nbsp;query, You have a <strong>C</strong> amount of money which you can use to purchase the toys. Also there are K broken toys and you won&#39;t purchase them. The task is to calculate the maximum number of toys you can purchase using the C amount of money.</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Note:</strong> 1 based indexing is used. Each query is treated independently.&nbsp;<br />\r\nQuery definition: The first element represents an integer C where C=Queries[i][0].<br />\r\nThe second element represents an integer K, where K = Queries[i][1].<br />\r\nThe next K integers represent the indices of broken toys which are Queries[i][j] ,j&gt;1</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong>\r\nN = 5\r\nA[] = {8, 6, 9, 2, 5}\r\nQ = 2\r\nQuery[][] = {{12,2,3,4},{30,0}}\r\n<strong>Output:</strong>\r\n2 5\r\n<strong>Explanation:</strong>\r\n<strong>Query 1:</strong> C = 12, K = 2 , \r\nIndices of Broken toys is {3,4}\r\nIndices of Available toys are {1,2,5}\r\nIf we purchase the toys 2 and 5 , \r\nthen cost = A[2]+A[5]= 6+5 = 11,\r\nTherefore,We purchase the 2 toys \r\nusing 11 amount of money.\r\n<strong>Query 2:</strong> C = 30, K = 0\r\nThere is no broken toy. \r\nWe can purchase all toys,\r\ncost = A[1]+A[2]+A[3]+A[4]+A[5]= 30\r\nTherefore,We purchase the 5 toys\r\nusing 30 amount of money.</span>\r\n</pre>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 2:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong>\r\nN = 2\r\nA[] = {3,3}\r\nQ = 1\r\nQuery[][] = {{1,0}}\r\n<strong>Output:</strong>\r\n0\r\n<strong>Explanation:</strong>\r\n<strong>Query 1:</strong> C = 1, K = 0 , \r\nThere is no broken toy. \r\nWe have not enough amount to purchase \r\nany toy.\r\n</span></pre>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Your Task:&nbsp;</strong><br />\r\nYou don&#39;t need to read input or print anything. Your task is to complete the function<strong>&nbsp;maximumToys()</strong>&nbsp;which takes the integer&nbsp;<strong>N</strong>&nbsp;and array&nbsp;<strong>A[ ],&nbsp; </strong>integer<strong> Q </strong>and 2D array<strong>&nbsp;Queries[][]</strong>&nbsp;as input parameters&nbsp;and returns the array of answers of each query.</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong>&nbsp;O(NLogMx + Q*K*LogMx + Q*(LogMx)<sup>2</sup>)<br />\r\n<strong>Expected Auxiliary Space:</strong>&nbsp;O(Mx)<br />\r\nWhere Mx is the maximum element present in the array A[i].</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Constraints:</strong><br />\r\n1 &le;&nbsp;N &le;&nbsp;10<sup>5</sup><br />\r\n1 &le; A[i] &le;&nbsp;10<sup>6</sup><br />\r\n1 &le; Q&nbsp;&le;&nbsp;10<sup>4</sup></span><br />\r\n<span style=\"font-size:18px\">1 &le; C&nbsp;&le;&nbsp;10<sup>9</sup><br />\r\n0 &le; K&nbsp;&le;&nbsp;10<br />\r\n1 &le; Queries[i][j]&nbsp;&le; N, j&gt;1</span></p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given N toys in a shop, where the cost of each toy is represented by the array A[]. You are given Q queries. For each query, you have an amount C of money to purchase toys. Additionally, there are K broken toys that you cannot purchase. The task is to calculate the maximum number of toys you can purchase with the given amount C, excluding the broken toys. Note that each query is independent.",
                "constraints": [
                    "1 <= N <= 10^5",
                    "1 <= A[i] <= 10^6",
                    "1 <= Q <= 10^4",
                    "1 <= C <= 10^9",
                    "0 <= K <= 10",
                    "1 <= Queries[i][j] <= N, j > 1"
                ],
                "testcases": [
                    {
                        "input": "N = 5\nA[] = {8, 6, 9, 2, 5}\nQ = 2\nQuery[][] = {{12,2,3,4},{30,0}}",
                        "output": "2 5",
                        "explanation": "Query 1: C = 12, K = 2, broken toys are at indices 3 and 4. Available toys are at indices 1, 2, and 5 with costs 8, 6, and 5 respectively. Purchasing toys at indices 2 and 5 costs 6 + 5 = 11, allowing the purchase of 2 toys.\nQuery 2: C = 30, K = 0, no broken toys. Purchasing all toys costs 8 + 6 + 9 + 2 + 5 = 30, allowing the purchase of 5 toys."
                    },
                    {
                        "input": "N = 2\nA[] = {3,3}\nQ = 1\nQuery[][] = {{1,0}}",
                        "output": "0",
                        "explanation": "Query 1: C = 1, K = 0, no broken toys. However, the cost of even a single toy is 3, which exceeds the available money C = 1. Therefore, no toys can be purchased."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Use Fenwick tree.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [
            "google"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\n\nconst int N=1e6+5;\nint fr[N]; //array to store frequency of elements\n\nclass tree{\npublic:\n  vector<long long> bit; //Binary Indexed Tree\n  tree(){\n    bit=vector<long long>(N); //initialize BIT\n  }\n  void add(int node,int v)\n  {\n     for(;node<N;node+=(node&(-node)))\n      bit[node]+=v; //updating BIT by adding v to each element\n  }\n  long long get(int node)\n  {\n    long long x=0;\n    for(;node>0;node-=(node&(-node)))\n      x+=bit[node]; //sum of elements in BIT\n    return x;\n  }\n};\ntree obj1,obj2; //creating two instances of tree\n\nclass Solution{\npublic:\n  vector<int> maximumToys(int N,vector<int> A,int Q,vector<vector<int>> Queries){\n    vector<int> res;\n\n    for(auto i:A){\n      fr[i]++; //counting frequency of each element in A array\n    }\n\n    for(int i=0;i<A.size();i++){\n      obj1.add(A[i],A[i]); //adding elements to bit1\n      obj2.add(A[i],1); //adding 1 to bit2 for each element\n    }\n\n    for(auto i:Queries){\n      long long C=i[0]; //value of C\n      for(int j=2;j<i.size();j++){\n        obj1.add(A[i[j]-1],-A[i[j]-1]); //removing element from bit1\n        obj2.add(A[i[j]-1],-1); //decrementing 1 from bit2\n      }\n\n      long long lw=1,hg=1e6; //lower bound and higher bound\n      long long pos=1e6; //position\n      while(lw<=hg){\n        int mid=(lw+hg)/2;\n        if(obj1.get(mid)>=C){ //check if sum of elements till mid is greater or equal to C\n          pos=mid;\n          hg=mid-1;\n        }\n        else{\n          lw=mid+1;\n        }\n      }\n\n      long long ans=obj2.get(pos-1); //get sum till position-1 from bit2\n      long long mx=min((C-obj1.get(pos-1))/pos,(long long)fr[pos]); //find maximum possible sum\n      ans+=mx; //add maximum sum to ans\n      res.push_back(ans); //push answer to res\n      for(int j=2;j<i.size();j++){\n        obj1.add(A[i[j]-1],A[i[j]-1]); //add element back to bit1\n        obj2.add(A[i[j]-1],1); //add 1 to bit2\n      }\n    }\n    for(int i=0;i<A.size();i++){\n      obj1.add(A[i],-A[i]); //remove element from bit1\n      obj2.add(A[i],-1); //decrement 1 from bit2\n      fr[A[i]]--; //decrement frequency of element in fr array\n    }\n    return res; //return result\n  }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution {\r\n    int fr[]; //frequency array to store count of each element\r\n    \r\n    class tree{ //inner class to implement binary indexed tree\r\n        int N; //size of the tree\r\n        long bit[]; //array to store BIT\r\n        \r\n        tree(int N){ //constructor to create tree of given size\r\n            this.N = N;\r\n            bit = new long[N]; //initialize the bit array\r\n        }\r\n        \r\n        void add(int node, int v){ //function to add a value to the BIT\r\n            for(;node<N;node+=(node&(-node))) //loop through all the nodes in the BIT\r\n                bit[node]+=v; //add the value to each node\r\n        }\r\n        \r\n        long get(int node){ //function to get the value from the BIT\r\n            long x = 0l; //initialize a variable to store the sum\r\n            for(;node>0;node-=(node&(-node))) //loop through all the nodes in the BIT\r\n                x+=bit[node]; //add the value of each node to the sum\r\n            return x; //return the sum\r\n        }\r\n    }\r\n    \r\n    ArrayList<Integer> maximumToys(int N, int A[], int Q, ArrayList<Integer> Queries[]){\r\n        ArrayList<Integer> res = new ArrayList<>(); //initialize a list to store the results\r\n        fr = new int[1000 * 1000 + 5]; //initialize the frequency array\r\n        for(int x : A) fr[x]++; //count and store the frequency of each element\r\n        \r\n        tree obj1 = new tree(1000 * 1000 + 5); //create a new tree object for values\r\n        tree obj2 = new tree(1000 * 1000 + 5); //create a new tree object for counts\r\n        \r\n        for(int i=0;i<A.length;i++){ //loop through all the elements in the array\r\n          obj1.add(A[i],A[i]); //add the value of each element to the first tree\r\n          obj2.add(A[i],1); //add 1 to the count of each element in the second tree\r\n        }\r\n        \r\n        for(ArrayList<Integer> i :Queries){ //loop through all the queries\r\n            long C=i.get(0); //get the value of C from the query\r\n            for(int j=2;j<i.size();j++){ //loop through all the elements in the query\r\n                obj1.add(A[i.get(j)-1],-A[i.get(j)-1]); //subtract the value of each element from the first tree\r\n                obj2.add(A[i.get(j)-1],-1); //subtract 1 from the count of each element in the second tree\r\n            }\r\n            \r\n            int lw=1,hg=1000 * 1000; //initialize the lower and higher bounds\r\n            int pos=1000 * 1000; //initialize the position to a default value\r\n            while(lw<=hg){ //binary search to find the position of C\r\n                int mid=lw + (hg - lw)/2; //find the middle position\r\n                if(obj1.get(mid)>=C){ //if sum of values in the first tree is greater than or equal to C\r\n                    pos=mid; //update the position to the current middle position\r\n                    hg=mid-1; //update the higher bound to the current middle position - 1\r\n                }\r\n                else{\r\n                    lw=mid+1; //update the lower bound to the current middle position + 1\r\n                }\r\n            }\r\n            \r\n            long ans = obj2.get(pos - 1); //get the count of elements from the second tree at position pos - 1\r\n            long mx=Math.min((C-obj1.get(pos-1))/pos,(long)fr[pos]); //find the maximum number of elements that can be added to achieve sum C\r\n            ans+=mx; //add the maximum number of elements to the count\r\n            res.add((int)ans); //add the count to the results list\r\n            \r\n            for(int j=2;j<i.size();j++){ //loop through all the elements in the query\r\n                obj1.add(A[i.get(j)-1],A[i.get(j)-1]); //add the value of each element back to the first tree\r\n                obj2.add(A[i.get(j)-1],1); //add 1 to the count of each element in the second tree\r\n            }\r\n        }\r\n        return res; //return the results list\r\n    }\r\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "\r\n\r\nn=10**6+5\r\nfr=[0]*n\r\nclass tree:\r\n    def __init__(self) -> None:\r\n        self.bit=[0]*n\r\n    def add(self,node,v):\r\n        while node < n:\r\n            self.bit[node]+=v\r\n            #print(node,self.bit[node])\r\n            node+=node&(-node)\r\n    def get(self,node):\r\n        sumt=0\r\n        while node>0:\r\n            #print(self.bit[node], node)\r\n            sumt+=self.bit[node]\r\n            node-=node&(-node)\r\n        # print(sumt,'heelo')\r\n        return sumt\r\n\r\nt1,t2=tree(),tree()\r\nclass Solution:\r\n    def maximumToys(self,n,A,Q,Queries):\r\n      #code here\r\n        new=[]\r\n        for i in A:\r\n            fr[i]+=1\r\n        for i in A:\r\n            t1.add(i,i)\r\n            t2.add(i,1);\r\n        for i in Queries:\r\n            C=i[0]\r\n            for j in range(2,len(i)):\r\n                # print(\"x\", t1.bit[:10])\r\n                t1.add(A[i[j]-1],-A[i[j]-1])\r\n                # print(\"x\", t1.bit[:10])\r\n                t2.add(A[i[j]-1],-1);\r\n            lw,hg=1,10**6\r\n            pos=10**6\r\n            while(lw<=hg):\r\n                mid=(lw+hg)//2;\r\n                # print(t1.get(mid),mid,'hello i am here ')\r\n                if(t1.get(mid)>=C):\r\n                    pos=mid;\r\n                    hg=mid-1;\r\n                else:\r\n                    lw=mid+1;\r\n            # print(pos,'pos')\r\n            ans=t2.get(pos-1);\r\n            # print(ans)\r\n            mx=min((C-t1.get(pos-1))//pos,fr[pos]);\r\n            ans+=mx;\r\n            # print(ans,mx)\r\n            new.append(ans);\r\n            for j in range(2,len(i)):\r\n                t1.add(A[i[j]-1],A[i[j]-1]);\r\n                t2.add(A[i[j]-1],1);\r\n        for i in range(len(A)):\r\n            t1.add(A[i],-A[i]);\r\n            t2.add(A[i],-1);\r\n            fr[A[i]]-=1;\r\n        # print(t1.bit,t2.bit)\r\n        return new;",
                "lang_text": "py"
            }
        ],
        "platform": "GFG"
    }
}