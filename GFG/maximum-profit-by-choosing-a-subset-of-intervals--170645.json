{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 713370,
            "title": "Maximum Profit By Choosing A Subset Of Intervals",
            "titleSlug": "maximum-profit-by-choosing-a-subset-of-intervals--170645",
            "content": "<p><span style=\"font-size: 18px;\">Given a list&nbsp;<strong>intervals</strong>&nbsp;of&nbsp;<strong>n</strong>&nbsp;intervals, the&nbsp;<strong>ith</strong>&nbsp;element&nbsp;<strong>[s, e, p]</strong>&nbsp;denotes the starting point&nbsp;<strong>s</strong>, ending point&nbsp;<strong>e</strong>, and the profit&nbsp;<strong>p</strong>&nbsp;earned by choosing the&nbsp;<strong>ith</strong>&nbsp;interval. Find the maximum profit one can achieve by choosing a subset of non-overlapping intervals.</span></p>\n<p><span style=\"font-size: 18px;\">Two intervals&nbsp;<strong>[s1, e1, p1]</strong>&nbsp;and&nbsp;<strong>[s2, e2, p2]</strong>&nbsp;are said to be non-overlapping if&nbsp;<strong>[e1 &lt;= s2]</strong>&nbsp;and&nbsp;<strong>[s1 &lt; s2]</strong>.</span></p>\n<p><strong><span style=\"font-size: 18px;\">Example 1:</span></strong></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong></span>\n<span style=\"font-size: 18px;\">n = 3</span>\n<span style=\"font-size: 18px;\">intervals = {</span>\n<span style=\"font-size: 18px;\">{1, 2, 4},</span>\n<span style=\"font-size: 18px;\">{1, 5, 7},</span>\n<span style=\"font-size: 18px;\">{2, 4, 4}</span>\n<span style=\"font-size: 18px;\">}</span>\n<span style=\"font-size: 18px;\"><strong>Output:</strong></span>\n<span style=\"font-size: 18px;\">8</span>\n<span style=\"font-size: 18px;\"><strong>Explanation:</strong></span>\n<span style=\"font-size: 18px;\">One can choose intervals [1, 2, 4] and [2, 4, 4] for a \nprofit of 8.</span></pre>\n<p><strong><span style=\"font-size: 18px;\">Example 2:</span></strong></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong></span>\n<span style=\"font-size: 18px;\">n = 3</span>\n<span style=\"font-size: 18px;\">intervals = {</span>\n<span style=\"font-size: 18px;\">{1, 4, 4},</span>\n<span style=\"font-size: 18px;\">{2, 3, 7},</span>\n<span style=\"font-size: 18px;\">{2, 3, 4}</span>\n<span style=\"font-size: 18px;\">}</span>\n<span style=\"font-size: 18px;\"><strong>Output:</strong></span>\n<span style=\"font-size: 18px;\">7\n<strong>Explanation:\n</strong>One can choose interval&nbsp;<code>[2, 3, 7]</code>&nbsp;for a profit of&nbsp;<code>7</code>.</span></pre>\n<p><strong><span style=\"font-size: 18px;\">Your Task:</span></strong></p>\n<p><span style=\"font-size: 18px;\"><span style=\"font-size: 18px;\">You don't need to print or output anything. Complete the function </span><strong style=\"font-size: 18px;\">maximum_profit()&nbsp;</strong><span style=\"font-size: 18px;\">which takes an integer </span><strong style=\"font-size: 18px;\">n&nbsp;</strong><span style=\"font-size: 18px;\">and a 2D integer array </span><strong style=\"font-size: 18px;\">intervals&nbsp;</strong><span style=\"font-size: 18px;\">and returns an integer, denoting the maximum profit which one can get by choosing the non-overlapping intervals.</span><br /><br /><span style=\"color: #a5a5a5;\"><span style=\"font-size: 15px; background-color: #0a0e0f;\">Expected Time Complexity: O(nlogn)<br />Expected Space Complexity: O(n)</span></span></span></p>\n<p><strong><span style=\"font-size: 18px;\">Constraints:</span></strong></p>\n<ul>\n<li><span style=\"font-size: 18px;\">1 &lt;= n and n &lt;= 10<sup>4</sup></span></li>\n<li><span style=\"font-size: 18px;\">1 &lt;= starting point of <strong>ith</strong> interval &lt;&nbsp;ending point of <strong>ith</strong> interval &lt;= 10<sup>5</sup></span></li>\n<li><span style=\"font-size: 18px;\">1 &lt;= profit earned by choosing <strong>ith</strong> interval &lt;= 10<sup>5</sup></span></li>\n</ul>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a list of `n` intervals, where the `ith` interval is represented as `[s, e, p]` denoting the starting point `s`, ending point `e`, and profit `p`, find the maximum profit that can be achieved by selecting a subset of non-overlapping intervals. Two intervals `[s1, e1, p1]` and `[s2, e2, p2]` are considered non-overlapping if `e1 <= s2`.",
                "constraints": [
                    "1 <= n <= 10^4",
                    "1 <= starting point of ith interval < ending point of ith interval <= 10^5",
                    "1 <= profit earned by choosing ith interval <= 10^5"
                ],
                "testcases": [
                    {
                        "input": "n = 3\nintervals = {{\n{1, 2, 4},\n{1, 5, 7},\n{2, 4, 4}\n}}",
                        "output": "8",
                        "explanation": "By selecting the intervals [1, 2, 4] and [2, 4, 4], we achieve a total profit of 8. These intervals are non-overlapping since the ending point of the first interval (2) is less than or equal to the starting point of the second interval (2)."
                    },
                    {
                        "input": "n = 3\nintervals = {{\n{1, 4, 4},\n{2, 3, 7},\n{2, 3, 4}\n}}",
                        "output": "7",
                        "explanation": "By selecting the interval [2, 3, 7], we achieve a profit of 7.  Since we can only choose non-overlapping intervals, and [2,3,7] provides the highest profit, it's the optimal choice."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:14px\">Sort the array.</span></p>",
            "<p><span style=\"font-size:14px\">&nbsp;Use dynamic programming to keep track of the maximum at any <strong>ith</strong> interval.</span></p>"
        ],
        "relatedTopics": [],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "// Back-end complete function Template for C++\r\nclass Solution {\r\n  public:\r\n    int find_nearest_equal_or_greater(int start, int end, int value, int n,\r\n                                      vector<vector<int>> &intervals) {\r\n\r\n        // If nothing found, position will be n.\r\n        int position = n;\r\n        while (start <= end) {\r\n            int mid = (start + end) / 2;\r\n            if (intervals[mid][0] >= value) {\r\n                position = mid;\r\n                end = mid - 1;\r\n            } else {\r\n                start = mid + 1;\r\n            }\r\n        }\r\n\r\n        return position;\r\n    }\r\n\r\n    int maximum_profit_helper(int index, int n, vector<vector<int>> &intervals,\r\n                              vector<int> &dp) {\r\n        if (index >= n) {\r\n            return 0;\r\n        }\r\n\r\n        // `dp[index]` stores the maximum profit one can get by choosing\r\n        // non-overlapping intervals from `index` to `n - 1`.\r\n        if (dp[index] != -1) {\r\n            return dp[index];\r\n        }\r\n\r\n        int answer = maximum_profit_helper(index + 1, n, intervals, dp);\r\n        int new_index = find_nearest_equal_or_greater(\r\n            index + 1, n - 1, intervals[index][1], n, intervals);\r\n        answer =\r\n            max(answer, intervals[index][2] +\r\n                            maximum_profit_helper(new_index, n, intervals, dp));\r\n\r\n        return dp[index] = answer;\r\n    }\r\n\r\n    int maximum_profit(int n, vector<vector<int>> &intervals) {\r\n        sort(intervals.begin(), intervals.end());\r\n        vector<int> dp(n, -1);\r\n        return maximum_profit_helper(0, n, intervals, dp);\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution{\r\n    static int find_nearest_equal_or_greater(int start, int end, int value, int n,\r\n                                      int [][]intervals) {\r\n        // If nothing found, position will be n.\r\n        int position = n;\r\n        while (start <= end) {\r\n            int mid = (start + end) / 2;\r\n            if (intervals[mid][0] >= value) {\r\n                position = mid;\r\n                end = mid - 1;\r\n            } else {\r\n                start = mid + 1;\r\n            }\r\n        }\r\n\r\n        return position;\r\n    }\r\n\r\n    static int maximum_profit_helper(int index, int n, int [][] intervals,\r\n                              int []dp) {\r\n        if (index >= n) {\r\n            return 0;\r\n        }\r\n\r\n        // `dp[index]` stores the maximum profit one can get by choosing\r\n        // non-overlapping intervals from `index` to `n - 1`.\r\n        if (dp[index] != -1) {\r\n            return dp[index];\r\n        }\r\n\r\n        int answer = maximum_profit_helper(index + 1, n, intervals, dp);\r\n        int new_index = find_nearest_equal_or_greater(\r\n            index + 1, n - 1, intervals[index][1], n, intervals);\r\n        answer =\r\n            Math.max(answer, intervals[index][2] +\r\n                            maximum_profit_helper(new_index, n, intervals, dp));\r\n\r\n        return dp[index] = answer;\r\n    }\r\n\r\n    public static int maximum_profit(int n, int[][] intervals) {\r\n        Arrays.sort(intervals, new Comparator<int []>(){\r\n            public int compare(int [] a1, int [] a2){\r\n                if(a1[0] == a2[0]){\r\n                    if(a1[1] == a2[1])\r\n                        return a1[2] - a2[2];\r\n                    return a1[1] - a2[1];\r\n                }\r\n                return a1[0] - a2[0];\r\n            }\r\n        });\r\n        int[] dp = new int[n];\r\n        Arrays.fill(dp, -1);\r\n        return maximum_profit_helper(0, n, intervals, dp);\r\n    }\r\n\r\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "from typing import List\n\nmaxi = 10**5+2\nclass Solution:\n    #Function to calculate the maximum profit.\n    def maximum_profit(self, n : int, intervals : List[List[int]]) -> int:\n        #Sorting the intervals based on end time.\n        intervals.sort(key = lambda x:x[1])\n        \n        #Creating a dp array to store the maximum profit at each time index.\n        dp = [0]*maxi\n        \n        #Initializing index and i variables.\n        ind = 0\n        i = 1\n        \n        #Iterating through each time index.\n        while i < maxi:\n            #Updating the dp array by taking the maximum of current profit or previous profit.\n            dp[i] = max(dp[i], dp[i-1])\n            \n            #Checking if the current interval has the same end time as the current time index.\n            if ind < n and intervals[ind][1] == i:\n                #Getting the start time, end time, and value of the current interval.\n                st, en, val = intervals[ind]\n                \n                #Updating the dp array by taking the maximum of current profit or profit including the current interval.\n                dp[i] = max(dp[i], dp[st]+val)\n                \n                #Incrementing the index to move on to the next interval.\n                ind += 1\n                continue\n                \n            #Incrementing the time index.\n            i += 1\n        \n        #Returning the maximum profit at the last time index.\n        return dp[maxi-1]",
                "lang_text": "py"
            },
            {
                "lang": "Javascript",
                "full_func": "class Solution {\n    //Function to find the maximum profit.\n    maximum_profit(n, intervals) {\n        const maxi = 10**5+2;\n        \n        //Sorting the intervals based on end time.\n        intervals.sort((a, b) => a[1] - b[1]);\n        \n        //Creating a dp array to store the maximum profit at each time index.\n        const dp = Array(maxi).fill(0);\n        \n        //Initializing index and i variables.\n        let ind = 0;\n        let i = 1;\n        \n        //Iterating through each time index.\n        while (i < maxi) {\n            //Updating the dp array by taking the maximum of current profit or previous profit.\n            dp[i] = Math.max(dp[i], dp[i-1]);\n            \n            //Checking if the current interval has the same end time as the current time index.\n            if (ind < n && intervals[ind][1] === i) {\n                //Getting the start time, end time, and profit of the current interval.\n                const [st, en, val] = intervals[ind];\n                \n                //Updating the dp array by taking the maximum of current profit or profit including the current interval.\n                dp[i] = Math.max(dp[i], dp[st]+val);\n                \n                //Incrementing the index to move on to the next interval.\n                ind++;\n                continue;\n            }\n            \n            //Incrementing the time index.\n            i++;\n        }\n        \n        //Returning the maximum profit at the last time index.\n        return dp[maxi-1];\n    }\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}