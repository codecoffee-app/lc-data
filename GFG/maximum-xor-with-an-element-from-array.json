{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 712544,
            "title": "Maximum XOR With an Element From Array",
            "titleSlug": "maximum-xor-with-an-element-from-array",
            "content": "<p><span style=\"font-size: 18px;\">Given an array <strong>arr</strong> of size <strong>N</strong> consisting of non-negative integers. You are also given<strong> Q</strong>&nbsp;queries represented by 2D integer array <strong>queries</strong>, where <strong>queries[ i ] = [xi, mi].</strong><br />The answer to the <strong>i<sup>th</sup></strong>&nbsp;query is the <strong>maximum</strong> bitwise XOR value of <strong>x<sub>i</sub></strong>&nbsp;and any element of arr that does not exceed <strong>m<sub>i</sub></strong>. In other words, the answer is <strong>max(arr [ j ] XOR x<sub>i</sub>)</strong> for all<strong> j </strong>such that <strong>arr [ j ] &lt;= m<sub>i</sub></strong>&nbsp;. If all elements in nums are larger than mi&nbsp;, then answer is <strong>-1</strong>.<br />Return an integer array <strong>answer</strong> where<strong> answer [ i ]</strong> is the answer to the<strong> i<sup>th</sup></strong>&nbsp;query.</span></p>\n<p><strong><span style=\"font-size: 18px;\">Example 1:</span></strong></p>\n<div style=\"background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #222426; --darkreader-inline-border-top: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446;\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-bgimage=\"\" data-darkreader-inline-border-bottom=\"\" data-darkreader-inline-border-left=\"\" data-darkreader-inline-border-right=\"\" data-darkreader-inline-border-top=\"\"><span style=\"font-size: 18px;\"><strong>Input:</strong><br />N = 5<br />Q = 3<br />arr [ ] = {0, 1, 2, 3, 4}<br />queries [ ][ ] = {{3, 1}, {1, 3}, {5, 6}}<br /><strong>Output:</strong>&nbsp;{3, 3, 7}<br /><strong>Explanation:&nbsp;</strong><br />1.&nbsp;&nbsp;0 and 1 are the only two integers not greater than 1. <br />0 XOR 3 = 3 and 1 XOR 3 = 2.<br />The larger of the two is 3.<br />2.&nbsp;&nbsp;1 XOR 2 = 3.<br />3.&nbsp;&nbsp;5 XOR 2 = 7.</span></div>\n<p><br /><strong><span style=\"font-size: 18px;\">Example 2:</span></strong></p>\n<div style=\"background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #222426; --darkreader-inline-border-top: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446;\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-bgimage=\"\" data-darkreader-inline-border-bottom=\"\" data-darkreader-inline-border-left=\"\" data-darkreader-inline-border-right=\"\" data-darkreader-inline-border-top=\"\"><span style=\"font-size: 18px;\"><strong>Input:</strong><br />N = 6<br />Q = 3<br />arr [ ] = {5, 2, 4, 6, 6, 3}<br />queries [ ][ ] = {{12, 4}, {8, 1}, {6, 3}}<br /><strong>Output:</strong>&nbsp;{15, -1, 5}</span></div>\n<p><br /><span style=\"font-size: 18px;\"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>maximumXor()</strong>&nbsp;which takes the interger <strong>N</strong>,&nbsp;integer&nbsp;<strong>Q</strong>, integer array&nbsp;<strong>arr [ ]</strong> and 2D integer array <strong>queries [ ][ ]</strong>&nbsp;&nbsp;as parameters and returns integer array where, the <strong>i<sup>th</sup></strong>&nbsp;element is the answer to the ith&nbsp;query.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity</strong>:&nbsp;O(max(QlogQ, NlogN))<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(Q + N)</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; N, Q&nbsp;&le;&nbsp;10<sup>5</sup><br />0 &le; arr<sub>i</sub>&nbsp;, x<sub>i</sub>&nbsp;, m<sub>i</sub> &le; 10<sup>9</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [],
        "relatedTopics": [],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class node {\r\n  public:\r\n    node *left;  // 0\r\n    node *right; // 1\r\n};\r\nclass trie {\r\n    node *root;\r\n\r\n  public:\r\n    trie() { root = new node(); }\r\n    void insert(int n) {\r\n        node *temp = root;\r\n        for (int i = 31; i >= 0; i--) {\r\n            int bit = (n >> i) & 1;\r\n            if (bit == 0) {\r\n                if (temp->left == NULL) {\r\n                    temp->left = new node();\r\n                }\r\n                temp = temp->left;\r\n            } else {\r\n                if (temp->right == NULL) {\r\n                    temp->right = new node();\r\n                }\r\n                temp = temp->right;\r\n            }\r\n        }\r\n    }\r\n    long long max_XOR_helper(int value) {\r\n        long long current_ans = 0;\r\n        node *temp = root;\r\n        for (int j = 31; j >= 0; j--) {\r\n            int bit = (value >> j) & 1;\r\n            if (bit == 0) {\r\n                // find opp value\r\n                if (temp->right != NULL) {\r\n                    temp = temp->right;\r\n                    current_ans += (1 << j);\r\n                } else {\r\n                    temp = temp->left;\r\n                }\r\n            } else {\r\n                // look for a zero\r\n                if (temp->left != NULL) {\r\n                    temp = temp->left;\r\n                    current_ans += (1 << j);\r\n                } else {\r\n                    temp = temp->right;\r\n                }\r\n            }\r\n        }\r\n        return current_ans;\r\n    }\r\n};\r\nclass Solution {\r\n  public:\r\n    vector<long long> maximumXor(int N, int Q, vector<int> &arr,\r\n                                 vector<vector<int>> &queries) {\r\n        vector<long long> ans(Q);\r\n        vector<array<int, 3>> qry;\r\n        sort(arr.begin(), arr.end());\r\n        for (int i = 0; i < Q; i++) {\r\n            qry.push_back({queries[i][1], queries[i][0], i});\r\n        }\r\n        sort(qry.begin(), qry.end());\r\n        int j = 0;\r\n        trie tree;\r\n        for (int i = 0; i < Q; i++) {\r\n            while (j < arr.size() and arr[j] <= qry[i][0]) {\r\n                tree.insert(arr[j++]);\r\n            }\r\n            if (j == 0)\r\n                ans[qry[i][2]] = -1;\r\n            else\r\n                ans[qry[i][2]] = tree.max_XOR_helper(qry[i][1]);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\r\n\r\nclass Solution {\r\n   static class Node\r\n    {\r\n        Node trie[]=new Node[2];\r\n        Node()\r\n        {\r\n           trie[0]=null;\r\n           trie[1]=null;\r\n        }\r\n    }\r\n    \r\n   static void insert(Node root,int x)\r\n    {\r\n      for(int i=31;i>=0;i--)\r\n      {\r\n          int bit=((x>>i)&1);\r\n          if(root.trie[bit]==null)\r\n              root.trie[bit]=new Node();\r\n           root=root.trie[bit];\r\n      }\r\n    }\r\n  \r\n  static int fun(Node root,int x)\r\n  {\r\n    int ans=0;\r\n    for(int i=31;i>=0;i--)\r\n    {\r\n        int bit=((x>>i)&1);\r\n        if(root.trie[bit^1]!=null)\r\n        {\r\n            ans|=(1<<i);\r\n            root=root.trie[bit^1];\r\n        }\r\n      else\r\n       {\r\n          root=root.trie[bit];\r\n       }  \r\n    }\r\n return ans;\r\n  }\r\n    static int[] maximumXor(int N, int Q, int a[],int q[][]) {\r\n        int n=a.length;\r\n        Arrays.sort(a);\r\n        int ql=q.length;\r\n        int t[][]=new int[ql][3];\r\n        for(int i=0;i<ql;i++)\r\n        {\r\n          t[i][0]=q[i][0];\r\n          t[i][1]=q[i][1];\r\n          t[i][2]=i;\r\n        }\r\n        Node root=new Node();\r\n        Arrays.sort(t,(x,y)->(x[1]-y[1]));\r\n        int ans[]=new int[ql]; Arrays.fill(ans,-1);\r\n        int ind=0;\r\n        for(int i=0;i<ql;i++)\r\n        {\r\n          int x=t[i][0];\r\n          int y=t[i][1];\r\n          while(ind<n && a[ind]<=y)\r\n              insert(root,a[ind++]);\r\n            \r\n          if(ind!=0)\r\n          {\r\n              int val=fun(root,x);\r\n              ans[t[i][2]]=val;\r\n          }\r\n        }\r\n        return ans;\r\n    }\r\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\r\n\r\nfrom bisect import bisect_left, bisect_right\r\nclass Solution:\r\n    def maximumXor(self, N, Q, nums, queries):\r\n        nums.sort()\r\n        answer = []\r\n        for x, m in queries:\r\n            start, stop = 0, bisect_right(nums, m)\r\n            num = 0\r\n            for i in range(30)[::-1]:\r\n                cut = bisect_left(nums, num + (1<<i), start, stop)\r\n                if cut > start and (x & (1<<i)):\r\n                    stop = cut\r\n                elif cut < stop:\r\n                    start = cut\r\n                    num += (1<<i)\r\n            answer.append(num ^ x if start < stop else -1)\r\n        return answer",
                "lang_text": "python3"
            },
            {
                "lang": "Javascript",
                "full_func": "class Solution\n{\n    //Function to return the maximum XOR value.\n    maximumXor(N, Q, arr, queries)\n    {\n        arr.sort((a, b) => a - b); // sorting the array in ascending order\n        let answer = [];\n        for(let i=0;i<Q;i++){\n            let x = queries[i][0];\n            let m = queries[i][1];\n            let start = 0, stop = this.bisectRight(arr, m, 0, N);\n            let num = 0;\n            for(let j=30;j>=0;j--){\n                let cut = this.bisectLeft(arr, num + (1<<j), start, stop);\n                if(cut > start && (x & (1<<j))){\n                    stop = cut;\n                }else if(cut < stop){\n                    start = cut;\n                    num += (1<<j);\n                }\n            }\n            answer.push(start < stop ? num ^ x : -1);\n        }\n        return answer;\n    }\n    \n    bisectRight(arr, target, start, end){\n        while(start < end){\n            let mid = Math.floor((start+end)/2);\n            if(arr[mid] <= target){\n                start = mid + 1;\n            }else{\n                end = mid;\n            }\n        }\n        return start;\n    }\n    \n    bisectLeft(arr, target, start, end){\n        while(start < end){\n            let mid = Math.floor((start+end)/2);\n            if(arr[mid] < target){\n                start = mid + 1;\n            }else{\n                end = mid;\n            }\n        }\n        return start;\n    }\n}",
                "lang_text": "javascript"
            },
            {
                "lang": "C#",
                "full_func": "class Node\n{\n    public Node Left;  // 0\n    public Node Right; // 1\n}\n\nclass Trie\n{\n    private Node root;\n\n    public Trie()\n    {\n        root = new Node();\n    }\n\n    public void Insert(int n)\n    {\n        Node temp = root;\n        for (int i = 31; i >= 0; i--)\n        {\n            int bit = (n >> i) & 1;\n            if (bit == 0)\n            {\n                if (temp.Left == null)\n                {\n                    temp.Left = new Node();\n                }\n                temp = temp.Left;\n            }\n            else\n            {\n                if (temp.Right == null)\n                {\n                    temp.Right = new Node();\n                }\n                temp = temp.Right;\n            }\n        }\n    }\n\n    public long MaxXorHelper(int value)\n    {\n        long currentAns = 0;\n        Node temp = root;\n        for (int j = 31; j >= 0; j--)\n        {\n            int bit = (value >> j) & 1;\n            if (bit == 0)\n            {\n                // find opposite value\n                if (temp.Right != null)\n                {\n                    temp = temp.Right;\n                    currentAns += (1 << j);\n                }\n                else\n                {\n                    temp = temp.Left;\n                }\n            }\n            else\n            {\n                // look for a zero\n                if (temp.Left != null)\n                {\n                    temp = temp.Left;\n                    currentAns += (1 << j);\n                }\n                else\n                {\n                    temp = temp.Right;\n                }\n            }\n        }\n        return currentAns;\n    }\n}\n\npublic class Solution\n{\n    public List<long> maximumXor(int N, int Q, List<int> arr, List<List<int>> queries)\n    {\n        List<long> ans = new List<long>(Q);\n        for (int i = 0; i < Q; i++)\n        {\n            ans.Add(0); // Initialize 'ans' with default value 0\n        }\n\n        List<int[]> qry = new List<int[]>();\n\n        arr.Sort();\n\n        for (int i = 0; i < Q; i++)\n        {\n            qry.Add(new int[] { queries[i][1], queries[i][0], i });\n        }\n\n        qry.Sort((a, b) => a[0].CompareTo(b[0]));\n\n        int j = 0;\n        Trie tree = new Trie();\n\n        for (int i = 0; i < Q; i++)\n        {\n            while (j < arr.Count && arr[j] <= qry[i][0])\n            {\n                tree.Insert(arr[j++]);\n            }\n\n            if (j == 0)\n                ans[qry[i][2]] = -1;\n            else\n                ans[qry[i][2]] = tree.MaxXorHelper(qry[i][1]);\n        }\n\n        return ans;\n    }\n}",
                "lang_text": "csharp"
            }
        ],
        "platform": "GFG"
    }
}