{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 885632,
            "title": "Meeting Rooms III",
            "titleSlug": "meeting-rooms-iii",
            "content": "<p>You are given an integer <strong>n</strong> representing the number of rooms numbered from <strong>0</strong> to <strong>n - 1</strong>. Additionally, you are given a 2D integer array <strong>meetings[][]</strong> where <strong>meetings[i]</strong> = <strong>[start<sub>i</sub>, end<sub>i</sub>]</strong> indicates that a meeting is scheduled during the half-closed time interval <strong>[start<sub>i</sub>, end<sub>i</sub>)</strong>. All start<sub>i</sub> values are unique.</p>\n<p>Meeting Allocation Rules:</p>\n<ul>\n<li>When a meeting starts, assign it to the available room with the smallest number.</li>\n<li>If no rooms are free, delay the meeting until the earliest room becomes available. The delayed meeting retains its original duration.</li>\n<li>When a room becomes free, assign it to the delayed meeting with the earliest original start time.</li>\n</ul>\n<p>Determine the room number that hosts the most meetings. If multiple rooms have the same highest number of meetings, return the smallest room number among them.</p>\n<p><strong>Examples:</strong></p>\n<pre><strong>Input: </strong>n = 2, meetings[][] = [[0, 6], [2, 3], [3, 7], [4, 8], [6, 8]]<strong>\nOutput:</strong> 1<strong>\nExplanation:\n</strong>Time 0: Both rooms available. [0,6] starts in room 0.\nTime 2: Room 0 busy until 6. Room 1 available. [2,3] starts in room 1.\nTime 3: Room 1 frees up. [3,7] starts in room 1.\nTime 4: Both rooms busy. [4,8] is delayed.\nTime 6: Room 0 frees up. Delayed [4,8] starts in room 0 [6,10).\nTime 6: [6,8] arrives but both rooms busy. It&rsquo;s delayed.\nTime 7: Room 1 frees up. Delayed [6,8] starts in room 1 [7,9).<br /><br />Meeting counts: [2, 3]</pre>\n<pre><strong>Input: </strong>n = 4, meetings[][] = [[0, 8], [1, 4], [3, 4], [2, 3]<strong>\nOutput: </strong>2<strong>\nExplanation:\n</strong>Time 0: All rooms available. [0,8] starts in room 0.\nTime 1: Room 0 busy until 8. Rooms 1, 2, 3 available. [1,4] starts in room 1.\nTime 2: Rooms 0 and 1 busy. Rooms 2, 3 available. [2,3] starts in room 2.\nTime 3: Room 2 frees up. [3,4] starts in room 2.<br />\nMeeting counts: [1, 1, 2, 0]</pre>\n<p><strong>Constraints:</strong></p>\n<ul>\n<li>1 &lt;= n &lt;= 10<sup>4</sup></li>\n<li>1 &lt;= meetings.size() &lt;= 10<sup>4</sup></li>\n<li>meetings[i].size() == 2</li>\n<li>0 &lt;= start<sub>i&nbsp;</sub>&lt; end<sub>i&nbsp;</sub>&lt;= 10<sup>4</sup></li>\n</ul>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "You are given an integer `n` representing the number of rooms numbered from 0 to `n - 1`. You are also given a 2D integer array `meetings` where `meetings[i] = [start_i, end_i]` indicates that a meeting is scheduled during the half-closed time interval `[start_i, end_i)`. All `start_i` values are unique.\n\nMeeting Allocation Rules:\n\n*   When a meeting starts, assign it to the available room with the smallest number.\n*   If no rooms are free, delay the meeting until the earliest room becomes available. The delayed meeting retains its original duration.\n*   When a room becomes free, assign it to the delayed meeting with the earliest original start time.\n\nDetermine the room number that hosts the most meetings. If multiple rooms have the same highest number of meetings, return the smallest room number among them.",
                "constraints": [
                    "1 <= n <= 10^4",
                    "1 <= meetings.length <= 10^4",
                    "meetings[i].length == 2",
                    "0 <= start_i < end_i <= 10^4"
                ],
                "testcases": [
                    {
                        "input": "n = 2, meetings = [[0, 6], [2, 3], [3, 7], [4, 8], [6, 8]]",
                        "output": "1",
                        "explanation": "Initially, both rooms are available. The meeting [0, 6] is assigned to room 0. At time 2, room 0 is busy. The meeting [2, 3] is assigned to room 1. At time 3, room 1 becomes available. The meeting [3, 7] is assigned to room 1. At time 4, both rooms are busy, so the meeting [4, 8] is delayed. At time 6, room 0 becomes available. The delayed meeting [4, 8] is assigned to room 0 and becomes [6, 10). The meeting [6, 8] arrives but both rooms are busy and it is delayed. At time 7, room 1 becomes available and the delayed meeting [6, 8] is assigned to room 1 and becomes [7, 9). Room 1 hosts the most meetings (3), while room 0 hosts 2 meetings."
                    },
                    {
                        "input": "n = 4, meetings = [[0, 8], [1, 4], [3, 4]]",
                        "output": "0",
                        "explanation": "Initially, all rooms are available. The meeting [0, 8] is assigned to room 0. At time 1, room 0 is busy. The meeting [1, 4] is assigned to room 1. At time 3, room 0 and room 1 are still busy, hence [3, 4] will be assigned to the first available room, which is room 2 in this case. Meeting counts: Room 0 = 1, Room 1 = 1, Room 2 = 1. The room with smallest number of meetings is room 0."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Use two simple priority queues:</p>\n<ul>\n<li>The first queue holds all the room numbers that are available.</li>\n<li>The second queue keeps track of when each meeting will finish and which room it&rsquo;s using.</li>\n</ul>"
        ],
        "relatedTopics": [
            {
                "name": "Heap",
                "slug": "heap"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "priority-queue",
                "slug": "priority-queue"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\nclass Solution {\n  public:\n    int mostBooked(int n, vector<vector<int>> &meetings) {\n        vector<int> cnt(n, 0); // Count of meetings per room\n        // Min-heap for occupied rooms: (end time, room number)\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>\n            occ;\n        // Min-heap for available rooms: room numbers\n        priority_queue<int, vector<int>, greater<int>> avail;\n\n        // Initialize all rooms as available\n        for (int i = 0; i < n; ++i)\n            avail.push(i);\n\n        // Sort meetings by start time\n        sort(meetings.begin(), meetings.end());\n\n        for (auto &m : meetings) {\n            int s = m[0], e = m[1];\n\n            // Release rooms that have become available by time s\n            while (!occ.empty() && occ.top().first <= s) {\n                avail.push(occ.top().second);\n                occ.pop();\n            }\n\n            if (!avail.empty()) {\n                // Assign to the smallest available room\n                int r = avail.top();\n                avail.pop();\n                occ.push({e, r});\n                cnt[r]++;\n            } else {\n                // All rooms are occupied; assign to the room that becomes free earliest\n                int t = occ.top().first;\n                int r = occ.top().second;\n                occ.pop();\n                occ.push({t + (e - s), r});\n                cnt[r]++;\n            }\n        }\n\n        // Find the room with the maximum number of meetings\n        int maxCnt = 0, res = 0;\n        for (int i = 0; i < n; ++i) {\n            if (cnt[i] > maxCnt) {\n                maxCnt = cnt[i];\n                res = i;\n            }\n        }\n\n        return res;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\nclass Solution {\n    public int mostBooked(int n, int[][] meetings) {\n        int[] cnt = new int[n]; // Count of meetings per room\n\n        // PriorityQueue for occupied rooms: (end time, room number)\n        PriorityQueue<int[]> occ = new PriorityQueue<>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                if (a[0] != b[0]) {\n                    return Integer.compare(a[0], b[0]); // Compare by end time\n                }\n                return Integer.compare(\n                    a[1], b[1]); // If end times are equal, compare by room number\n            }\n        });\n\n        // PriorityQueue for available rooms: room numbers\n        PriorityQueue<Integer> avail = new PriorityQueue<>();\n        for (int i = 0; i < n; i++) {\n            avail.offer(i);\n        }\n\n        // Sort meetings by start time, then by end time if start times are equal\n        Arrays.sort(meetings, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                if (a[0] != b[0]) {\n                    return Integer.compare(a[0], b[0]);\n                }\n                return Integer.compare(a[1], b[1]);\n            }\n        });\n\n        for (int[] m : meetings) {\n            int s = m[0]; // Start time\n            int e = m[1]; // End time\n\n            // Release all rooms that have become available by time s\n            while (!occ.isEmpty() && occ.peek()[0] <= s) {\n                avail.offer(occ.poll()[1]);\n            }\n\n            if (!avail.isEmpty()) {\n                // Assign to the smallest available room\n                int r = avail.poll();\n                occ.offer(new int[] {e, r});\n                cnt[r]++;\n            } else {\n                // All rooms are occupied; assign to the room that becomes free earliest\n                int[] earliest = occ.poll();\n                int t = earliest[0];\n                int r = earliest[1];\n                occ.offer(new int[] {t + (e - s), r});\n                cnt[r]++;\n            }\n        }\n\n        // Find the room with the maximum number of meetings\n        int maxCnt = 0;\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (cnt[i] > maxCnt) {\n                maxCnt = cnt[i];\n                res = i;\n            }\n        }\n\n        return res;\n    }\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\nclass Solution:\n\n    def mostBooked(self, n, meetings):\n        cnt = [0] * n  # Count of meetings per room\n        # Min-heap for occupied rooms: (end time, room number)\n        occ = []\n        # Min-heap for available rooms: room numbers\n        avail = list(range(n))\n        heapq.heapify(avail)\n\n        # Sort meetings by start time\n        meetings.sort()\n\n        for m in meetings:\n            s, e = m\n\n            # Release rooms that have become available by time s\n            while occ and occ[0][0] <= s:\n                end_time, room = heapq.heappop(occ)\n                heapq.heappush(avail, room)\n\n            if avail:\n                # Assign to the smallest available room\n                r = heapq.heappop(avail)\n                heapq.heappush(occ, (e, r))\n                cnt[r] += 1\n            else:\n                # All rooms are occupied; assign to the room that becomes free earliest\n                t, r = heapq.heappop(occ)\n                heapq.heappush(occ, (t + (e - s), r))\n                cnt[r] += 1\n\n        # Find the room with the maximum number of meetings\n        maxCnt = 0\n        res = 0\n        for i in range(n):\n            if cnt[i] > maxCnt:\n                maxCnt = cnt[i]\n                res = i\n\n        return res\n",
                "lang_text": "py"
            },
            {
                "lang": "Javascript",
                "full_func": "//Back-end complete function Template for javascript\nclass PriorityQueue {\n    constructor(comparator = (a, b) => a > b) {\n        this.heap = [];\n        this.comparator = comparator;\n    }\n\n    size() { return this.heap.length; }\n\n    peek() { return this.heap[0]; }\n\n    push(value) {\n        this.heap.push(value);\n        this._heapifyUp();\n    }\n\n    pop() {\n        const top = this.peek();\n        const bottom = this.heap.pop();\n        if (this.heap.length > 0) {\n            this.heap[0] = bottom;\n            this._heapifyDown();\n        }\n        return top;\n    }\n\n    _heapifyUp() {\n        let index = this.heap.length - 1;\n        while (index > 0) {\n            let parent = Math.floor((index - 1) / 2);\n            if (this.comparator(this.heap[index], this.heap[parent])) {\n                [this.heap[index], this.heap[parent]] =\n                    [ this.heap[parent], this.heap[index] ];\n                index = parent;\n            } else {\n                break;\n            }\n        }\n    }\n\n    _heapifyDown() {\n        let index = 0;\n        const length = this.heap.length;\n        while (true) {\n            let left = 2 * index + 1;\n            let right = 2 * index + 2;\n            let target = index;\n\n            if (left < length && this.comparator(this.heap[left], this.heap[target])) {\n                target = left;\n            }\n\n            if (right < length &&\n                this.comparator(this.heap[right], this.heap[target])) {\n                target = right;\n            }\n\n            if (target !== index) {\n                [this.heap[index], this.heap[target]] =\n                    [ this.heap[target], this.heap[index] ];\n                index = target;\n            } else {\n                break;\n            }\n        }\n    }\n}\n\nclass Solution {\n    mostBooked(n, meetings) {\n        const cnt = new Array(n).fill(0);\n\n        // Priority Queue for occupied rooms: [end time, room number]\n        const occ = new PriorityQueue((a, b) => {\n            if (a[0] !== b[0]) {\n                return a[0] < b[0]; // Earlier end time first\n            }\n            return a[1] < b[1]; // If end times are equal, smaller room number first\n        });\n\n        // Priority Queue for available rooms: room numbers\n        const avail = new PriorityQueue((a, b) => a < b); // Smaller room number first\n        for (let i = 0; i < n; i++) {\n            avail.push(i);\n        }\n\n        // Sort meetings by start time, then by end time\n        meetings.sort((a, b) => {\n            if (a[0] !== b[0]) {\n                return a[0] - b[0];\n            }\n            return a[1] - b[1];\n        });\n\n        for (const m of meetings) {\n            let s = m[0];\n            let e = m[1];\n\n            // Release all rooms that have become available by time s\n            while (occ.size() > 0 && occ.peek()[0] <= s) {\n                let room = occ.pop()[1];\n                avail.push(room);\n            }\n\n            if (avail.size() > 0) {\n                // Assign to the smallest available room\n                let r = avail.pop();\n                occ.push([ e, r ]);\n                cnt[r]++;\n            } else {\n                // All rooms are occupied; assign to the room that becomes free earliest\n                let earliest = occ.pop();\n                let t = earliest[0];\n                let r = earliest[1];\n                occ.push([ t + (e - s), r ]);\n                cnt[r]++;\n            }\n        }\n\n        // Find the room with the maximum number of meetings\n        let maxCnt = 0;\n        let res = 0;\n        for (let i = 0; i < n; i++) {\n            if (cnt[i] > maxCnt) {\n                maxCnt = cnt[i];\n                res = i;\n            }\n        }\n\n        return res;\n    }\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}