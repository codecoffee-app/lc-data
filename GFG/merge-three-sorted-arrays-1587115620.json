{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 701244,
            "title": "Merge three sorted arrays",
            "titleSlug": "merge-three-sorted-arrays-1587115620",
            "content": "<p><span style=\"font-size:18px\">Given three sorted arrays <strong>A</strong>, <strong>B</strong> and <strong>C</strong> of size <strong>N</strong>, <strong>M</strong> and <strong>P</strong> respectively. The task is to merge them into a single array which must be sorted in increasing order.</span><br />\n<br />\n<span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\n\n<pre>\n<span style=\"font-size:18px\"><strong>Input</strong>: \nN = 4, A[] = [1 2 3 4] \nM = 5, B[] = [1 2 3 4 5] \nP = 6, C[] = [1 2 3 4 5 6]\n<strong>Output</strong>: 1 1 1 2 2 2 3 3 3 4 4 4 5 5 6\n<strong>Explanation</strong>: Merging these three sorted \narrays, we have: \n1 1 1 2 2 2 3 3 3 4 4 4 5 5 6.</span></pre>\n\n<p><span style=\"font-size:18px\"><strong>Example 2:</strong></span></p>\n\n<pre>\n<span style=\"font-size:18px\"><strong>Input</strong>: \nN = 2, A[] = [1 2]\nM = 3, B[] = [2 3 4] \nP = 4, C[] = [4 5 6 7]\n<strong>Output</strong>: 1 2 2 3 4 4 5 6 7\n<strong>Explanation</strong>: Merging three sorted arrays, \nwe have: 1 2 2 3 4 4 5 6 7.</span></pre>\n\n<p><br />\n<span style=\"font-size:18px\"><strong>Your Task:</strong><br />\nThis is a function problem. You only need to complete the function<strong> mergeThree()&nbsp;</strong>that takes <strong>A,B,C as parameters</strong>. The function <strong>returns </strong>an <strong>array </strong>or <strong>vector</strong>.</span><br />\n<br />\n<span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong>&nbsp;O(N + M + P)<br />\n<strong>Expected Auxiliary Space:</strong>&nbsp;O(N + M + P) for the resultant array only.</span><br />\n<br />\n<span style=\"font-size:18px\"><strong>Constraints:</strong><br />\n1 &lt;= N, M, P &lt;= 10<sup>6</sup><br />\n1 &lt;= A[i], B[i], C[i] &lt;= 10<sup>6</sup></span></p>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given three sorted arrays A, B, and C of sizes N, M, and P respectively, merge them into a single sorted array in increasing order.",
                "constraints": [
                    "1 <= N, M, P <= 10^6",
                    "1 <= A[i], B[i], C[i] <= 10^6"
                ],
                "testcases": [
                    {
                        "input": "N = 4, A = [1, 2, 3, 4]\nM = 5, B = [1, 2, 3, 4, 5]\nP = 6, C = [1, 2, 3, 4, 5, 6]",
                        "output": "[1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 6]",
                        "explanation": "The merged and sorted array of A, B, and C is [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 6]."
                    },
                    {
                        "input": "N = 2, A = [1, 2]\nM = 3, B = [2, 3, 4]\nP = 4, C = [4, 5, 6, 7]",
                        "output": "[1, 2, 2, 3, 4, 4, 5, 6, 7]",
                        "explanation": "The merged and sorted array of A, B, and C is [1, 2, 2, 3, 4, 4, 5, 6, 7]."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            ""
        ],
        "relatedTopics": [
            {
                "name": "Arrays",
                "slug": "arrays"
            },
            {
                "name": "Sorting",
                "slug": "sorting"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C",
                "full_func": "//Back-end complete function Template for C\n\n//Function to merge three sorted vectors or arrays \n//into a single vector or array.\n// A, B, and C: input sorted arrays\n// n, m, and p: size of A, B, C respectively\nint* mergeThree(int *A,int *B,int *C,int n,int m,int p) \n{ \n    int *D;\n\tD = (int*)malloc((n+m+p) * sizeof(int));\n\tint i,j,k,z;\n\ti = j = k = z= 0; \n        \n    //Using three pointers over the three vectors which helps in choosing\n    //and storing the smallest element in the output vector.\n    while (i < n && j < m && k < p) { \n\n        //Finding minimum of A[i], B[j] and C[k].\n        int minn = A[i]<B[j]?(A[i]<C[k]?A[i]:C[k]):(B[j]<C[k]?B[j]:C[k]); \n\n        //We store the minimum value in output vector. \n        D[z]=minn; \n        z++;\n        //Incrementing the pointer which had the minimum value.\n        if (minn == A[i]) \n            i++; \n        else if (minn == B[j]) \n            j++; \n        else\n            k++; \n    } \n    \n\n    //If C has exhausted(its pointer has crossed last element) then \n    //we continue storing the minimum values from other two vectors.\n    while (i < n && j < m) { \n        if (A[i] <= B[j]) { \n            D[z]=A[i]; \n            i++; \n        } \n        else { \n            D[z]=B[j]; \n            j++; \n        } \n        z++;\n    } \n    \n    //If B has exhausted(its pointer has crossed last element) then\n    //we continue storing the minimum values from other two vectors. \n    while (i < n && k < p) { \n        if (A[i] <= C[k]) { \n            D[z]=A[i]; \n            i++; \n        } \n        else { \n            D[z]=C[k]; \n            k++; \n        } \n        z++;\n    } \n\n    //If A has exhausted(its pointer has crossed last element) then \n    //we continue storing the minimum values from other two vectors.\n    while (j < m && k < p) { \n        if (B[j] <= C[k]) { \n            D[z]=B[j]; \n            j++; \n        } \n        else { \n            D[z]=C[k]; \n            k++; \n        } \n        z++;\n    } \n\n    //If A and B have exhausted(their pointer has crossed last element) then\n    //we continue storing the minimum values from the last vector C.\n    while (k < p) \n        D[z++]=C[k++]; \n\n    //If B and C have exhausted(their pointer has crossed last element) then\n    //we continue storing the minimum values from the last vector A.\n    while (i < n) \n        D[z++]=A[i++]; \n\n    //If A and C have exhausted(their pointer has crossed last element) then\n    //we continue storing the minimum values from the last vector B.\n    while (j < m) \n        D[z++]=B[j++]; \n        \n    //returning the resultant vector.\n    return D; \n    \n} \n",
                "lang_text": "c"
            },
            {
                "lang": "C++",
                "full_func": "class Solution{\n  public:\n\n    //Function to merge three sorted vectors or arrays \n    //into a single vector or array.\n    vector<int> mergeThree(vector<int>& A, vector<int>& B, vector<int>& C) \n    { \n        int m, n, o, i, j, k; \n        //Storing the size of the three vectors. \n        m = A.size(); \n        n = B.size(); \n        o = C.size(); \n    \n        //Creating a vector for storing output.\n        vector<int> D; \n        D.reserve(m + n + o); \n    \n        i = j = k = 0; \n        \n        //Using three pointers over the three vectors which helps in choosing\n        //and storing the smallest element in the output vector.\n        while (i < m && j < n && k < o) { \n    \n            //Finding minimum of A[i], B[j] and C[k].\n            int minn = min(min(A[i], B[j]), C[k]); \n    \n            //We store the minimum value in output vector. \n            D.push_back(minn); \n    \n            //Incrementing the pointer which had the minimum value.\n            if (minn == A[i]) \n                i++; \n            else if (minn == B[j]) \n                j++; \n            else\n                k++; \n        } \n    \n        //If C has exhausted(its pointer has crossed last element) then \n        //we continue storing the minimum values from other two vectors.\n        while (i < m && j < n) { \n            if (A[i] <= B[j]) { \n                D.push_back(A[i]); \n                i++; \n            } \n            else { \n                D.push_back(B[j]); \n                j++; \n            } \n        } \n    \n        //If B has exhausted(its pointer has crossed last element) then\n        //we continue storing the minimum values from other two vectors. \n        while (i < m && k < o) { \n            if (A[i] <= C[k]) { \n                D.push_back(A[i]); \n                i++; \n            } \n            else { \n                D.push_back(C[k]); \n                k++; \n            } \n        } \n    \n        //If A has exhausted(its pointer has crossed last element) then \n        //we continue storing the minimum values from other two vectors.\n        while (j < n && k < o) { \n            if (B[j] <= C[k]) { \n                D.push_back(B[j]); \n                j++; \n            } \n            else { \n                D.push_back(C[k]); \n                k++; \n            } \n        } \n    \n        //If A and B have exhausted(their pointer has crossed last element) then\n        //we continue storing the minimum values from the last vector C.\n        while (k < o) \n            D.push_back(C[k++]); \n    \n        //If B and C have exhausted(their pointer has crossed last element) then\n        //we continue storing the minimum values from the last vector A.\n        while (i < m) \n            D.push_back(A[i++]); \n    \n        //If A and C have exhausted(their pointer has crossed last element) then\n        //we continue storing the minimum values from the last vector B.\n        while (j < n) \n            D.push_back(B[j++]); \n        \n        //returning the resultant vector.\n        return D; \n    } \n\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\nclass Solution\n{\n    //Function to merge three sorted lists into a single list.\n    static ArrayList<Integer> merge3sorted(int A[], int B[], int C[])\n    {\n        //Storing the size of the three lists.\n        int m = A.length;\n        int n = B.length;\n        int o = C.length;\n        \n        int i = 0, j = 0, k = 0;\n        \n        //Creating a list for storing output.\n        ArrayList<Integer> list = new ArrayList<>();\n        \n        //Using three pointers over the three lists which helps in choosing\n        //and storing the smallest element in the output list.\n        while(i < m && j < n && k < o)\n        {\n            //Finding minimum of A[i], B[j] and C[k].\n            int min = Math.min(Math.min(A[i], B[j]), C[k]);\n            \n            //We store the minimum value in output list. \n            list.add(min);\n            \n            //Incrementing the pointer which had the minimum value.\n            if(min == A[i])\n              i++;\n            else if(min == B[j])\n                 j++;\n            else if(min == C[k])\n                 k++;\n        }\n        \n        //If C has exhausted(its pointer has crossed last element) then \n        //we continue storing the minimum values from other two lists.\n        while(i < m && j < n)\n        {\n            if(A[i] <= B[j])\n            {\n                list.add(A[i]);\n                i++;\n            }\n            else\n            {\n                list.add(B[j]);\n                j++;\n            }\n        }\n        \n        //If B has exhausted(its pointer has crossed last element) then \n        //we continue storing the minimum values from other two lists.\n        while(i < m && k < o)\n        {\n            if(A[i] <= C[k])\n            {\n                list.add(A[i]);\n                i++;\n            }\n            else\n            {\n                list.add(C[k]);\n                k++;\n            }\n        }\n        \n        //If A has exhausted(its pointer has crossed last element) then \n        //we continue storing the minimum values from other two lists.\n        while(j < n && k < o)\n        {\n            if(B[j] <= C[k])\n            {\n                list.add(B[j]);\n                j++;\n            }\n            else\n            {\n                list.add(C[k]);\n                k++;\n            }\n        }\n        \n        //If B and C have exhausted (their pointer has crossed last element) then\n        //we continue storing the minimum values from the last list A.\n        while(i < m)\n        {\n            list.add(A[i]);\n            i++;\n        }\n        \n        //If A and C have exhausted (their pointer has crossed last element) then\n        //we continue storing the minimum values from the last list B.\n        while(j < n)\n        {\n            list.add(B[j]);\n            j++;\n        }\n        \n        //If A and B have exhausted (their pointer has crossed last element) then\n        //we continue storing the minimum values from the last list C.\n        while(k < o)\n        {\n            list.add(C[k]);\n            k++;\n        }\n        //returning the resultant list.\n        return list;\n        \n    }\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "class Solution:\n    #Back-end complete function Template for Python 3\n    \n    #Function to merge three sorted arrays into a single array.\n    def mergeThree(self, A,B,C):\n        \n        #Storing the size of the three arrays.\n        n=len(A)\n        m=len(B)\n        p=len(C)\n        \n        #Creating an array for storing output.\n        merged_array=[] \n        \n        i=0\n        j=0\n        k=0\n        \n        #Using three pointers over the three arrays which helps in choosing\n        #and storing the smallest element in the output array.\n        while(i<n and j<m and k<p):\n            \n            #Finding minimum of A[i], B[j] and C[k] and storing in output array. \n            merged_array.append(min(A[i],B[j],C[k]))\n            \n            #Incrementing the pointer which had the minimum value.\n            if(merged_array[-1]==A[i]):\n                i+=1\n            elif (merged_array[-1]==B[j]):\n                j+=1\n            else:\n                k+=1\n                \n        #If C has exhausted(its pointer has crossed last element) then \n        #we continue storing the minimum values from other two arrays.\n        while(i<n and j<m):\n            merged_array.append(min(A[i],B[j]))\n            \n            if(merged_array[-1]==A[i]):\n                i+=1\n            elif (merged_array[-1]==B[j]):\n                j+=1\n                \n        #If B has exhausted(its pointer has crossed last element) then \n        #we continue storing the minimum values from other two arrays.\n        while(i<n and k<p):\n            merged_array.append(min(A[i],C[k]))\n            \n            if(merged_array[-1]==A[i]):\n                i+=1\n            elif (merged_array[-1]==C[k]):\n                k+=1\n                \n        #If A has exhausted(its pointer has crossed last element) then \n        #we continue storing the minimum values from other two arrays.\n        while(j<m and k<p):\n            merged_array.append(min(B[j],C[k]))\n            \n            if(merged_array[-1]==B[j]):\n                j+=1\n            elif (merged_array[-1]==C[k]):\n                k+=1\n                \n        #If B and C have exhausted (their pointer has crossed last element) then\n        #we continue storing the minimum values from the last array A.\n        while(i<n):\n            merged_array.append(A[i])\n            i+=1\n            \n        #If A and C have exhausted (their pointer has crossed last element) then\n        #we continue storing the minimum values from the last array B.\n        while(j<m):\n            merged_array.append(B[j])\n            j+=1\n            \n        #If A and B have exhausted (their pointer has crossed last element) then\n        #we continue storing the minimum values from the last array C.\n        while(k<p):\n            merged_array.append(C[k])\n            k+=1\n        \n        #returning the resultant array.\n        return merged_array\n        \n        ",
                "lang_text": "python3"
            },
            {
                "lang": "Javascript",
                "full_func": "//Back-end complete function Template for javascript\n\n/**\n * @param {number[]} A\n * @param {number[]} B\n * @param {number[]} C\n * @returns {number[]}\n*/\n\nclass Solution {\n    //Function to merge three sorted arrays into a single array.\n    mergeThree(A, B, C)\n    {\n        let m, n, o, i, j, k; \n        //Storing the size of the three arrays.\n        m = A.length; \n        n = B.length; \n        o = C.length; \n    \n        //Creating an array for storing output. \n        let D = [];\n    \n        i = j = k = 0; \n        \n        //Using three pointers over the three arrays which helps in choosing\n        //and storing the smallest element in the output array.\n        while (i < m && j < n && k < o) { \n    \n            //Finding minimum of A[i], B[j] and C[k].\n            let minn = Math.min(Math.min(A[i], B[j]), C[k]); \n    \n            //We store the minimum value in output array. \n            D.push(minn); \n    \n            //Incrementing the pointer which had the minimum value.\n            if (minn == A[i]) \n                i++; \n            else if (minn == B[j]) \n                j++; \n            else\n                k++; \n        } \n    \n        //If C has exhausted(its pointer has crossed last element) then \n        //we continue storing the minimum values from other two arrays.\n        while (i < m && j < n) { \n            if (A[i] <= B[j]) { \n                D.push(A[i]); \n                i++; \n            } \n            else { \n                D.push(B[j]); \n                j++; \n            } \n        } \n    \n        //If B has exhausted(its pointer has crossed last element) then \n        //we continue storing the minimum values from other two arrays.\n        while (i < m && k < o) { \n            if (A[i] <= C[k]) { \n                D.push(A[i]); \n                i++; \n            } \n            else { \n                D.push(C[k]); \n                k++; \n            } \n        } \n    \n        //If A has exhausted(its pointer has crossed last element) then \n        //we continue storing the minimum values from other two arrays.\n        while (j < n && k < o) { \n            if (B[j] <= C[k]) { \n                D.push(B[j]); \n                j++; \n            } \n            else { \n                D.push(C[k]); \n                k++; \n            } \n        } \n    \n        //If A and B have exhausted (their pointer has crossed last element) then\n        //we continue storing the minimum values from the last array C.\n        while (k < o) \n            D.push(C[k++]); \n    \n        //If B and C have exhausted (their pointer has crossed last element) then\n        //we continue storing the minimum values from the last array A.\n        while (i < m) \n            D.push(A[i++]); \n    \n        //If A and C have exhausted (their pointer has crossed last element) then\n        //we continue storing the minimum values from the last array B.\n        while (j < n) \n            D.push(B[j++]); \n    \n        //returning the resultant array.\n        return D; \n    }\n}",
                "lang_text": "javascript"
            },
            {
                "lang": "C#",
                "full_func": "class Solution\n{\n    public List<int> mergeThree(List<int> A, List<int> B, List<int> C)\n    {\n        int m, n, o, i, j, k;\n        m = A.Count;\n        n = B.Count;\n        o = C.Count;\n\n        List<int> D = new List<int>();\n        D.Capacity = m + n + o;\n\n        i = j = k = 0;\n\n        while (i < m && j < n && k < o)\n        {\n            int minn = Math.Min(Math.Min(A[i], B[j]), C[k]);\n            D.Add(minn);\n            if (minn == A[i])\n                i++;\n            else if (minn == B[j])\n                j++;\n            else\n                k++;\n        }\n\n        while (i < m && j < n)\n        {\n            if (A[i] <= B[j])\n            {\n                D.Add(A[i]);\n                i++;\n            }\n            else\n            {\n                D.Add(B[j]);\n                j++;\n            }\n        }\n\n        while (i < m && k < o)\n        {\n            if (A[i] <= C[k])\n            {\n                D.Add(A[i]);\n                i++;\n            }\n            else\n            {\n                D.Add(C[k]);\n                k++;\n            }\n        }\n\n        while (j < n && k < o)\n        {\n            if (B[j] <= C[k])\n            {\n                D.Add(B[j]);\n                j++;\n            }\n            else\n            {\n                D.Add(C[k]);\n                k++;\n            }\n        }\n\n        while (k < o)\n            D.Add(C[k++]);\n\n        while (i < m)\n            D.Add(A[i++]);\n\n        while (j < n)\n            D.Add(B[j++]);\n\n        return D;\n    }\n}",
                "lang_text": "csharp"
            }
        ],
        "platform": "GFG"
    }
}