{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 711154,
            "title": "Merging Details",
            "titleSlug": "merging-details",
            "content": "<p><span style=\"font-size: 18px;\">Bob, a teacher&nbsp;of St. Joseph School given a task by his principal&nbsp;to merge the details of the students where each element<strong> details[i] </strong>is a list of strings, where the first element <strong>details[i][0]</strong> is a name of the student, and the rest of the elements are emails representing emails of the student. &nbsp; Two details definitely belong to the same student if there is some common email to both detail. &nbsp;After merging the details, return the details of the student in the following format: the first element of each detail is the name of the student, and the rest of the elements are emails in sorted order. &nbsp;<br /><strong>Note: </strong>Two details have the same name, they may belong to different people as people could have the same name. A person can have any number of details initially, but all of their details definitely have the same name.<br />In case 2 or more same email&nbsp;belongs to&nbsp;2 or more&nbsp;different names merge with first name only. <strong>Return the 2D list in the order in a sorted way according to the name of the details.</strong></span></p>\n<p><span style=\"font-size: 18px;\"><strong>Example 1:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong> \nn: 4\ndetails = \n[[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],\n[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],\n[\"Mary\",\"mary@mail.com\"],\n[\"John\",\"johnnybravo@mail.com\"]]\n<strong>Output:</strong> \n[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\n\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],\n[\"John\",\"johnnybravo@mail.com\"]]\n<strong>Explanation:</strong>\nThe first and second John's are the same person as \nthey have the common email \"johnsmith@mail.com\".\nThe third John and Mary are different people as none\nof their email addresses are used by other accounts.\nWe could return these lists in any order, for example\nthe answer [['Mary', 'mary@mail.com'], \n['John', 'johnnybravo@mail.com'], \n['John', 'john00@mail.com', 'john_newyork@mail.com', \n'johnsmith@mail.com']] \nwould still be accepted.</span>\n</pre>\n<p><span style=\"font-size: 18px;\"><strong>Example 2:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong> \nn: 5\ndetails = \n[[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]\n<strong>Output:</strong> \n[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]\n<strong>Explanation:\n</strong>We don't have any common emails in any of the users.\nWe just sorted the emails of each person and we\nreturn a list of the emails.(The details can be\nreturned in any order).</span>\n</pre>\n<p><span style=\"font-size: 18px;\"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>mergeDetails</strong><strong>()&nbsp;</strong>which takes 2D List of string details denoting the details of the students and returns the list of strings denoting the details of student after merging.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:</strong>&nbsp;O(N*M*logN) - where N is the size of details length and M is the size of number of strings for a name.<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N*M) - where N is the size of details length and M is the size of number of strings for a name.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong></span></p>\n<ul>\n<li><span style=\"font-size: 18px;\">1 &lt;= details.length &lt;= 1000</span></li>\n<li><span style=\"font-size: 18px;\">2 &lt;= details[i].length &lt;= 10</span></li>\n<li><span style=\"font-size: 18px;\">1 &lt;= details[i][j].length &lt;= 30</span></li>\n<li><span style=\"font-size: 18px;\">details[i][0]&nbsp;consists of English letters.</span></li>\n<li><span style=\"font-size: 18px;\">details[i][j] (for j &gt; 0)&nbsp;is a valid email.</span></li>\n</ul>\n<p>&nbsp;</p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a list of student details, where each detail contains a student's name and a list of their email addresses, merge the details of students who share common email addresses. The first element of each detail is the student's name, and the remaining elements are their emails. If two details share a common email, they belong to the same student. After merging, return a list of student details, where each detail contains the student's name followed by a sorted list of their unique email addresses.  Prioritize the first name encountered during merging when encountering the same emails among multiple students with different names. The final list should be sorted alphabetically by student name.",
                "constraints": [
                    "1 <= details.length <= 1000",
                    "2 <= details[i].length <= 10",
                    "1 <= details[i][j].length <= 30",
                    "details[i][0] consists of English letters.",
                    "details[i][j] (for j > 0) is a valid email."
                ],
                "testcases": [
                    {
                        "input": "n: 4\ndetails = \n[[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],\n[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],\n[\"Mary\",\"mary@mail.com\"],\n[\"John\",\"johnnybravo@mail.com\"]] ",
                        "output": "[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"John\",\"johnnybravo@mail.com\"],[\"Mary\",\"mary@mail.com\"]] ",
                        "explanation": "The first and second John's are the same person as they share the email 'johnsmith@mail.com'. The third John and Mary are different people as none of their email addresses are used by other accounts. The output is sorted by name."
                    },
                    {
                        "input": "n: 5\ndetails = \n[[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]] ",
                        "output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"]] ",
                        "explanation": "There are no common emails between any of the users.  The emails for each user are sorted, and the final list is sorted by name."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:14px\">For every pair of emails in the same account, draw an edge between those emails. The problem is about enumerating the connected components of this graph.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "union-find",
                "slug": "union-find"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "// Back-end complete function Template for C++\nclass Solution {\n  public:\n    // Function to find the root of the union find array\n    int find(vector<int>& union_find, int ind) {\n        while (union_find[ind] != ind) ind = union_find[ind];\n        return ind;\n    }\n\n    // Function to merge the accounts\n    vector<vector<string>> mergeDetails(vector<vector<string>>& accounts) {\n        unordered_map<string, int> m;\n        vector<int> union_find(accounts.size(), 0);\n        unordered_map<int, vector<string>> res_map;\n\n        // Initializing union find array and mapping email to account index\n        for (int i = 0; i < accounts.size(); i++) {\n            union_find[i] = i;\n            for (int j = 1; j < accounts[i].size(); j++) {\n                if (m.find(accounts[i][j]) != m.end()) {\n                    int root1 = find(union_find, i);\n                    int root2 = find(union_find, m[accounts[i][j]]);\n                    union_find[root1] = root2;\n                } else\n                    m[accounts[i][j]] = union_find[i];\n            }\n        }\n\n        // Mapping root index to merged emails\n        for (auto it : m) {\n            int ind = find(union_find, it.second);\n            res_map[ind].push_back(it.first);\n        }\n\n        // Constructing final result with sorted emails\n        vector<vector<string>> res;\n        for (auto it : res_map) {\n            vector<string> email = it.second;\n            sort(email.begin(), email.end());\n            email.insert(email.begin(), accounts[it.first][0]);\n            res.push_back(email);\n        }\n\n        return res;\n    }\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "// Back-end complete function Template for Java\r\n\r\nclass Solution {\r\n    HashSet<String> visited = new HashSet<>();\r\n    Map<String, List<String>> adjacent = new HashMap<String, List<String>>();\r\n\r\n    private void DFS(List<String> mergedAccount, String email) {\r\n        visited.add(email);\r\n        // Add the email vector that contains the current component's emails\r\n        mergedAccount.add(email);\r\n\r\n        if (!adjacent.containsKey(email)) {\r\n            return;\r\n        }\r\n\r\n        for (String neighbor : adjacent.get(email)) {\r\n            if (!visited.contains(neighbor)) {\r\n                DFS(mergedAccount, neighbor);\r\n            }\r\n        }\r\n    }\r\n    public List<List<String>> mergeDetails(List<List<String>> details) {\r\n        int detailsSize = details.size();\r\n\r\n        for (List<String> detail : details) {\r\n            int detailSize = detail.size();\r\n\r\n            // Building adjacency list\r\n            // Adding edge between first email to all other emails in the\r\n            // account\r\n            String detailFirstEmail = detail.get(1);\r\n            for (int j = 2; j < detailSize; j++) {\r\n                String detailEmail = detail.get(j);\r\n\r\n                if (!adjacent.containsKey(detailFirstEmail)) {\r\n                    adjacent.put(detailFirstEmail, new ArrayList<String>());\r\n                }\r\n                adjacent.get(detailFirstEmail).add(detailEmail);\r\n\r\n                if (!adjacent.containsKey(detailEmail)) {\r\n                    adjacent.put(detailEmail, new ArrayList<String>());\r\n                }\r\n                adjacent.get(detailEmail).add(detailFirstEmail);\r\n            }\r\n        }\r\n\r\n        // Traverse over all th accounts to store components\r\n        List<List<String>> mergedAccounts = new ArrayList<>();\r\n        for (List<String> detail : details) {\r\n            String accountName = detail.get(0);\r\n            String accountFirstEmail = detail.get(1);\r\n\r\n            // If email is visited, then it's a part of different component\r\n            // Hence perform DFS only if email is not visited yet\r\n            if (!visited.contains(accountFirstEmail)) {\r\n                List<String> mergedAccount = new ArrayList<>();\r\n                // Adding account name at the 0th index\r\n                mergedAccount.add(accountName);\r\n\r\n                DFS(mergedAccount, accountFirstEmail);\r\n                Collections.sort(\r\n                    mergedAccount.subList(1, mergedAccount.size()));\r\n                mergedAccounts.add(mergedAccount);\r\n            }\r\n        }\r\n\r\n        return mergedAccounts;\r\n    }\r\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "#Back-end complete function Template for Python 3\r\n\r\nfrom collections import defaultdict\r\nfrom typing import List\r\nclass Solution:\r\n    def mergeDetails(self, details : List[List[str]]) -> List[List[str]]:\r\n        id_parents = list(range(len(details)))\r\n        \r\n        def find_parent(x):\r\n            if id_parents[x] != x:\r\n                id_parents[x] = find_parent(id_parents[x])\r\n            return id_parents[x]\r\n\r\n        def union(old, new):\r\n            parent_old = find_parent(old)\r\n            parent_new = find_parent(new)\r\n            if parent_old != parent_new:\r\n                id_parents[new] = parent_old\r\n            return parent_old\r\n        \r\n        email_to_id = {} # map email to its id group, used for checking existing emails\r\n        for curr_id, account in enumerate(details):\r\n            for email in account[1:]:\r\n                if email not in email_to_id:\r\n                    email_to_id[email] = curr_id\r\n                else:\r\n                    curr_id = union(email_to_id[email], curr_id)\r\n            \r\n        id_to_emails = defaultdict(list) # map name to a set of emails\r\n        for email in email_to_id:\r\n            id_group = find_parent(email_to_id[email])\r\n            id_to_emails[id_group].append(email)\r\n        \r\n        ans = []\r\n        for id_group in id_to_emails:\r\n            sorted_emails = sorted(id_to_emails[id_group])\r\n            ans.append([details[id_group][0]]+sorted_emails)\r\n    \r\n        return ans\r\n",
                "lang_text": "py"
            }
        },
        "platform": "GFG"
    }
}