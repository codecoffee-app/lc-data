{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 710047,
            "title": "Minimum swap required to convert binary tree to binary search tree",
            "titleSlug": "minimum-swap-required-to-convert-binary-tree-to-binary-search-tree",
            "content": "<p><span style=\"font-size: 18px;\">Given an array&nbsp;<strong>arr[]</strong>&nbsp;which represents&nbsp;a&nbsp;Complete Binary Tree i.e, if index&nbsp;<strong>i</strong>&nbsp;is the parent, index&nbsp;<strong>2*i + 1</strong>&nbsp;is the left child and index&nbsp;<strong>2*i + 2</strong>&nbsp;is the right child.<br />The task is to find the minimum number of swaps required to convert it into a Binary Search Tree.&nbsp;</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Examples :</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input: </strong>arr[] = [5, 6, 7, 8, 9, 10, 11]\n<strong>Output: </strong>3\n<strong>Explanation:</strong> \nBinary tree of the given array:\n<img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/880844/Web/Other/blobid0_1732596870.png\" width=\"303\" height=\"266\" /> <br />Swap 1: Swap node 8 with node 5.\nSwap 2: Swap node 9 with node 10.\nSwap 3: Swap node 10 with node 7.\n<img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/880844/Web/Other/blobid1_1732596347.png\" width=\"300\" height=\"265\" /> <br />So, minimum 3 swaps are required.</span></pre>\n<pre><span style=\"font-size: 18px;\"><strong style=\"font-size: 18px;\">Input: </strong><span style=\"font-size: 18px;\">arr[] = [1, 2, 3]<br /></span><strong style=\"font-size: 18px;\">Explanation:</strong><span style=\"font-size: 18px;\"> <br />Binary tree of the given array:<br /><img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/880844/Web/Other/blobid2_1732596556.png\" width=\"299\" height=\"264\" /> <br />After swapping node 1 with node 2, obtain the below binary search tree:<br /><img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/880844/Web/Other/blobid3_1732596597.png\" width=\"297\" height=\"265\" /><br /></span><strong style=\"font-size: 18px;\">Output: </strong><span style=\"font-size: 18px;\">1</span></span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &lt;= arr.size() &lt;= 10<sup>5<br /></sup></span><span style=\"font-size: 18px;\">1 &lt;= arr[i] &lt;= 10<sup>9</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Inorder traversal of Binary Search Tree is in increasing order of their value.&nbsp;</span></p>",
            "<p><span style=\"font-size:18px\">Find the inorder traversal of the Binary Tree and store it in the array and try to sort the array. The minimum number of swap required to get the array sorted will be the answer.</span></p>"
        ],
        "relatedTopics": [],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class Solution {\n  public:\n    void inorder(vector<int>& arr, vector<int>& inorderArr, int index) {\n\n        int n = arr.size();\n\n        // If index is out of bounds, return\n        if (index >= n)\n            return;\n\n        // Recursively visit left subtree\n        inorder(arr, inorderArr, 2 * index + 1);\n\n        // Store current node value in vector\n        inorderArr.push_back(arr[index]);\n\n        // Recursively visit right subtree\n        inorder(arr, inorderArr, 2 * index + 2);\n    }\n\n    // Function to calculate minimum swaps\n    // to sort inorder traversal\n    int minSwaps(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> inorderArr;\n\n        // Get the inorder traversal of the binary tree\n        inorder(arr, inorderArr, 0);\n\n        // Create an array of pairs to store value\n        // and original index\n        vector<pair<int, int>> t(inorderArr.size());\n        int ans = 0;\n\n        // Store the value and its index\n        for (int i = 0; i < inorderArr.size(); i++)\n            t[i] = {inorderArr[i], i};\n\n        // Sort the pair array based on values\n        // to get BST order\n        sort(t.begin(), t.end());\n\n        // Find minimum swaps by detecting cycles\n        for (int i = 0; i < t.size(); i++) {\n\n            // If the element is already in the\n            // correct position, continue\n            if (i == t[i].second)\n                continue;\n\n            // Otherwise, perform swaps until the element\n            // is in the right place\n            else {\n\n                // Swap elements to correct positions\n                swap(t[i].first, t[t[i].second].first);\n                swap(t[i].second, t[t[i].second].second);\n            }\n\n            // Check if the element is still not\n            // in the correct position\n            if (i != t[i].second)\n                --i;\n\n            // Increment swap count\n            ans++;\n        }\n\n        return ans;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution {\n    // Function to perform inorder traversal of the binary tree\n    // and store it in array `inorderArr`\n    static void inorder(int[] arr, List<Integer> inorderArr, int index) {\n        int n = arr.length;\n\n        // If index is out of bounds, return\n        if (index >= n) return;\n\n        // Recursively visit left subtree\n        inorder(arr, inorderArr, 2 * index + 1);\n\n        // Store current node value in list\n        inorderArr.add(arr[index]);\n\n        // Recursively visit right subtree\n        inorder(arr, inorderArr, 2 * index + 2);\n    }\n\n    public static int minSwaps(int[] arr) {\n        int n = arr.length;\n        List<Integer> inorderArr = new ArrayList<>();\n\n        // Get the inorder traversal of the binary tree\n        inorder(arr, inorderArr, 0);\n\n        // Create an array of pairs to store value and original index\n        Pair[] t = new Pair[inorderArr.size()];\n        int ans = 0;\n\n        // Store the value and its index\n        for (int i = 0; i < inorderArr.size(); i++) {\n            t[i] = new Pair(inorderArr.get(i), i);\n        }\n\n        // Sort the array based on values to get BST order\n        Arrays.sort(t, Comparator.comparingInt(p -> p.first));\n\n        // Find minimum swaps by detecting cycles\n        boolean[] visited = new boolean[t.length];\n        for (int i = 0; i < t.length; i++) {\n            // If the element is already in the correct position or visited, continue\n            if (visited[i] || i == t[i].second) continue;\n\n            // Count the number of nodes in the current cycle\n            int cycleSize = 0;\n            int j = i;\n            while (!visited[j]) {\n                visited[j] = true;\n                j = t[j].second;\n                cycleSize++;\n            }\n\n            // Add cycle size - 1 to the swap count\n            if (cycleSize > 1) {\n                ans += (cycleSize - 1);\n            }\n        }\n\n        // Return total number of swaps\n        return ans;\n    }\n\n    // Pair class to store value and original index\n    static class Pair {\n        int first, second;\n\n        Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n    }\n}\n",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "# Python program for Minimum swaps required\n# to convert binary tree to binary search tree\nclass Solution:\n\n    def minSwaps(self, arr):\n        inorderArr = []\n\n        # Get the inorder traversal of the binary tree\n        self.inorder(arr, inorderArr, 0)  # Use self to call the method\n\n        # Create a list of pairs to store value and original index\n        t = [(inorderArr[i], i) for i in range(len(inorderArr))]\n        ans = 0\n\n        # Sort the list of pairs based on values to get BST order\n        t.sort()\n\n        # Create a visited array to detect cycles\n        visited = [False] * len(t)\n\n        # Find minimum swaps by detecting cycles\n        for i in range(len(t)):\n\n            # If the element is already in the correct position or visited\n            if visited[i] or i == t[i][1]:\n                continue\n\n            # Count the size of the cycle\n            cycle_size = 0\n            j = i\n\n            while not visited[j]:\n                visited[j] = True\n                j = t[j][1]  # Jump to the next index in the cycle\n                cycle_size += 1\n\n            # Add (cycle_size - 1) to the swap count\n            if cycle_size > 1:\n                ans += (cycle_size - 1)\n\n        # Return total number of swaps\n        return ans\n\n    def inorder(self, arr, inorderArr, index):\n        # If index is out of bounds, return\n        n = len(arr)\n        if index >= n:\n            return\n\n        # Recursively visit left subtree\n        self.inorder(arr, inorderArr, 2 * index + 1)\n\n        # Store current node value in the list\n        inorderArr.append(arr[index])\n\n        # Recursively visit right subtree\n        self.inorder(arr, inorderArr, 2 * index + 2)",
                "lang_text": "python3"
            },
            {
                "lang": "Javascript",
                "full_func": "// JavaScript program for Minimum swap required\n// to convert binary tree to binary search tree\n\nclass Solution {\n    // Function to perform inorder traversal of the binary tree\n    // and store it in array inorderArr\n    inorder(arr, inorderArr, index) {\n        // If index is out of bounds, return\n        if (index >= arr.length) return;\n\n        // Recursively visit left subtree\n        this.inorder(arr, inorderArr, 2 * index + 1);\n\n        // Store current node value in array\n        inorderArr.push(arr[index]);\n\n        // Recursively visit right subtree\n        this.inorder(arr, inorderArr, 2 * index + 2);\n    }\n\n    // Function to calculate minimum swaps\n    // to sort inorder traversal\n    minSwaps(arr) {\n        let inorderArr = [];\n\n        // Get the inorder traversal of the binary tree\n        this.inorder(arr, inorderArr, 0);\n\n        // Create an array of pairs to store value and original index\n        let t = inorderArr.map((val, i) => [val, i]);\n        let ans = 0;\n\n        // Sort the pair array based on values to get BST order\n        t.sort((a, b) => a[0] - b[0]);\n\n        // Create a visited array to detect cycles\n        let visited = new Array(t.length).fill(false);\n\n        // Find minimum swaps by detecting cycles\n        for (let i = 0; i < t.length; i++) {\n            // If the element is already in the correct position or visited\n            if (visited[i] || i === t[i][1]) continue;\n\n            // Count the size of the cycle\n            let cycle_size = 0;\n            let j = i;\n\n            while (!visited[j]) {\n                visited[j] = true;\n                j = t[j][1]; // Move to the next index in the cycle\n                cycle_size++;\n            }\n\n            // Add (cycle_size - 1) to the swap count\n            if (cycle_size > 1) {\n                ans += (cycle_size - 1);\n            }\n        }\n\n        // Return total number of swaps\n        return ans;\n    }\n}\n",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}