{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 705584,
            "title": "nCr mod M | Part 2",
            "titleSlug": "ncr-mod-m-part-20611",
            "content": "<p><span style=\"font-size: 18px;\">Given 3&nbsp;integers n, r and m. You task is to calculate <sup>n</sup>Cr%m.<br /><strong>Note:&nbsp;</strong>m is a square free number and largest prime factor of m &lt;= 50.</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Example 1:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input: </strong>n = 5, r = 2, m = 98697\n<strong>Output: </strong>10\n<strong>Explanation: </strong><sup>5</sup>C2 = 5!/(2!*3!) = 10%98697 = 10\n</span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Example 2:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input: </strong>n = 3, r = 2, m = 98697\n<strong>Output: </strong>3\n<strong>Explanation: </strong><sup>3</sup>C2 = 3!/(2!*1!) = 3%98697 = 3\n</span></pre>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>nCrModM()&nbsp;</strong>which takes n, r and m as input parameter and returns nCr modulo m.</span><br />&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:&nbsp;</strong>O(m +&nbsp;log<sub>m</sub>n)&nbsp;<br /><strong>Expected Space Complexity:&nbsp;</strong>O(m)</span><br />&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &lt;= r&nbsp;&lt;= n&nbsp;&lt;= 10<sup>9</sup><br />1 &lt;= m &lt;= 10<sup>5</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given three integers `n`, `r`, and `m`, calculate <sup>n</sup>C<sub>r</sub> % m.  It is guaranteed that `m` is a square-free number, and the largest prime factor of `m` is less than or equal to 50.",
                "constraints": [
                    "1 <= r <= n <= 10<sup>9</sup>",
                    "1 <= m <= 10<sup>5</sup>"
                ],
                "testcases": [
                    {
                        "input": "n = 5, r = 2, m = 98697",
                        "output": "10",
                        "explanation": "<sup>5</sup>C<sub>2</sub> = 5! / (2! * 3!) = 10. Therefore, 10 % 98697 = 10."
                    },
                    {
                        "input": "n = 3, r = 2, m = 98697",
                        "output": "3",
                        "explanation": "<sup>3</sup>C<sub>2</sub> = 3! / (2! * 1!) = 3. Therefore, 3 % 98697 = 3."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Use Lucas Theorem</p>"
        ],
        "relatedTopics": [
            {
                "name": "Combinatorial",
                "slug": "combinatorial"
            },
            {
                "name": "Modular Arithmetic",
                "slug": "modular-arithmetic"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\r\n    public:\r\n    //Function to find all prime factors of a given number.\r\n    std::vector<int> findPrimeFactors(int x) {\r\n        std::vector<int> factors;\r\n        int square_root = (int) std::sqrt(x);\r\n        int factor = 2;\r\n        \r\n        //looping until factor exceeds square root of x or x becomes 1\r\n        while (factor <= square_root && x != 1) {\r\n            //if factor divides x, push it to factors and divide x by factor\r\n            if (x % factor == 0) {\r\n                factors.push_back(factor);\r\n                x /= factor;\r\n                square_root = (int) std::sqrt(x);\r\n            }\r\n            factor++;\r\n        }\r\n        \r\n        //if x is not equal to 1, push it to factors as it is a prime factor\r\n        if (x != 1) {\r\n            factors.push_back(x);\r\n        }\r\n        \r\n        return factors;\r\n    }\r\n    \r\n    //Function to find the minimum value of x using Chinese Remainder Theorem\r\n    int findByCrt(const std::vector<int> x, const std::vector<int> r) {\r\n        const int kN = x.size();\r\n        int min_x = 0;\r\n        \r\n        //loop until a valid x is found which satisfies all the remainders\r\n        while (true) {\r\n            bool found = true;\r\n            \r\n            //checking if current x satisfies all the remainders\r\n            for (int i = 0; i < kN; i++) {\r\n                if (min_x % x[i] != r[i]) {\r\n                    found = false;\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            //if all remainders are satisfied, return min_x\r\n            if (found) {\r\n                return min_x;\r\n            }\r\n            \r\n            min_x++;\r\n        }\r\n    }\r\n    \r\n    //Function to find nCr % p using Pascal's Triangle\r\n    int rCnModP(int n, int r, int p) {\r\n        //if r is 0 or r is same as n, return 1\r\n        if (r == 0 || r == n) {\r\n            return 1;\r\n        }\r\n        \r\n        int triangle[r+1];\r\n        std::memset(triangle, 0, sizeof(triangle));\r\n        triangle[0] = 1;\r\n        \r\n        //building Pascal's Triangle up to n rows\r\n        for (int i = 1; i <= n; i++) {\r\n            //calculating each element using previous row\r\n            for (int j = std::min(i,r); j > 0; j--) {\r\n                triangle[j] = (triangle[j]+triangle[j-1]) % p;\r\n            }\r\n        }\r\n        \r\n        return triangle[r];\r\n    }\r\n    \r\n    //Function to find nCr % p using Lucas Theorem for prime p\r\n    int rCnModPrimeLucas(int n, int r, int p) {\r\n        //if r is 0, return 1 as nC0 = 1\r\n        if (r == 0) {\r\n            return 1;\r\n        }\r\n        \r\n        int ni = n % p;\r\n        int ri = r % p;\r\n        \r\n        //recursive call to calculate n/p, r/p using Lucas Theorem and rCnModP for ni,ri\r\n        return rCnModPrimeLucas(n/p, r/p, p) * rCnModP(ni, ri, p) % p;\r\n    }\r\n    \r\n    //Function to calculate nCr % m using Chinese Remainder Theorem\r\n    int nCrModM(int n, int r, int m) {\r\n        //find all prime factors of m\r\n        const auto primes = findPrimeFactors(m);\r\n        \r\n        std::vector<int> rem;\r\n        \r\n        //calculate rCn % p for each prime factor p\r\n        for (const int p : primes) {\r\n            rem.push_back(rCnModPrimeLucas(n, r, p));\r\n        }\r\n        \r\n        //find minimum value of x using Chinese Remainder Theorem\r\n        return findByCrt(primes, rem);\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution{\n\tArrayList<Integer> findPrimeFactors(int x) {\n\t    // Initializing an ArrayList to store the prime factors of x.\n\t    ArrayList<Integer> factors = new ArrayList<>();\n\t    // Finding the square root of x to optimize the factorization process.\n\t    int square_root = (int) Math.sqrt(x);\n\t    // Start with the smallest prime factor, 2.\n\t    int factor = 2;\n\t    // Iterating until the factor is smaller than or equal to the square root of x.\n\t    while (factor <= square_root && x != 1) {\n\t        // If x is divisible by the factor, add it to the prime factors list.\n\t        if (x % factor == 0) {\n\t            factors.add(factor);\n\t            // Divide x by the factor to continue factorizing.\n\t            x /= factor;\n\t            // Update the square root since x has changed.\n\t            square_root = (int) Math.sqrt(x);\n\t        }\n\t        // Move to the next factor.\n\t        factor++;\n\t    }\n    \t// If x is still not equal to 1, it means x itself is a prime factor.\n    \tif (x != 1) {\n        \tfactors.add(x);\n    \t}\n    \t// Return the list of prime factors of x.\n    \treturn factors;\n\t}\n\t\n\t\n\tint findByCrt(ArrayList<Integer> x, ArrayList<Integer> r) {\n\t    // Get the number of congruence equations.\n\t    int kN = x.size();\n\t    // Start with the smallest possible number.\n\t    int min_x = 0;\n\t    while (true) {\n\t        boolean found = true;\n\t        // Check if the current number satisfies all congruence equations.\n\t        for (int i = 0; i < kN; i++) {\n\t            if (min_x % x.get(i) != r.get(i)) {\n\t                found = false;\n\t                break;\n\t            }\n\t        }\n\t        \n\t        // If the current number satisfies all congruence equations, return it.\n\t        if (found) {\n\t            return min_x;\n\t        }\n\t        \n\t        // Move to the next number.\n\t        min_x++;\n\t    }\n\t}\n\t\n\tint rCnModP(int n, int r, int p) {\n\t    // Base case: nC0 = nCn = 1\n\t    if (r == 0 || r == n) {\n\t        return 1;\n\t    }\n\t    // Initialize an array to store Pascal's triangle values.\n\t    int [] triangle = new int[r+1];\n\t    // Initialize the first value as 1.\n\t    triangle[0] = 1;\n\t    for (int i = 1; i <= n; i++) {\n\t        for (int j = Math.min(i,r); j > 0; j--) {\n\t            // Calculate the next value in Pascal's triangle using modular arithmetic.\n\t            triangle[j] = (triangle[j]+triangle[j-1]) % p;\n\t        }\n\t    }\n\t    // Return the value of nCr mod p.\n\t    return triangle[r];\n\t}\n\t\n\tint rCnModPrimeLucas(int n, int r, int p) {\n\t    // Base case: nCr = 1 if r = 0\n\t    if (r == 0) {\n\t        return 1;\n\t    }\n\t    // Calculate the modulo values of n and r.\n\t    int ni = n % p;\n\t    int ri = r % p;\n\t    // Recursive step: Calculate n/p, r/p, and the value of nCr mod p using Lucas' theorem.\n\t    return rCnModPrimeLucas(n/p, r/p, p) * rCnModP(ni, ri, p) % p;\n\t}\n\t\n\tpublic int nCrModM(int n, int r, int m) {\n\t    // Find the prime factors of m.\n\t    ArrayList<Integer> primes = findPrimeFactors(m);\n\t    \n\t    // Calculate the modulo values for each prime factor.\n\t    ArrayList<Integer> rem = new ArrayList<>();\n\t    for (int p : primes) {\n\t        rem.add(rCnModPrimeLucas(n, r, p));\n\t    }\n\t    \n\t    // Solve the Chinese Remainder Theorem to find the final result.\n\t    return findByCrt(primes, rem);\n\t}\n\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python3",
                "full_func": "class Solution:\n\n    def nCrModM(self, n, r, m):\n        # Function to find the value of nCr % m using Lucas's Theorem\n\n        def leastPrimeFactor(n):\n            # Function to find the least prime factor of numbers up to n\n\n            least_prime = [0] * (n + 1)\n            least_prime[1] = 1\n\n            for i in range(2, n + 1):\n                if (least_prime[i] == 0):\n                    least_prime[i] = i\n\n                    for j in range(2 * i, n + 1, i):\n                        # Marking multiples of i as non-prime\n                        if (least_prime[j] == 0):\n                            least_prime[j] = i\n            return least_prime\n\n        def power(x, y, m):\n            # Function to compute x^y under modulo m using recursion\n\n            if (y == 0):\n                return 1\n\n            p = power(x, y // 2, m) % m\n            p = (p * p) % m\n\n            if (y % 2 == 0):\n                return p\n            else:\n                return ((x * p) % m)\n\n        def ncr_kris(n, r, p):\n            # Function to compute nCr % p (for prime p) using modular arithmetic\n\n            if (n < r):\n                return 0\n            if (r > n - r):\n                r = n - r\n\n            num = den = 1\n\n            for i in range(r):\n                num = (num * (n - i)) % p\n                den = (den * (i + 1)) % p\n\n            ans = (num * power(den, p - 2, p)) % p\n\n            return ans\n\n        def toBaseB(N, B):\n            # Function to convert a number to another base\n\n            digits = []\n\n            while N > 0:\n                digits.insert(0, N % B)\n                N = N // B\n\n            return digits\n\n        def nCrModp_Lucas(n, r, p):\n            # Function to compute nCr % p using Lucas's theorem\n\n            m = toBaseB(n, p)\n            n = toBaseB(r, p)\n            l1 = len(m)\n            l2 = len(n)\n            ans = 1\n\n            for i in range(l2):\n                ans = (ans * ncr_kris(m[(l1 - l2) + i], n[i], p)) % p\n\n            return ans\n\n        SPF = leastPrimeFactor(m)\n        PrimeFactors = []\n        x = m\n        i = 0\n        ans = 0\n\n        while x != 1:\n            PrimeFactors.append(SPF[x])\n            ans = ans + ((nCrModp_Lucas(n, r, PrimeFactors[i]) *\n                          (m // PrimeFactors[i]) *\n                          (power(m // PrimeFactors[i], PrimeFactors[i] - 2,\n                                 PrimeFactors[i]))) % m)\n            i += 1\n            x = x // SPF[x]\n\n        return ans % m\n",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\n/**\n * @param {number} n\n * @param {number} r\n * @param {number} m\n * @returns {number}\n*/\n\nclass Solution {\n    //Function to find nCr under modulo p.\n    nCrModM(n, r, m) {\n        // Function to find the least prime factor of numbers up to n\n        function leastPrimeFactor(n) {\n            let least_prime = new Array(n + 1).fill(0);\n            least_prime[1] = 1;\n\n            for (let i = 2; i <= n; i++) {\n                if (least_prime[i] == 0) {\n                    least_prime[i] = i;\n\n                    for (let j = 2 * i; j <= n; j += i) {\n                        // Marking multiples of i as non-prime\n                        if (least_prime[j] == 0) {\n                            least_prime[j] = i;\n                        }\n                    }\n                }\n            }\n            return least_prime;\n        }\n\n        // Function to compute x^y under modulo m using recursion\n        function power(x, y, m) {\n            if (y == 0) {\n                return 1;\n            }\n            let p = power(x, Math.floor(y / 2), m) % m;\n            p = (p * p) % m;\n            if (y % 2 == 0) {\n                return p;\n            } else {\n                return ((x * p) % m);\n            }\n        }\n\n        // Function to compute nCr % p (for prime p) using modular arithmetic\n        function ncr_kris(n, r, p) {\n            if (n < r) {\n                return 0;\n            }\n            if (r > n - r) {\n                r = n - r;\n            }\n\n            let num = 1;\n            let den = 1;\n\n            for (let i = 0; i < r; i++) {\n                num = (num * (n - i)) % p;\n                den = (den * (i + 1)) % p;\n            }\n\n            let ans = (num * power(den, p - 2, p)) % p;\n\n            return ans;\n        }\n\n        // Function to convert a number to another base\n        function toBaseB(N, B) {\n            let digits = [];\n\n            while (N > 0) {\n                digits.unshift(N % B);\n                N = Math.floor(N / B);\n            }\n\n            return digits;\n        }\n\n        // Function to compute nCr % p using Lucas's theorem\n        function nCrModp_Lucas(n, r, p) {\n            let m = toBaseB(n, p);\n            n = toBaseB(r, p);\n            let l1 = m.length;\n            let l2 = n.length;\n            let ans = 1;\n\n            for (let i = 0; i < l2; i++) {\n                ans = (ans * ncr_kris(m[(l1-l2) + i], n[i], p)) % p;\n            }\n\n            return ans;\n        }\n\n        let SPF = leastPrimeFactor(m);\n        let PrimeFactors = [];\n        let x = m;\n        let i = 0;\n        let ans = 0;\n\n        while (x != 1) {\n            PrimeFactors.push(SPF[x]);\n            ans = ans + ((nCrModp_Lucas(n, r, PrimeFactors[i]) * (Math.floor(m/PrimeFactors[i])) * (power(Math.floor(m/PrimeFactors[i]), PrimeFactors[i] - 2, PrimeFactors[i]))) % m);\n            i += 1;\n            x = Math.floor(x / SPF[x]);\n        }\n\n        return ans % m;\n    }\n}",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}