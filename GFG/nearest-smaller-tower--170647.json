{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 714254,
            "title": "Nearest smaller tower",
            "titleSlug": "nearest-smaller-tower--170647",
            "content": "<p><span style=\"font-size:18px\">Given an array where each element (<strong>arr[i]</strong>) represents the height of the tower. Find for each tower, the nearest possible tower that is shorter than it. You can look left or right on both sides.<br />\r\n<strong>Note :&nbsp;</strong></span></p>\r\n\r\n<ul>\r\n\t<li>\r\n\t<p><span style=\"font-size:18px\">If&nbsp;two smaller towers&nbsp;are at the same distance, pick the smallest tower.</span></p>\r\n\t</li>\r\n\t<li>\r\n\t<p><span style=\"font-size:18px\">If two towers have the same height then we choose the one with a smaller index.</span></p>\r\n\t</li>\r\n</ul>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong> \r\narr[] = {1,3,2}</span>\r\n<span style=\"font-size:18px\"><strong>Output:</strong> \r\n{-1,0,0}</span>\r\n<strong><span style=\"font-size:18px\">Explanation:</span></strong>\r\n<span style=\"font-size:18px\">For <strong>0th</strong> Index : no tower is smallest, so <strong>-1</strong>.\r\nFor <strong>1st</strong> Index : For 3, here 1 &amp; 2 both are \r\nsmall &amp; at a same distance, so we will pick 1, \r\nbeacuse it has smallest value, so <strong>0(Index)</strong>\r\nFor <strong>2nd</strong> Index : here 1 is smaller, so <strong>0(Index)\r\n</strong></span><span style=\"font-size:18px\">So the final output will be which consistes \r\nIndexes are {-1,0,0}.</span>\r\n</pre>\r\n\r\n<p><strong><span style=\"font-size:18px\">Example 2:</span></strong></p>\r\n\r\n<pre>\r\n<strong><span style=\"font-size:18px\">Input: \r\n</span></strong><span style=\"font-size:18px\">arr[] = {4,8,3,5,3}</span>\r\n<strong><span style=\"font-size:18px\">Output: \r\n</span></strong><span style=\"font-size:18px\">{2,2,-1,2,-1}\r\n</span>\r\n<strong><span style=\"font-size:18px\">Explanation:</span></strong> \r\n<span style=\"font-size:18px\">For <strong>0th</strong> Index : here 3 is the smaller, so <strong>2(Index)</strong> \r\nFor <strong>1st</strong> Index : For 8, here 4 &amp; 3 both are\r\nsmall &amp; at a same distance, so we will pick 3, so <strong>2(Index)</strong>\r\nFor <strong>2nd</strong> Index : no tower is smallest, so <strong>-1</strong>.\r\nFor <strong>3rd</strong> Index : For 5, here 3 &amp; 3 both are\r\nsmall &amp; at a same distance, so we will pick \r\n<strong>3</strong>(2nd Index) because it smaller Index, so <strong>2(Index)\r\n</strong>For <strong>4th</strong> Index : no tower is smallest, so <strong>-1</strong>.</span>\r\n<span style=\"font-size:18px\">So the final output will be which consistes\r\nIndexes are {2,2,-1,2,-1}.</span>\r\n</pre>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Your Task:</strong><br />\r\nYou don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>nearestSmallerTower()&nbsp;</strong>which takes an array of heights&nbsp;of the towers&nbsp;as input parameter and returns an array of <strong>indexes</strong> of the nearest smaller tower. If there is no smaller tower on both sides then<strong> return -1</strong> for that tower.</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong>&nbsp;O(N)<br />\r\n<strong>Expected Auxiliary Space:</strong>&nbsp;O(N)&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Constraints:</strong></span><br />\r\n<span style=\"font-size:18px\">1 &lt;= N &lt;= 10<sup>5</sup><br />\r\n1 &lt;= arr[i]&nbsp;&lt;= 10<sup>5</sup></span></p>\r\n\r\n<p>&nbsp;</p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given an array `arr` where each element `arr[i]` represents the height of a tower, find, for each tower, the index of the nearest shorter tower. You can look to both the left and the right.  If no shorter tower exists, return -1.\n\n*   If two shorter towers are at the same distance, choose the smallest tower.\n*   If two towers have the same height, choose the one with the smaller index.",
                "constraints": [
                    "1 <= N <= 10^5",
                    "1 <= arr[i] <= 10^5"
                ],
                "testcases": [
                    {
                        "input": "[1,3,2]",
                        "output": "[-1,0,0]",
                        "explanation": "For index 0 (height 1), there is no shorter tower, so the output is -1.  For index 1 (height 3), towers at index 0 (height 1) and index 2 (height 2) are both shorter and equidistant. Since 1 < 2, the tower at index 0 is chosen. For index 2 (height 2), the tower at index 0 (height 1) is shorter, so the output is 0."
                    },
                    {
                        "input": "[4,8,3,5,3]",
                        "output": "[2,2,-1,2,-1]",
                        "explanation": "For index 0 (height 4), the tower at index 2 (height 3) is shorter, so the output is 2. For index 1 (height 8), the towers at indices 0 (height 4) and 2 (height 3) are shorter and equidistant. Since 3 < 4, the tower at index 2 is chosen. For index 2 (height 3), there is no shorter tower, so the output is -1. For index 3 (height 5), the towers at indices 2 (height 3) and 4 (height 3) are shorter and equidistant. Since 2 < 4, the tower at index 2 is chosen.  For index 4 (height 3), there is no shorter tower, so the output is -1."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Can we think of a data structure to store only smaller element in&nbsp;the left side or right side of a element?</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Arrays",
                "slug": "arrays"
            },
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [
            "atlassian"
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\n\nclass Solution\n{\npublic:\n    //Function to find nearest smaller tower for each tower in the given array.\n    vector<int> nearestSmallerTower(vector<int> &arr)\n    {\n        int n = arr.size();\n        stack<int> pre, suf;\n        vector<int> res(n, -1);\n\n        //Iterating through the array from left to right.\n        for (int i = 0; i < n; i++)\n        {\n            //Removing the towers from the stack that are higher or equal to \n            //the current tower.\n            while (!pre.empty() && arr[pre.top()] >= arr[i])\n            {\n                pre.pop();\n            }\n\n            //Checking if there is a nearest smaller tower on the left side.\n            if (!pre.empty())\n            {\n                res[i] = pre.top();\n            }\n\n            //Pushing the current tower's index into the stack.\n            pre.push(i);\n        }\n\n        //Iterating through the array from right to left.\n        for (int i = n - 1; i >= 0; i--)\n        {\n            //Removing the towers from the stack that are higher or equal to \n            //the current tower.\n            while (!suf.empty() && arr[suf.top()] >= arr[i])\n            {\n                suf.pop();\n            }\n\n            //Checking if there is a nearest smaller tower on the right side.\n            if (!suf.empty())\n            {\n                //Checking if the nearest smaller tower on the left and right side\n                //are equidistant from the current tower.\n                if (res[i] != -1)\n                {\n                    if (abs(res[i] - i) == abs(suf.top() - i))\n                    {\n                        //Choosing the tower with the smaller height if both towers \n                        //are equidistant.\n                        if (arr[res[i]] > arr[suf.top()])\n                            res[i] = suf.top();\n                    }\n                    //Updating the nearest smaller tower if the tower on the right side\n                    //is closer than the tower on the left side.\n                    else if (abs(res[i] - i) > abs(suf.top() - i))\n                        res[i] = suf.top();\n                }\n                //Updating the nearest smaller tower if there was no nearest smaller tower\n                //on the left side of the current tower.\n                else\n                    res[i] = suf.top();\n            }\n\n            //Pushing the current tower's index into the stack.\n            suf.push(i);\n        }\n\n        //Returning the array containing the indices of the nearest smaller towers.\n        return res;\n    }\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution{\r\n\tint [] nearestSmallestTower(int [] arr){\r\n        int n = arr.length;\r\n        Stack<Integer> pre = new Stack<>();\r\n        Stack<Integer> suf = new Stack<>();\r\n        int [] res = new int[n];\r\n        Arrays.fill(res, -1);\r\n\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            while (!pre.empty() && arr[pre.peek()] >= arr[i])\r\n            {\r\n                pre.pop();\r\n            }\r\n\r\n            if (!pre.empty())\r\n            {\r\n                res[i] = pre.peek();\r\n            }\r\n\r\n            pre.push(i);\r\n        }\r\n\r\n        for (int i = n - 1; i >= 0; i--)\r\n        {\r\n            while (!suf.empty() && arr[suf.peek()] >= arr[i])\r\n            {\r\n                suf.pop();\r\n            }\r\n\r\n            if (!suf.empty())\r\n            {\r\n\r\n                if (res[i] != -1)\r\n                {\r\n                    if (Math.abs(res[i] - i) == Math.abs(suf.peek() - i))\r\n                    {\r\n                        if (arr[res[i]] > arr[suf.peek()])\r\n                            res[i] = suf.peek();\r\n                    }\r\n                    else if (Math.abs(res[i] - i) > Math.abs(suf.peek() - i))\r\n                        res[i] = suf.peek();\r\n                }\r\n                else\r\n                    res[i] = suf.peek();\r\n            }\r\n\r\n            suf.push(i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "#Back-end complete function Template for Python 3\r\n\r\nclass Solution:\r\n    def nearestSmallestTower(self,arr):\r\n        #code here\r\n        suff=[]\r\n        n=len(arr)\r\n        findsuff=[0]*n #building suffix\r\n        for i in range(n-1,-1,-1):\r\n            if len(suff)==0:\r\n                findsuff[i]=-1\r\n                suff.append([arr[i],i])\r\n            else:\r\n                while suff:\r\n                    if suff[-1][0]<arr[i]:\r\n                        findsuff[i]=suff[-1][1]\r\n                        break\r\n                    suff.pop()\r\n                if len(suff)==0:\r\n                    findsuff[i]=-1\r\n                suff.append([arr[i],i])\r\n        pre=[]\r\n        findpre=[0]*n #building prefix\r\n        for i in range(n):\r\n            if len(pre)==0:\r\n                findpre[i]=-1\r\n                pre.append([arr[i],i])\r\n            else:\r\n                while pre:\r\n                    if pre[-1][0]<arr[i]:\r\n                        findpre[i]=pre[-1][1]\r\n                        break\r\n                    pre.pop()\r\n                if len(pre)==0:\r\n                    findpre[i]=-1\r\n                pre.append([arr[i],i])\r\n        new=[0]*n #comparing both\r\n        for i in range(n):\r\n            if findsuff[i]==-1:\r\n                new[i]=findpre[i]\r\n                continue\r\n            if findpre[i]==-1:\r\n                new[i]=findsuff[i]\r\n                continue\r\n            if abs(findsuff[i]-i)==abs(findpre[i]-i):\r\n                if arr[findsuff[i]]>=arr[findpre[i]]:\r\n                    new[i]=findpre[i]\r\n                else:\r\n                    new[i]=findsuff[i]\r\n            elif abs(findsuff[i]-i)>abs(findpre[i]-i):\r\n                new[i]=findpre[i]\r\n            else:\r\n                new[i]=findsuff[i]\r\n        return new  ",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\n/**\n * @param {number[]} arr\n * @returns {number[]}\n*/\n\nclass Solution {\n    //Function to find the nearest smallest numbers to every element in the array.\n    nearestSmallestTower(arr)\n    {\n        //creating a suffix stack\n        let suff=[];\n        let n=arr.length;\n        let findsuff=new Array(n).fill(0); //building suffix\n        \n        //iterating the array from right to left.\n        for(let i=n-1;i>=0;i--){\n            //if stack is empty, then theres no smaller tower\n            if(suff.length==0){\n                findsuff[i]=-1;\n                suff.push([arr[i],i]);\n            }else{\n                //until suff stack is not empty, we will keep comparing with arr[i]\n                while(suff.length>0){\n                    //if last element of stack is smaller than arr[i] =>then we will add i to findsuff\n                    if(suff[suff.length-1][0]<arr[i]){\n                        findsuff[i]=suff[suff.length-1][1];\n                        break;\n                    }\n                    //if it is larger than arr[i]=> we will keep removing elements\n                    suff.pop();\n                }\n                //if stack becomes empty then no smaller element\n                if(suff.length==0){\n                    findsuff[i]=-1;\n                }\n                suff.push([arr[i],i]);\n            }\n        }\n        \n        //creating a prefix stack\n        let pre=[];\n        let findpre=new Array(n).fill(0); //building prefix\n        \n        //iterating the array from left to right.\n        for(let i=0;i<n;i++){\n            //if stack is empty, then theres no smaller tower\n            if(pre.length==0){\n                findpre[i]=-1;\n                pre.push([arr[i],i]);\n            }else{\n                //until pre stack is not empty, we will keep comparing with arr[i]\n                while(pre.length>0){\n                    //if last element of stack is smaller than arr[i] =>then we will add i to findpre\n                    if(pre[pre.length-1][0]<arr[i]){\n                        findpre[i]=pre[pre.length-1][1];\n                        break;\n                    }\n                    //if it is larger than arr[i]=> we will keep removing elements\n                    pre.pop();\n                }\n                //if stack becomes empty then no smaller element\n                if(pre.length==0){\n                    findpre[i]=-1;\n                }\n                pre.push([arr[i],i]);\n            }\n        }\n        \n        //an array to compare\n        let newarr=new Array(n).fill(0); //comparing both\n        \n        //iterating the array\n        for(let i=0;i<n;i++){\n            //if there is no smaller element on the right\n            if(findsuff[i]==-1){\n                newarr[i]=findpre[i];\n                continue;\n            }\n            //if there is no smaller element on the left\n            if(findpre[i]==-1){\n                newarr[i]=findsuff[i];\n                continue;\n            }\n            //if the difference on right side and left side is same\n            if(Math.abs(findsuff[i]-i)==Math.abs(findpre[i]-i)){\n                //if height of tower at right side is smaller\n                if(arr[findsuff[i]]>=arr[findpre[i]]){\n                    newarr[i]=findpre[i];\n                }else{\n                    newarr[i]=findsuff[i];\n                }\n            //if the difference on right side is larger than left side\n            }else if(Math.abs(findsuff[i]-i)>Math.abs(findpre[i]-i)){\n                newarr[i]=findpre[i];\n            //if the difference on left side is larger than right side\n            }else{\n                newarr[i]=findsuff[i];\n            }\n        }\n        return newarr;\n    }\n}",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}