{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 700546,
            "title": "Nodes at given distance in binary tree",
            "titleSlug": "nodes-at-given-distance-in-binary-tree",
            "content": "<p><span style=\"font-size: 18px;\">Given a binary tree, a target node in the binary tree, and an integer value k, find all the nodes that are at a distance k from the given target node. No parent pointers are available.<br /><strong>Note</strong>: </span></p>\n<ul>\n<li><span style=\"font-size: 18px;\">You have to return the list in sorted order.</span></li>\n<li><span style=\"font-size: 18px;\">The tree will <strong>not </strong>contain <strong>duplicate </strong>values.</span></li>\n</ul>\n<p><strong><span style=\"font-size: 18px;\">Examples:</span></strong></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong> root = [1, 2, 3, 4, 5], target = 2, k = 2   \n</span><img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700546/Web/Other/blobid0_1733895958.png\" width=\"317\" height=\"283\" />\n<span style=\"font-size: 18px;\"><strong>Output:</strong> [3]</span>\n<span style=\"font-size: 18px;\"><strong>Explanation: </strong>Nodes at a distance 2 from the given node 2 is 3.</span>\n</pre>\n<pre><span ><strong>Input: </strong>root = [1, 2, 3, 4, 5, 6, 7], target = 3, k = 1<br /><img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700546/Web/Other/blobid1_1733896181.png\" width=\"324\" height=\"289\" />\n</span><span style=\"font-size: 18px;\"><span ><strong>Output:</strong> [1, 6, 7]<br /><strong style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">Explanation:</strong><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\"> Nodes at a distance 1 from the given target node 3 are 1, 6 &amp; 7.</span></span></span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; number of nodes &le; 10<sup>6</sup><br />1 &le;&nbsp; node-&gt;data &le; 10<sup>9</sup><br />1 &le; target &le; 10<sup>9</sup><br />1 &le; k &le; 20</span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p><span >Use DFS to map parent nodes, then BFS from the target node to find all nodes at a distance k&nbsp; while tracking visited nodes to avoid revisiting.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [
            "flipkart",
            "accolite",
            "amazon",
            "microsoft",
            "samsung",
            "hike",
            "ola-cabs",
            "walmart",
            "goldman-sachs"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "/* A binary Tree node\nstruct Node\n{\n    int data;\n    struct Node *left, *right;\n};\n*/\n\nclass Solution {\n\n  public:\n    // Map to store parent pointers of each node\n    unordered_map<Node *, Node *> mp;\n\n    // Preorder traversal to populate parent pointers and locate target node\n    void preorder(Node *root, Node *par, int target, Node *&tar) {\n        if (!root)\n            return;\n\n        // Store the parent of current node\n        mp[root] = par;\n\n        // Check if the current node is the target node\n        if (root->data == target) {\n            tar = root; // Set tar as the target node\n            return;\n        }\n\n        // Recursively traverse left and right subtrees\n        preorder(root->left, root, target, tar);\n        preorder(root->right, root, target, tar);\n    }\n\n    // Function to find all nodes at distance k from target node\n    vector<int> KDistanceNodes(Node *root, int target, int k) {\n\n        unordered_map<Node *, int> vis;    // Map to keep track of visited nodes\n        Node *tar = NULL;                  // Pointer to store the target node\n        preorder(root, NULL, target, tar); // Populate parent map and locate target\n\n        queue<pair<Node *, int>>\n            q;            // Queue for BFS traversal, stores node and its distance\n        vector<int> ans;  // Vector to store the result nodes at distance k\n        q.push({tar, 0}); // Start BFS from target node with distance 0\n        vis[tar] = 1;     // Mark target as visited\n\n        // BFS traversal to find all nodes at distance k\n        while (!q.empty()) {\n            auto temp = q.front();\n            q.pop();\n            Node *node = temp.first;\n            int dist = temp.second;\n\n            // If the node is at distance k, add it to the answer\n            if (dist == k)\n                ans.push_back(node->data);\n\n            // Explore left child if not visited\n            if (node->left && vis[node->left] == 0) {\n                q.push({node->left, dist + 1});\n                vis[node->left] = 1;\n            }\n\n            // Explore right child if not visited\n            if (node->right && vis[node->right] == 0) {\n                q.push({node->right, dist + 1});\n                vis[node->right] = 1;\n            }\n\n            // Explore parent node if it exists and is not visited\n            if (mp[node] != NULL && mp.find(node) != mp.end() &&\n                vis.find(mp[node]) == vis.end()) {\n                q.push({mp[node], dist + 1});\n                vis[mp[node]] = 1;\n            }\n        }\n\n        // Sort the result before returning to ensure nodes are in ascending order\n        sort(ans.begin(), ans.end());\n        return ans;\n    }\n};\n",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "// User function Template for Java\n\n// class Node\n// {\n//     int data;\n//     Node left, right;\n// }\n\nclass Solution {\n    // Function to find all nodes at distance k from the target node\n    public static ArrayList<Integer> KDistanceNodes(Node root, int target, int k) {\n        // To store parent pointers of each node\n        Map<Node, Node> parentMap = new HashMap<>();\n        // To store the nodes at distance k\n        ArrayList<Integer> result = new ArrayList<>();\n\n        // Step 1: Locate the target node and populate the parent pointers\n        Node targetNode = findAndMapParents(root, target, parentMap);\n\n        // Step 2: BFS traversal to find nodes at distance k from target\n        Set<Node> visited = new HashSet<>(); // Set to keep track of visited nodes\n        Queue<NodeDistancePair> queue = new LinkedList<>();\n        queue.add(new NodeDistancePair(targetNode, 0));\n        visited.add(targetNode);\n\n        while (!queue.isEmpty()) {\n            NodeDistancePair current = queue.poll();\n            Node node = current.node;\n            int dist = current.distance;\n\n            // If current node is at distance k, add it to the result list\n            if (dist == k) {\n                result.add(node.data);\n            }\n\n            // If distance is less than k, continue exploring children and parent\n            if (dist < k) {\n                // Explore left child\n                if (node.left != null && !visited.contains(node.left)) {\n                    queue.add(new NodeDistancePair(node.left, dist + 1));\n                    visited.add(node.left);\n                }\n                // Explore right child\n                if (node.right != null && !visited.contains(node.right)) {\n                    queue.add(new NodeDistancePair(node.right, dist + 1));\n                    visited.add(node.right);\n                }\n                // Explore parent node\n                Node parent = parentMap.get(node);\n                if (parent != null && !visited.contains(parent)) {\n                    queue.add(new NodeDistancePair(parent, dist + 1));\n                    visited.add(parent);\n                }\n            }\n        }\n\n        // Sort the result before returning\n        Collections.sort(result);\n        return result;\n    }\n\n    // Helper method to perform DFS and populate parent pointers and locate target node\n    private static Node findAndMapParents(Node root, int target,\n                                          Map<Node, Node> parentMap) {\n        Stack<Node> stack = new Stack<>();\n        stack.push(root);\n        Node targetNode = null;\n\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            if (node.data == target) {\n                targetNode = node;\n            }\n\n            if (node.left != null) {\n                parentMap.put(node.left, node);\n                stack.push(node.left);\n            }\n            if (node.right != null) {\n                parentMap.put(node.right, node);\n                stack.push(node.right);\n            }\n        }\n        return targetNode;\n    }\n}\n\n// Helper class to store node and its distance\nclass NodeDistancePair {\n    Node node;\n    int distance;\n\n    NodeDistancePair(Node node, int distance) {\n        this.node = node;\n        this.distance = distance;\n    }\n}\n",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "# User function Template for python3\n'''\n# Tree Node\nclass Node:\n    def __init__(self, val):\n        self.right = None\n        self.data = val\n        self.left = None\n'''\n\n\nclass Solution:\n\n    def KDistanceNodes(self, root, target, k):\n        # Dictionary to store parent pointers\n        parent_map = {}\n        # List to store nodes at distance k\n        result = []\n\n        # Step 1: Locate the target node and populate parent pointers\n        target_node = self.mapParentsAndLocateTarget(root, target, parent_map)\n\n        # Step 2: BFS traversal to find nodes at distance k from target\n        visited = set()  # Set to keep track of visited nodes\n        queue = deque([(target_node, 0)])\n        visited.add(target_node)\n\n        while queue:\n            node, dist = queue.popleft()\n\n            # If current node is at distance k, add it to the result list\n            if dist == k:\n                result.append(node.data)\n\n            # If distance is less than k, continue exploring children and parent\n            if dist < k:\n                # Explore left child\n                if node.left and node.left not in visited:\n                    queue.append((node.left, dist + 1))\n                    visited.add(node.left)\n\n                # Explore right child\n                if node.right and node.right not in visited:\n                    queue.append((node.right, dist + 1))\n                    visited.add(node.right)\n\n                # Explore parent node\n                if node in parent_map and parent_map[node] not in visited:\n                    queue.append((parent_map[node], dist + 1))\n                    visited.add(parent_map[node])\n\n        # Sort the result before returning\n        result.sort()\n        return result\n\n    # Helper method to perform DFS and populate parent pointers and locate target node\n    def mapParentsAndLocateTarget(self, root, target, parent_map):\n        stack = [root]\n        target_node = None\n\n        while stack:\n            node = stack.pop()\n            if node.data == target:\n                target_node = node\n\n            if node.left:\n                parent_map[node.left] = node\n                stack.append(node.left)\n            if node.right:\n                parent_map[node.right] = node\n                stack.append(node.right)\n\n        return target_node\n",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "\n\npublic class Solution {\n    private Dictionary<Node, Node> parentMap = new Dictionary<Node, Node>();\n    private List<int> result = new List<int>();\n\n    public List<int> KDistanceNodes(Node root, int target, int k) {\n        Node targetNode = MapParentsAndLocateTarget(root, target);\n\n        if (targetNode == null) return new List<int>();\n\n        FindKDistanceNodes(targetNode, k);\n        result.Sort();\n        return result;\n    }\n\n    private Node MapParentsAndLocateTarget(Node root, int target) {\n        Stack<Node> stack = new Stack<Node>();\n        stack.Push(root);\n        Node targetNode = null;\n\n        while (stack.Count > 0) {\n            Node node = stack.Pop();\n\n            if (node.data == target) targetNode = node;\n\n            if (node.left != null) {\n                parentMap[node.left] = node;\n                stack.Push(node.left);\n            }\n            if (node.right != null) {\n                parentMap[node.right] = node;\n                stack.Push(node.right);\n            }\n        }\n\n        return targetNode;\n    }\n\n    private void FindKDistanceNodes(Node targetNode, int k) {\n        Queue<(Node, int)> queue = new Queue<(Node, int)>();\n        HashSet<Node> visited = new HashSet<Node>();\n\n        queue.Enqueue((targetNode, 0));\n        visited.Add(targetNode);\n\n        while (queue.Count > 0) {\n            var (node, distance) = queue.Dequeue();\n\n            if (distance == k) result.Add(node.data);\n\n            if (distance < k) {\n                if (node.left != null && !visited.Contains(node.left)) {\n                    queue.Enqueue((node.left, distance + 1));\n                    visited.Add(node.left);\n                }\n\n                if (node.right != null && !visited.Contains(node.right)) {\n                    queue.Enqueue((node.right, distance + 1));\n                    visited.Add(node.right);\n                }\n\n                if (parentMap.ContainsKey(node) && !visited.Contains(parentMap[node])) {\n                    queue.Enqueue((parentMap[node], distance + 1));\n                    visited.Add(parentMap[node]);\n                }\n            }\n        }\n    }\n}\n",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "/*\nclass Node {\n    constructor(x) {\n        this.key = x;\n        this.left = null;\n        this.right = null;\n    }\n}\n*/\n\nclass Solution {\n    constructor() {\n        this.parentMap = new Map(); // To store the parent nodes for each node\n        this.result = [];           // To store the nodes at distance k from target\n    }\n\n    // Function to find all nodes at distance k from a target node\n    KDistanceNodes(root, target, k) {\n        // Map parent nodes and locate the target node\n        let targetNode = this.mapParentsAndLocateTarget(root, target);\n\n        // If target node is not found, return an empty array\n        if (!targetNode) return [];\n\n        // Find all nodes at distance k from the target node\n        this.findKDistanceNodes(targetNode, k);\n\n        // Sort the result before returning, as required\n        return this.result.sort((a, b) => a - b);\n    }\n\n    // Helper function to map parent nodes and locate the target node\n    mapParentsAndLocateTarget(root, target) {\n        const stack = [ root ]; // Stack for iterative traversal\n        let targetNode = null;\n\n        // Traverse all nodes to map parents and locate the target node\n        while (stack.length > 0) {\n            const node = stack.pop();\n\n            // If we find the target node, store it\n            if (node.key === target) targetNode = node;\n\n            // Map the parent for the left child and add left to the stack\n            if (node.left) {\n                this.parentMap.set(node.left, node);\n                stack.push(node.left);\n            }\n\n            // Map the parent for the right child and add right to the stack\n            if (node.right) {\n                this.parentMap.set(node.right, node);\n                stack.push(node.right);\n            }\n        }\n        return targetNode;\n    }\n\n    // Helper function to find all nodes at distance k from the target node\n    findKDistanceNodes(targetNode, k) {\n        const queue = [ [ targetNode, 0 ] ]; // Queue for BFS, storing [node, distance]\n        const visited = new Set();           // Set to keep track of visited nodes\n        visited.add(targetNode);\n\n        // Perform BFS to find nodes at distance k\n        while (queue.length > 0) {\n            const [node, distance] = queue.shift();\n\n            // If the current distance is k, add node's key to the result\n            if (distance === k) {\n                this.result.push(node.key);\n            }\n\n            // Continue BFS if current distance is less than k\n            if (distance < k) {\n                // Add the left child to the queue if not visited\n                if (node.left && !visited.has(node.left)) {\n                    queue.push([ node.left, distance + 1 ]);\n                    visited.add(node.left);\n                }\n\n                // Add the right child to the queue if not visited\n                if (node.right && !visited.has(node.right)) {\n                    queue.push([ node.right, distance + 1 ]);\n                    visited.add(node.right);\n                }\n\n                // Add the parent node to the queue if not visited\n                if (this.parentMap.has(node) &&\n                    !visited.has(this.parentMap.get(node))) {\n                    queue.push([ this.parentMap.get(node), distance + 1 ]);\n                    visited.add(this.parentMap.get(node));\n                }\n            }\n        }\n    }\n}\n",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}