{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 711153,
            "title": "Number Of Islands",
            "titleSlug": "number-of-islands",
            "content": "<p><span style=\"font-size:18px\">You are given a <strong>n,m</strong> which means the row and column of the 2D matrix and an array of &nbsp;size k denoting the number of operations. Matrix elements is 0 if there is water or 1 if there is land. Originally, the 2D matrix is all 0 which means there is no land in the matrix. The array has k operator(s) and each operator has two integer A[i][0], A[i][1] means that you can change the cell&nbsp;matrix[A[i][0]][A[i][1]] from sea to island. Return how many island are there in the matrix after each operation.You need to return an array of size <strong>k</strong>.<br />\r\n<strong>Note :&nbsp;</strong>An island means group of 1s such that they share a common side.</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong><span style=\"font-size:18px\">Example 1:</span></strong></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong> n = 4\r\nm = 5\r\nk = 4\r\nA = {{1,1},{0,1},{3,3},{3,4}}</span>\r\n\r\n<span style=\"font-size:18px\"><strong>Output:</strong> 1 1 2 2\r\n<strong>Explanation:</strong>\r\n0.  00000\r\n    00000\r\n    00000\r\n    00000\r\n1.  00000\r\n    01000\r\n    00000\r\n    00000\r\n2.  01000\r\n    01000\r\n    00000\r\n    00000\r\n3.  01000\r\n    01000\r\n    00000\r\n    00010\r\n4.  01000\r\n    01000\r\n    00000\r\n    00011</span></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong><span style=\"font-size:18px\">Example 2:</span></strong></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong> n = 4\r\nm = 5\r\nk = 4\r\nA = {{0,0},{1,1},{2,2},{3,3}}</span>\r\n\r\n<span style=\"font-size:18px\"><strong>Output:</strong> 1 2 3 4\r\n<strong>Explanation:</strong>\r\n0.  00000\r\n    00000\r\n    00000\r\n    00000\r\n1.  10000\r\n    00000\r\n    00000\r\n    00000\r\n2.  10000\r\n    01000\r\n    00000\r\n    00000\r\n3.  10000\r\n    01000\r\n    00100\r\n    00000\r\n4.  10000\r\n    01000\r\n    00100\r\n    00010</span></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Your Task:</strong><br />\r\nYou don&#39;t need to read or print anything. Your task is to complete the function numOfIslands() which takes an integer n denoting no. of rows in the matrix, an integer m denoting the number of columns in the matrix and a 2D array of size k denoting&nbsp; the number of operators.</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong>&nbsp;O(m * n)<br />\r\n<strong>Expected Auxiliary Space:</strong>&nbsp;O(m * n)</span></p>\r\n\r\n<p><strong><span style=\"font-size:18px\">Constraints:</span></strong></p>\r\n\r\n<p><span style=\"font-size:18px\">1 &lt;= n,m &lt;= 100<br />\r\n1 &lt;= k &lt;= 1000</span></p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "You are given the dimensions `n` and `m` representing the number of rows and columns of a 2D matrix, respectively. You are also provided with an array `A` of size `k`, where each element `A[i]` contains a pair of integers `(A[i][0], A[i][1])` representing the row and column index of a cell in the matrix.  Initially, all cells in the `n x m` matrix are 0, representing water.  Each operation in `A` changes the cell at the specified index from water (0) to land (1).  Your task is to determine the number of islands in the matrix after each operation and return an array of size `k` containing the number of islands after each operation. An island is defined as a group of connected 1s (land) that are adjacent horizontally or vertically.",
                "constraints": [
                    "1 <= n, m <= 100",
                    "1 <= k <= 1000"
                ],
                "testcases": [
                    {
                        "input": "n = 4\nm = 5\nk = 4\nA = {{1,1},{0,1},{3,3},{3,4}}",
                        "output": "1 1 2 2",
                        "explanation": "Initially, the matrix is all 0s.\n1. After the first operation, matrix[1][1] becomes 1. Number of islands: 1.\n2. After the second operation, matrix[0][1] becomes 1. Number of islands: 1 (the two 1s are adjacent).\n3. After the third operation, matrix[3][3] becomes 1. Number of islands: 2.\n4. After the fourth operation, matrix[3][4] becomes 1. Number of islands: 2 (the two 1s at the bottom are adjacent)."
                    },
                    {
                        "input": "n = 4\nm = 5\nk = 4\nA = {{0,0},{1,1},{2,2},{3,3}}",
                        "output": "1 2 3 4",
                        "explanation": "Initially, the matrix is all 0s.\n1. After the first operation, matrix[0][0] becomes 1. Number of islands: 1.\n2. After the second operation, matrix[1][1] becomes 1. Number of islands: 2.\n3. After the third operation, matrix[2][2] becomes 1. Number of islands: 3.\n4. After the fourth operation, matrix[3][3] becomes 1. Number of islands: 4."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Use&nbsp;union find algorithm.</p>"
        ],
        "relatedTopics": [
            {
                "name": "union-find",
                "slug": "union-find"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "// Back-end complete function Template for C++\r\nclass Solution {\r\n  public:\r\n    int p[100000];\r\n    int find(int x)\r\n    {\r\n        if (p[x] != x) p[x] = find(p[x]);\r\n        return p[x];\r\n    }\r\n    int index(int x, int y, int m)\r\n    {\r\n        return x * m + y;\r\n    }\r\n    vector<int> numOfIslands(int n, int m, vector<vector<int>> &operators) {\r\n        if (operators.empty())\r\n            return {};\r\n\r\n        vector<int> res;\r\n        unordered_set<int> nodes;\r\n        int s = operators.size();\r\n        unordered_set<int> current;\r\n        int dx[4] = {0, 1, 0, -1};\r\n        int dy[4] = {1, 0, -1, 0};\r\n        int total = 0;\r\n        \r\n        for(auto op : operators){\r\n            int pos = index(op[0], op[1], m);\r\n            nodes.insert(pos);\r\n            if (current.count(pos))\r\n            {\r\n                res.push_back(total);\r\n                continue;\r\n            }\r\n            total++;\r\n            p[pos] = pos;\r\n            for (int j = 0; j < 4; j++)\r\n            {\r\n                int nx = op[0] + dx[j];\r\n                int ny = op[1] + dy[j];\r\n                if (!(nx >= 0 && nx < n && ny >= 0 && ny < m)) \r\n                    continue;\r\n                if (current.count(index(nx, ny, m)))\r\n                {\r\n                    int apos = index(op[0], op[1], m);\r\n                    int bpos = index(nx, ny, m);\r\n                    if (find(apos) != find(bpos))\r\n                    {\r\n                        p[find(apos)] = find(bpos);\r\n                        total--;\r\n                    }\r\n                }\r\n            }\r\n\r\n            current.insert(index(op[0], op[1], m));\r\n            res.push_back(total);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\n// Solution class to compute the number of islands\n// based on given operators and dimensions of the grid\nclass Solution {\n   static final int[][] DIRS = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // Possible directions to check adjacent cells\n    \n    // Function to compute the number of islands\n    public List<Integer> numOfIslands(int rows, int cols, int[][] operators) {\n        if (isNullOrEmpty(operators)) return Collections.emptyList(); // If operators are empty, return empty list\n        \n        UF uf = new UF(rows * cols + 1); // Create an instance of the Union-Find data structure\n        List<Integer> result = new ArrayList<>(operators.length); // List to store the results\n        \n        // Iterate over the given operators\n        for (int[] op : operators) {\n            int curr = op[0] * cols + op[1] + 1; // Compute the current cell index\n            uf.addLand(curr); // Add the current cell to the land\n            \n            // Check adjacent cells and perform union operation if they are also lands\n            for (int[] dir : DIRS) {\n                int r = op[0] + dir[0]; // Compute the row index of adjacent cell\n                int c = op[1] + dir[1]; // Compute the column index of adjacent cell\n                int adj = r * cols + c + 1; // Compute the index of adjacent cell\n                \n                // Check if adjacent cell is safe and is a land\n                if (isSafe(rows, cols, r, c) && uf.isLand(adj)) {\n                    uf.union(curr, adj); // Perform union operation\n                }\n            }\n            \n            result.add(uf.nmbOfIslands()); // Compute the number of islands and add it to the result list\n        }\n        return result; // Return the list of number of islands for each operator\n    }\n    \n    // Function to check if a cell is safe\n    private boolean isSafe(int rows, int cols, int r, int c) {\n        return r >= 0 && r < rows && c >= 0 && c < cols; // Check if row and column indices are within the grid bounds\n    }\n    \n    // Function to check if an array is null or empty\n    private boolean isNullOrEmpty(int[][] arr) {\n        return arr.length == 0; // Check if the length of the array is zero\n    }\n}\n\n// Union Find class to perform union-find operations\nclass UF {\n    private final int[] parent; // Array to store the parent of each element\n    private final int[] rank; // Array to store the rank of each element\n    private int count = 0; // Number of components\n    \n    // Constructor to initialize the Union-Find data structure\n    UF(int n) {\n        parent = new int[n]; // Create parent array with size n\n        rank = new int[n]; // Create rank array with size n\n    }\n    \n    // Function to add a cell to the land\n    public void addLand(int p) {\n        if (isLand(p)) return; // If the cell is already a land, return\n        \n        parent[p] = p; // Set the parent of the cell to itself\n        rank[p] = 1; // Set the rank of the cell to 1\n        count++; // Increment the count of components\n    }\n    \n    // Function to check if a cell is a land\n    public boolean isLand(int p) {\n        return parent[p] > 0; // Check if the parent of the cell is greater than zero\n    }\n    \n    // Function to find the parent of an element using path compression\n    public int find(int p) {\n        while (p != parent[p]) {\n            parent[p] = parent[parent[p]]; // Path compression\n            p = parent[p]; // Update the element to its parent\n        }\n        return p; // Return the parent of the element\n    }\n    \n    // Function to perform union operation on two cells\n    public void union(int p, int q) {\n        int pr = find(p); // Find the parent of the first cell\n        int qr = find(q); // Find the parent of the second cell\n        if (pr == qr) return; // If both cells are already in the same component, return\n        \n        // Perform union by rank\n        if (rank[pr] < rank[qr]) {\n            parent[pr] = qr;\n        } else {\n            parent[qr] = pr;\n            if (rank[pr] == rank[qr]) rank[pr]++;\n        }\n        count--; // Decrement the count of components\n    }\n    \n    // Function to get the number of islands\n    public int nmbOfIslands() {\n        return count; // Return the count of components as the number of islands\n    }\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\n\nfrom heapq import *\nfrom typing import List\n\nclass Solution:\n  \n    # Function to count the number of islands\n    def numOfIslands(self, rows: int, cols : int, operators : List[List[int]]) -> List[int]:\n      \n        # Initialize graph as adjacency list\n        root = [i for i in range(rows * cols)]\n        rank = [1] * (rows * cols)\n        a = [[0] * cols for _ in range(rows)]\n        \n        # Function to find the root of a node\n        def find(x):\n            if root[x] == x:\n                return x\n\n            root[x] = find(root[x])\n            return root[x]\n        \n        # Function to perform union of two nodes\n        def union(x, y):\n            x, y = find(x), find(y)\n            if x == y:\n                return False\n            \n            if rank[x] > rank[y]:\n                root[y] = x\n            elif rank[y] > rank[x]:\n                root[x] = y\n            else:\n                root[y] = x\n                rank[x] += 1\n            \n            return True\n        \n        res = [1]\n        a[operators[0][0]][operators[0][1]] = 1\n        \n        for x, y in operators[1:]:\n            if a[x][y]:\n                res.append(res[-1])\n                continue\n            \n            a[x][y] = cnt = 1\n            for i, j in [(0, -1), (0, 1), (1, 0), (-1, 0)]:\n                p, q = i + x, y + j\n                if 0 <= p < rows and 0 <= q < cols and a[p][q]:\n                    cnt -= union(x * cols + y, p * cols + q)\n            \n            res.append(res[-1] + cnt)\n        \n        return res",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\n\nclass Solution {\n    // Function to count the number of islands.\n    numOfIslands(rows, cols, operators) {\n        let root = new Array(rows * cols).fill().map((_, i) => i);\n        let rank = new Array(rows * cols).fill(1);\n        let a = Array.from({ length: rows }, () => new Array(cols).fill(0));\n\n        const find = x => {\n            if (root[x] === x) return x;\n            root[x] = find(root[x]);\n            return root[x];\n        };\n\n        const union = (x, y) => {\n            x = find(x);\n            y = find(y);\n            if (x === y) return false;\n\n            if (rank[x] > rank[y]) {\n                root[y] = x;\n            } else if (rank[y] > rank[x]) {\n                root[x] = y;\n            } else {\n                root[y] = x;\n                rank[x]++;\n            }\n\n            return true;\n        };\n\n        let res = [1];\n        a[operators[0][0]][operators[0][1]] = 1;\n\n        for (let k = 1; k < operators.length; k++) {\n            let [x, y] = operators[k];\n            if (a[x][y]) {\n                res.push(res[res.length - 1]);\n                continue;\n            }\n\n            a[x][y] = 1;\n            let cnt = 1;\n            const directions = [[0, -1], [0, 1], [1, 0], [-1, 0]];\n            for (let [i, j] of directions) {\n                let p = i + x, q = y + j;\n                if (p >= 0 && p < rows && q >= 0 && q < cols && a[p][q]) {\n                    cnt -= union(x * cols + y, p * cols + q) ? 1 : 0;\n                }\n            }\n\n            res.push(res[res.length - 1] + cnt);\n        }\n\n        return res;\n    }\n}",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}