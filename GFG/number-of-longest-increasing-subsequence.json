{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 712383,
            "title": "Number of Longest Increasing Subsequence",
            "titleSlug": "number-of-longest-increasing-subsequence",
            "content": "<p><span style=\"font-size: 18px;\">Given an integer array&nbsp;<strong><code>arr</code></strong>, return&nbsp;the number of longest increasing subsequences.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Notice</strong>&nbsp;that the sequence has to be&nbsp;<strong>strictly</strong>&nbsp;increasing.</span></p>\n<p><strong><span style=\"font-size: 18px;\">Example:</span></strong></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input: </strong>arr = [1, 3, 5, 4, 7]\n<strong>Output: </strong>2\n<strong>Explanation: </strong>The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].</span></pre>\n<pre><span style=\"font-size: 18px;\"><strong>Input: </strong>arr = [2, 2, 2, 2, 2]\n<strong>Output: </strong>5\n<strong>Explanation: </strong>Each LIS has a Length of 1. </span></pre>\n<p><strong><span style=\"font-size: 18px;\">Constraint:</span></strong><br /><span style=\"font-size: 18px;\">1 &lt;= n &lt;= 2000<br />1 &lt;= arr[i] &lt;= 10<sup>5</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given an integer array `arr`, determine the number of longest increasing subsequences (LIS). A strictly increasing subsequence is a sequence where each element is greater than the previous one.",
                "constraints": [
                    "1 <= n <= 2000, where n is the length of the array `arr`",
                    "1 <= arr[i] <= 10^5 for each element in `arr`"
                ],
                "testcases": [
                    {
                        "input": "[1, 3, 5, 4, 7]",
                        "output": "2",
                        "explanation": "The longest increasing subsequences are [1, 3, 5, 7] and [1, 3, 4, 7], both having a length of 4."
                    },
                    {
                        "input": "[2, 2, 2, 2, 2]",
                        "output": "5",
                        "explanation": "Each element forms an increasing subsequence of length 1.  Since there are 5 elements, there are 5 such subsequences."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [],
        "relatedTopics": [],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class Solution {\n  public:\n    // Function to find the number of longest increasing subsequences\n    int numberofLIS(vector<int>& arr) {\n        int n = arr.size();\n        // Initializing dp array to store the length of the LIS ending at each index\n        vector<int> dp(n, 1);\n        // Initializing count array to store the count of LIS ending at each index\n        vector<int> ct(n, 1);\n\n        // Initializing the maximum LIS length as 1\n        int maxi = 1;\n\n        // Looping through each element in the array\n        for (int i = 0; i <= n - 1; i++) {\n            // Looping through all previous indices to compare with current element\n            for (int prev_index = 0; prev_index <= i - 1; prev_index++) {\n                // Checking if the current element is greater than the previous element\n                // and if adding the current element will increase the length of the LIS\n                if (arr[prev_index] < arr[i] && dp[prev_index] + 1 > dp[i]) {\n                    // Updating the length of the LIS ending at the current index\n                    dp[i] = dp[prev_index] + 1;\n                    // Inheriting the count of the LIS from the previous index\n                    ct[i] = ct[prev_index];\n                }\n                // Checking if the current element is greater than the previous element\n                // and if adding the current element will result in the same length of\n                // the LIS\n                else if (arr[prev_index] < arr[i] && dp[prev_index] + 1 == dp[i]) {\n                    // Increasing the count of the LIS ending at the current index\n                    ct[i] = ct[i] + ct[prev_index];\n                }\n            }\n            // Updating the maximum LIS length\n            maxi = max(maxi, dp[i]);\n        }\n\n        // Initializing the number of longest increasing subsequences as 0\n        int nos = 0;\n\n        // Looping through each element in the array\n        for (int i = 0; i <= n - 1; i++) {\n            // Checking if the length of the LIS ending at the current index is equal to\n            // the maximum length\n            if (dp[i] == maxi)\n                // Incrementing the number of longest increasing subsequences\n                nos += ct[i];\n        }\n\n        // Returning the number of longest increasing subsequences\n        return nos;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\nclass Solution {\n    public int numberofLIS(int arr[]) {\n        int n = arr.length;\n\n        // Array to store the length of the\n        // LIS ending at each element\n        int[] lis = new int[n];\n\n        // Array to store the number of LIS\n        // of that length ending at each element\n        int[] count = new int[n];\n\n        // Initialize LIS and count arrays\n        Arrays.fill(lis, 1);\n        Arrays.fill(count, 1);\n\n        // Variable to track the length of\n        // the longest LIS found\n        int maxLen = 1;\n\n        for (int i = 1; i < n; i++) {\n            for (int prev = 0; prev < i; prev++) {\n                if (arr[i] > arr[prev]) {\n\n                    // If a longer subsequence is found,\n                    // update the lis and reset the count\n                    if (lis[i] < lis[prev] + 1) {\n                        lis[i] = lis[prev] + 1;\n                        count[i] = count[prev];\n                    }\n\n                    // If another subsequence of the\n                    // same length is found, add to the\n                    // count\n                    else if (lis[i] == lis[prev] + 1) {\n                        count[i] += count[prev];\n                    }\n                }\n            }\n            if (lis[i] > maxLen) {\n                maxLen = lis[i];\n            }\n        }\n\n        // Sum up counts of subsequences that\n        // have the maximum length\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (lis[i] == maxLen) {\n                res += count[i];\n            }\n        }\n\n        return res;\n    }\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\n\n\nclass Solution:\n\n    def numberofLIS(self, arr):\n        n = len(arr)\n        dp = [1\n              ] * n  #initialize a list dp with length n, all elements set to 1\n        ct = [\n            1\n        ] * n  #initialize another list ct with length n, all elements set to 1\n\n        maxi = 1  #initialize a variable maxi to 1\n        for i in range(0, n):  #iterate over the range from 0 to n\n            for j in range(0, i):  #iterate over the range from 0 to i\n                if (\n                        arr[j] < arr[i] and dp[j] + 1 > dp[i]\n                ):  #if the element at index j in arr is less than the element at index i in arr AND the value at index j in dp plus one is greater than the value at index i in dp\n                    dp[i] = dp[\n                        j] + 1  #update the value at index i in dp to the value at index j in dp plus one\n                    ct[i] = ct[\n                        j]  #update the value at index i in ct to the value at index j in ct\n                elif (\n                        arr[j] < arr[i] and dp[j] + 1 == dp[i]\n                ):  #if the element at index j in arr is less than the element at index i in arr AND the value at index j in dp plus one is equal to the value at index i in dp\n                    ct[i] = ct[i] + ct[\n                        j]  #update the value at index i in ct to the value at index i in ct plus the value at index j in ct\n            maxi = max(\n                maxi, dp[i]\n            )  #update the value of maxi to the maximum value between maxi and the value at index i in dp\n\n        nos = 0  #initialize a variable nos to 0\n        for i in range(0, n):  #iterate over the range from 0 to n\n            if (dp[i] == maxi\n                ):  #if the value at index i in dp is equal to maxi\n                nos = nos + ct[\n                    i]  #update the value of nos to the current value of nos plus the value at index i in ct\n\n        return nos  #return the value of nos\n",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "class Solution {\n    public int numberofLIS(List<int> arr) {\n        int n = arr.Count;\n        // Initializing dp array to store the length of the LIS ending at each index\n        List<int> dp = new List<int>(n);\n        for (int i = 0; i < n; i++) {\n            dp.Add(1);\n        }\n\n        // Initializing count array to store the count of LIS ending at each index\n        List<int> ct = new List<int>(n);\n        for (int i = 0; i < n; i++) {\n            ct.Add(1);\n        }\n\n        // Initializing the maximum LIS length as 1\n        int maxi = 1;\n\n        // Looping through each element in the array\n        for (int i = 0; i <= n - 1; i++) {\n            // Looping through all previous indices to compare with current element\n            for (int prev_index = 0; prev_index <= i - 1; prev_index++) {\n                // Checking if the current element is greater than the previous element\n                // and if adding the current element will increase the length of the LIS\n                if (arr[prev_index] < arr[i] && dp[prev_index] + 1 > dp[i]) {\n                    // Updating the length of the LIS ending at the current index\n                    dp[i] = dp[prev_index] + 1;\n                    // Inheriting the count of the LIS from the previous index\n                    ct[i] = ct[prev_index];\n                }\n                // Checking if the current element is greater than the previous element\n                // and if adding the current element will result in the same length of\n                // the LIS\n                else if (arr[prev_index] < arr[i] && dp[prev_index] + 1 == dp[i]) {\n                    // Increasing the count of the LIS ending at the current index\n                    ct[i] = ct[i] + ct[prev_index];\n                }\n            }\n            // Updating the maximum LIS length\n            maxi = Math.Max(maxi, dp[i]);\n        }\n\n        // Initializing the number of longest increasing subsequences as 0\n        int nos = 0;\n\n        // Looping through each element in the array\n        for (int i = 0; i <= n - 1; i++) {\n            // Checking if the length of the LIS ending at the current index is equal to\n            // the maximum length\n            if (dp[i] == maxi) {\n                // Incrementing the number of longest increasing subsequences\n                nos += ct[i];\n            }\n        }\n\n        // Returning the number of longest increasing subsequences\n        return nos;\n    }\n}",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "// User function Template for javascript\n/**\n * @param {number} n\n * @param {number[]} arr\n * @returns {number}\n */\n\nclass Solution {\n    // Function to find the number of strictly increasing subarrays.\n    numberofLIS(arr) {\n        let n = arr.length;\n        let dp = new Array(n).fill(\n            1); // initialize a list dp with length n, all elements set to 1\n        let ct = new Array(n).fill(\n            1); // initialize another list ct with length n, all elements set to 1\n\n        let maxi = 1;                     // initialize a variable maxi to 1\n        for (let i = 0; i < n; i++) {     // iterate over the range from 0 to n\n            for (let j = 0; j < i; j++) { // iterate over the range from 0 to i\n                if (arr[j] < arr[i] &&\n                    dp[j] + 1 > dp[i]) { // if the element at index j in arr is less\n                                         // than the element at index i in arr AND the\n                                         // value at index j in dp plus one is greater\n                                         // than the value at index i in dp\n                    dp[i] = dp[j] + 1; // update the value at index i in dp to the value\n                                       // at index j in dp plus one\n                    ct[i] = ct[j]; // update the value at index i in ct to the value at\n                                   // index j in ct\n                } else if (arr[j] < arr[i] &&\n                           dp[j] + 1 ==\n                               dp[i]) { // if the element at index j in arr is less than\n                                        // the element at index i in arr AND the value\n                                        // at index j in dp plus one is equal to the\n                                        // value at index i in dp\n                    ct[i] = ct[i] +\n                            ct[j]; // update the value at index i in ct to the value at\n                                   // index i in ct plus the value at index j in ct\n                }\n            }\n            maxi =\n                Math.max(maxi, dp[i]); // update the value of maxi to the maximum value\n                                       // between maxi and the value at index i in dp\n        }\n\n        let nos = 0;                  // initialize a variable nos to 0\n        for (let i = 0; i < n; i++) { // iterate over the range from 0 to n\n            if (dp[i] == maxi) {      // if the value at index i in dp is equal to maxi\n                nos = nos + ct[i];    // update the value of nos to the current value of\n                                      // nos plus the value at index i in ct\n            }\n        }\n\n        return nos; // return the value of nos\n    }\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}