{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 700240,
            "title": "Binary Heap Operations",
            "titleSlug": "operations-on-binary-min-heap",
            "content": "<p><span style=\"font-size: 18px;\">A <strong>binary heap</strong> is a Binary Tree with the following properties:<br /><strong>1)</strong> Its a <em>complete tree</em><strong> </strong>(All levels are completely filled except possibly the last level and the last level has all keys as left as possible). This property of Binary Heap makes them suitable to be stored in an array.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>2)</strong> A Binary Heap is either <strong>Min Heap</strong> or <strong>Max Heap</strong>. In a <em>Min Binary Heap</em>, the key at the&nbsp;<em>root</em> must be <em>minimum</em><strong> </strong>among all keys present in Binary Heap. The same property must be recursively true for all nodes in Binary Tree. Max Binary Heap is similar to MinHeap.</span></p>\n<p><span style=\"font-size: 18px;\">You are given an empty Binary Min Heap and some queries and your task is to implement the three methods <strong>insertKey, &nbsp;deleteKey, </strong>&nbsp;and&nbsp;<strong>extractMin </strong>on&nbsp;the Binary Min Heap and call them as per the query given below:<br /><strong>1) </strong><em>1 &nbsp;x</em> &nbsp;(a query of this type means to insert an element in the min-heap with value x&nbsp;)<br /><strong>2)</strong> <em>2 &nbsp;x</em> &nbsp;(a query of this type means to remove an element at position x from the min-heap)<br /><strong>3)</strong><strong> </strong><em>3</em> &nbsp;(a query like this removes&nbsp;the min element from the min-heap and prints it&nbsp;).</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Examples :</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input: <br /></strong></span><span style=\"font-size: 18px;\">Q = 7\nQueries:\ninsertKey(4)\ninsertKey(2)\nextractMin()\ninsertKey(6)\ndeleteKey(0)\nextractMin()\nextractMin()\n<strong>Output: </strong>[2, 6, -1]<strong>\nExplanation: </strong>In the first test case for\nquery&nbsp;\ninsertKey(4) the heap will have &nbsp;{4}&nbsp;&nbsp;\ninsertKey(2) the heap will be {2 4}\nextractMin()&nbsp;removes min element from \n&nbsp;\\t\\theap ie 2 and prints it\n&nbsp;\\t\\tnow heap is {4}&nbsp;\ninsertKey(6)&nbsp;inserts 6 to heap now heap\n&nbsp;\\t\\tis {4 6}\ndeleteKey(0)&nbsp;delete element at position 0\n\\t\\t of the heap,now heap is {6}\nextractMin() remove min element from heap\n\\t\\t ie 6 and prints it&nbsp;&nbsp;now the\n&nbsp;\\t\\theap is empty\nextractMin() since the heap is empty thus\n\\t\\t no min element exist so -1\n&nbsp;\\t\\tis printed.</span>\n</pre>\n<pre><span style=\"font-size: 18px;\"><strong>Input:\n</strong>Q = 5\nQueries:\ninsertKey(8)\ninsertKey(9)\ndeleteKey(1)\nextractMin()\nextractMin()\n<strong>Output: </strong>[8, -1]</span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &lt;= <strong>Q</strong> &lt;= 10<sup>4</sup><br />1 &lt;= <strong>x</strong> &lt;= 10<sup>4</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Implement a Binary Min Heap with the following operations:\n\n*   **insertKey(x):** Inserts the element 'x' into the min-heap.\n*   **deleteKey(x):** Removes the element at position 'x' (0-based index) from the min-heap.\n*   **extractMin():** Removes and returns the minimum element from the min-heap. If the heap is empty, return -1.\n\nA Binary Min Heap is a binary tree that satisfies the following properties:\n\n1.  It is a complete tree (all levels are completely filled except possibly the last level, and the last level has all keys as left as possible).\n2.  The key at the root must be the minimum among all keys present in the binary heap. This property must be recursively true for all nodes in the binary tree.\n\nYour task is to implement these three methods based on a sequence of queries.",
                "constraints": [
                    "1 <= Q <= 10^4",
                    "1 <= x <= 10^4"
                ],
                "testcases": [
                    {
                        "input": "Q = 7\nQueries:\ninsertKey(4)\ninsertKey(2)\nextractMin()\ninsertKey(6)\ndeleteKey(0)\nextractMin()\nextractMin()",
                        "output": "[2, 6, -1]",
                        "explanation": "1. insertKey(4): heap = {4}\n2. insertKey(2): heap = {2, 4}\n3. extractMin(): removes 2, prints 2, heap = {4}\n4. insertKey(6): heap = {4, 6}\n5. deleteKey(0): removes 4, heap = {6}\n6. extractMin(): removes 6, prints 6, heap = {}\n7. extractMin(): heap is empty, prints -1"
                    },
                    {
                        "input": "Q = 5\nQueries:\ninsertKey(8)\ninsertKey(9)\ndeleteKey(1)\nextractMin()\nextractMin()",
                        "output": "[8, -1]",
                        "explanation": "1. insertKey(8): heap = {8}\n2. insertKey(9): heap = {8, 9}\n3. deleteKey(1): removes 9, heap = {8}\n4. extractMin(): removes 8, prints 8, heap = {}\n5. extractMin(): heap is empty, prints -1"
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            ""
        ],
        "relatedTopics": [
            {
                "name": "Heap",
                "slug": "heap"
            },
            {
                "name": "Design-Pattern",
                "slug": "design-pattern"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [
            "amazon",
            "microsoft",
            "samsung",
            "ola-cabs",
            "walmart",
            "synopsys"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Function to insert a value in Heap.\r\nvoid MinHeap::insertKey(int k) \r\n{\r\n    heap_size++;\r\n    int i = heap_size - 1;\r\n    //inserting the value at leaf node.\r\n    harr[i] = k;\r\n\r\n    while (i != 0 && harr[parent(i)] > harr[i])\r\n    {\r\n        //swapping values of ith index with its parent node\r\n        //if value at parent node is greater.\r\n        swap(harr[i], harr[parent(i)]);\r\n        i = parent(i);\r\n    }\r\n}\r\n\r\n//Function to change value at ith index and store that value at first index.\r\nvoid MinHeap::decreaseKey(int i, int new_val)\r\n{\r\n    //storing new value at ith index.\r\n    harr[i] = new_val;\r\n    while (i != 0 && harr[parent(i)] > harr[i]) \r\n    {\r\n        //swapping values of ith index with its parent node\r\n        //if value at parent node is greater.\r\n        swap(harr[i], harr[parent(i)]);\r\n        i = parent(i);\r\n    }\r\n}\r\n\r\n//Function to extract minimum value in heap and then to store \r\n//next minimum value at first index.\r\nint MinHeap::extractMin() \r\n{\r\n    if (heap_size <= 0) return -1;\r\n    if (heap_size == 1) {\r\n        heap_size--;\r\n        return harr[0];\r\n    }\r\n\r\n    int root = harr[0];\r\n    //storing value of leaf node at first index.\r\n    harr[0] = harr[heap_size - 1];\r\n    harr[heap_size - 1] = 0;\r\n    heap_size--;\r\n\r\n    //calling heapify function for the first index.\r\n    MinHeapify(0); \r\n\r\n    return root;\r\n}\r\n\r\n//Function to delete a key at ith index.\r\nvoid MinHeap::deleteKey(int i)\r\n{\r\n    if (i < heap_size) \r\n    {\r\n        //decreasing value at ith index to minimum integer value.\r\n        decreaseKey(i, INT_MIN);\r\n        //extracting the minimum value from heap.\r\n        extractMin();\r\n    }\r\n}\r\n\r\n//MinHeapify function is used to heapify ith index.\r\nvoid MinHeap::MinHeapify(int i) \r\n{\r\n    int l = left(i);\r\n    int r = right(i);\r\n    int smallest = i;\r\n    \r\n    //if left or right child is smaller than current element, \r\n    //we store its position.\r\n    if (l < heap_size && harr[l] <harr[smallest]) \r\n        smallest = l;\r\n    if (r < heap_size && harr[r] < harr[smallest]) \r\n        smallest = r;\r\n        \r\n    //if smallest is not equal to i, we swap the values at their position.\r\n    if (smallest != i) \r\n    {\r\n        swap(harr[i], harr[smallest]);\r\n         //calling function recursively for the smallest index.\r\n        MinHeapify(smallest); \r\n    }\r\n}\r\n",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "// Back-end complete function Template for Java\r\n\r\nclass MinHeap \r\n{\r\n    int[] harr;\r\n    int capacity;\r\n    int heap_size;\r\n    int parent(int i) { return (i - 1) / 2; }\r\n    int left(int i) { return (2 * i + 1); }\r\n    int right(int i) { return (2 * i + 2); }\r\n\r\n    MinHeap(int cap) {\r\n        heap_size = 0;\r\n        capacity = cap;\r\n        harr = new int[cap];\r\n    }\r\n\r\n    //Function to insert a value in Heap.\r\n    void insertKey(int k)\r\n    {\r\n        heap_size++;\r\n        int i = heap_size - 1;\r\n        //inserting the value at leaf node.\r\n        harr[i] = k;\r\n\r\n        while (i != 0 && harr[parent(i)] > harr[i]) \r\n        {\r\n            //swapping values of ith index with its parent node\r\n            //if value at parent node is greater.\r\n            int temp = harr[i];\r\n            harr[i] = harr[parent(i)];\r\n            harr[parent(i)] = temp;\r\n            i = parent(i);\r\n        }\r\n    }\r\n\r\n    //Function to change value at ith index and store that value at first index.\r\n    void decreaseKey(int i, int new_val) \r\n    {\r\n        //storing new value at ith index.\r\n        harr[i] = new_val;\r\n        while (i != 0 && harr[parent(i)] > harr[i]) \r\n        {\r\n            //swapping values of ith index with its parent node\r\n            //if value at parent node is greater.\r\n            int temp = harr[i];\r\n            harr[i] = harr[parent(i)];\r\n            harr[parent(i)] = temp;\r\n            i = parent(i);\r\n        }\r\n    }\r\n\r\n    //Function to extract minimum value in heap and then to store \r\n    //next minimum value at first index.\r\n    int extractMin() \r\n    {\r\n        if (heap_size <= 0) return -1;\r\n        if (heap_size == 1) {\r\n            heap_size--;\r\n            return harr[0];\r\n        }\r\n        int root = harr[0];\r\n        \r\n        //storing value of leaf node at first index.\r\n        harr[0] = harr[heap_size - 1];\r\n        harr[heap_size - 1] = 0;\r\n        heap_size--;\r\n\r\n        //calling heapify function for the first index.\r\n        MinHeapify(0);\r\n\r\n        return root;\r\n    }\r\n\r\n    //Function to delete a key at ith index.\r\n    void deleteKey(int i) \r\n    {\r\n        if (i < heap_size) \r\n        {\r\n            //decreasing value at ith index to minimum integer value.\r\n            decreaseKey(i, Integer.MIN_VALUE);\r\n            //extracting the minimum value from heap.\r\n            extractMin();\r\n        }\r\n    }\r\n\r\n    //MinHeapify function is used to heapify ith index.\r\n    void MinHeapify(int i) \r\n    {\r\n        int l = left(i);\r\n        int r = right(i);\r\n        int smallest = i;\r\n        \r\n        //if left or right child is smaller than current element, \r\n        //we store its position.\r\n        if (l < heap_size && harr[l] < harr[i]) \r\n        smallest = l;\r\n        if (r < heap_size && harr[r] < harr[smallest]) \r\n        smallest = r;\r\n        \r\n        //if smallest is not equal to i, we swap the values at their position.\r\n        if (smallest != i) \r\n        {\r\n            int temp = harr[i];\r\n            harr[i] = harr[smallest];\r\n            harr[smallest] = temp;\r\n            \r\n            //calling function recursively for the smallest index.\r\n            MinHeapify(smallest);\r\n        }\r\n    }\r\n}\r\n",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\r\ndef getParent(x):  # get parent node , if exits else -1\r\n    return (x - 1) // 2\r\n\r\n\r\ndef leftChild(x):  # get left child if exists, else -1\r\n    return (2 * x + 1) if (2 * x + 1) < curr_size else -1\r\n\r\n\r\ndef rightChild(x):  # get right child if exits, else -1\r\n    return (2 * x + 2) if (2 * x + 2) < curr_size else -1\r\n\r\n#Function to maintain the min heap property of heap.\r\ndef heapify():\r\n    \r\n    curr_ind = curr_size - 1\r\n    while getParent(curr_ind) != -1 and heap[getParent(curr_ind)] > heap[curr_ind]:\r\n        heap[curr_ind], heap[getParent(curr_ind)]=heap[getParent(curr_ind)],heap[curr_ind]\r\n        curr_ind = getParent(curr_ind)\r\n\r\n    return\r\n\r\n\r\ndef heapifyDown(x):\r\n    \r\n    # if the removed index was leaf.\r\n    if x >= curr_size:  \r\n        return\r\n    \r\n    if getParent(x) != -1 and heap[x] < heap[getParent(x)]:\r\n        heap[x], heap[getParent(x)] = heap[getParent(x)], heap[x]\r\n        heapifyDown(getParent(x))\r\n        \r\n    if leftChild(x)==-1 or (leftChild(x)!=-1 and heap[x]<heap[leftChild(x)]):\r\n        if rightChild(x)==-1 or (rightChild(x)!=-1 and heap[x]<heap[rightChild(x)]):\r\n            return \r\n    \r\n    #swapping with left child and calling function recursively for left child. \r\n    if rightChild(x)==-1:\r\n        heap[x], heap[leftChild(x)] = heap[leftChild(x)], heap[x]\r\n        heapifyDown(leftChild(x))\r\n        \r\n    #swapping with right child and calling function recursively for right child.\r\n    elif leftChild(x) == -1:\r\n        heap[x], heap[rightChild(x)] = heap[rightChild(x)], heap[x]\r\n        heapifyDown(rightChild(x))\r\n        \r\n    #swapping with the minimum of the two childs.    \r\n    else:\r\n        if heap[rightChild(x)]<heap[leftChild(x)]:\r\n            heap[x], heap[rightChild(x)] = heap[rightChild(x)], heap[x]\r\n            heapifyDown(rightChild(x))\r\n        else:\r\n            heap[x], heap[leftChild(x)] = heap[leftChild(x)], heap[x]\r\n            heapifyDown(leftChild(x))\r\n    return\r\n\r\n\r\n#Function to insert a value in Heap.\r\ndef insertKey (x):\r\n    \r\n    global curr_size\r\n     #inserting value at current available index.\r\n    heap[curr_size] = x \r\n    curr_size += 1\r\n    #calling heapify function to maintain heap property.\r\n    heapify()  \r\n\r\n#Function to delete a key at ith index.\r\ndef deleteKey (i):\r\n    \r\n    global curr_size\r\n\r\n    if i >= curr_size: \r\n        return\r\n    #storing value of leaf node at ith index.\r\n    heap[i] = heap[curr_size - 1]\r\n    heap[curr_size - 1] = 0\r\n    curr_size -= 1  \r\n\r\n     #calling heapify function to maintain heap property from index i.\r\n    heapifyDown(i) \r\n\r\n#Function to extract minimum value in heap and then to store \r\n#next minimum value at first index.\r\ndef extractMin ():\r\n    \r\n    if curr_size == 0:  \r\n        return -1\r\n\r\n    #storing value at first index in a variable.\r\n    val = heap[0] \r\n    #deleting the value at first index.\r\n    deleteKey(0)   \r\n    return val   \r\n",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "// User function Template for C#\n\nclass MinHeap {\n    // Declaring the required variables and functions\n\n    private int[] harr;\n    private int heap_size;\n\n    // Constructor for initializing the variables\n    public MinHeap(int cap) {\n        heap_size = 0;\n        harr = new int[cap];\n    }\n\n    // Function to get index of parent of node at index i\n    private int parent(int i) { return (i - 1) / 2; }\n\n    // Function to get index of left child of node at index i\n    private int left(int i) { return (2 * i + 1); }\n\n    // Function to get index of right child of node at index i\n    private int right(int i) { return (2 * i + 2); }\n\n    // Function to extract minimum value in heap and then to store\n    // next minimum value at first index.\n    public int extractMin() {\n        if (heap_size <= 0) return -1;\n        if (heap_size == 1) {\n            heap_size--;\n            return harr[0];\n        }\n\n        int root = harr[0];\n        // storing value of leaf node at first index.\n        harr[0] = harr[heap_size - 1];\n        harr[heap_size - 1] = 0;\n        heap_size--;\n\n        // calling heapify function for the first index.\n        MinHeapify(0);\n\n        return root;\n    }\n\n    // Function to delete a key at ith index.\n    public void deleteKey(int i) {\n        if (i < heap_size) {\n            // decreasing value at ith index to minimum integer value.\n            decreaseKey(i, int.MinValue);\n            // extracting the minimum value from heap.\n            extractMin();\n        }\n    }\n\n    // Function to insert a value in Heap.\n    public void insertKey(int k) {\n        heap_size++;\n        int i = heap_size - 1;\n        // inserting the value at leaf node.\n        harr[i] = k;\n\n        while (i != 0 && harr[parent(i)] > harr[i]) {\n            // swapping values of ith index with its parent node\n            // if value at parent node is greater.\n            swap(harr, i, parent(i));\n            i = parent(i);\n        }\n    }\n\n    // Function to change value at ith index and store that value at first index.\n    public void decreaseKey(int i, int new_val) {\n        harr[i] = new_val;\n        while (i != 0 && harr[parent(i)] > harr[i]) {\n            // Swapping the elements if they don't satisfy the min heap property\n            swap(harr, i, parent(i));\n            i = parent(i);\n        }\n    }\n\n    /* You may call below MinHeapify function in\n       above codes. Please do not delete this code\n       if you are not writing your own MinHeapify */\n    public void MinHeapify(int i) {\n        int l = left(i);\n        int r = right(i);\n        int smallest = i;\n        if (l < heap_size && harr[l] < harr[i]) smallest = l;\n        if (r < heap_size && harr[r] < harr[smallest]) smallest = r;\n        if (smallest != i) {\n            // Swapping the elements if they don't satisfy the min heap property\n            swap(harr, i, smallest);\n            MinHeapify(smallest);\n        }\n    }\n\n    // Function to swap two elements in an integer array\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "\nclass MinHeap { \n    constructor(cap) {\n        this.heap_size = 0;\n        this.capacity = cap;\n        this.harr = new Array(cap);\n    }\n    \n    parent(i){\n      return Math.floor((i - 1) / 2); \n    }\n    \n    left(i){ \n      return (2 * i + 1);\n    }\n    \n    right(i){ \n      return (2 * i + 2); \n    }\n\n    insertKey(k) {\n        this.heap_size++;\n        let i = this.heap_size - 1;\n        this.harr[i] = k;\n\n        while (i !== 0 && this.harr[this.parent(i)] > this.harr[i]) {\n            let temp = this.harr[i];\n            this.harr[i] = this.harr[this.parent(i)];\n            this.harr[this.parent(i)] = temp;\n            i = this.parent(i);\n        }\n    }\n    \n    decreaseKey(i,  new_val) {\n        this.harr[i] = new_val;\n        while (i !== 0 && this.harr[this.parent(i)] > this.harr[i]) {\n            let temp = this.harr[i];\n            this.harr[i] = this.harr[this.parent(i)];\n            this.harr[this.parent(i)] = temp;\n            i = this.parent(i);\n        }\n    }\n\n    extractMin() {\n        if (this.heap_size <= 0) return -1;\n        \n        if (this.heap_size === 1) {\n            this.heap_size--;\n            return this.harr[0];\n        }\n\n        let root = this.harr[0];\n        this.harr[0] = this.harr[this.heap_size - 1];\n        this.harr[this.heap_size - 1] = 0;\n        this.heap_size--;\n        this.MinHeapify(0);\n\n        return root;\n    }\n\n    deleteKey(i) {\n        if (i < this.heap_size) {\n            this.decreaseKey(i, Number.MIN_SAFE_INTEGER);\n            this.extractMin();\n        }\n    }\n    \n    MinHeapify(i) {\n        let l = this.left(i);\n        let r = this.right(i);\n        let smallest = i;\n        \n        if (l < this.heap_size && this.harr[l] < this.harr[i]) smallest = l;\n        if (r < this.heap_size && this.harr[r] < this.harr[smallest]) smallest = r;\n        \n        if (smallest != i) {\n            let temp = this.harr[i];\n            this.harr[i] = this.harr[smallest];\n            this.harr[smallest] = temp;\n            this.MinHeapify(smallest);\n        }\n    }\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}