{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 705602,
            "title": "Phone directory",
            "titleSlug": "phone-directory4628",
            "content": "<p><span style=\"font-size: 18px;\">Given a list of contacts <strong>contact[]</strong>&nbsp;of length <strong>n</strong>&nbsp;where each contact is a string which exist in a phone directory and a query string <strong>s</strong>. The task is to implement a search query for the phone directory. Run a search query for each prefix <strong>p</strong> of the query string <strong>s&nbsp;</strong>(<em>i.e.</em> from&nbsp; index 1 to |s|) that prints all the distinct contacts which have the same prefix as p&nbsp;in <strong>lexicographical increasing&nbsp;order</strong>.&nbsp;Please refer the explanation part for better understanding.</span><br /><span style=\"font-size: 18px;\"><strong>Note: </strong>If there is no match between query and contacts, print \"0\".</span></p>\n<p><strong><span style=\"font-size: 18px;\">Example 1:</span></strong></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong> \nn = 3\ncontact[] = {\"geeikistest\", \"geeksforgeeks\", \n\"geeksfortest\"}\ns = \"geeips\"\n<strong>Output:</strong>\ngeeikistest geeksforgeeks geeksfortest\ngeeikistest geeksforgeeks geeksfortest\ngeeikistest geeksforgeeks geeksfortest\ngeeikistest\n0\n0\n<strong>Explaination:</strong> By running the search query on \ncontact list for \"g\" we get: \"geeikistest\", \n\"geeksforgeeks\" and \"geeksfortest\".\nBy running the search query on contact list \nfor \"ge\" we get: \"geeikistest\" \"geeksforgeeks\"\nand \"geeksfortest\".\nBy running the search query on contact list \nfor \"gee\" we get: \"geeikistest\" \"geeksforgeeks\"\nand \"geeksfortest\".\nBy running the search query on contact list \nfor \"geei\" we get: \"geeikistest\".\nNo results found for \"geeip\", so print \"0\". \nNo results found for \"geeips\", so print \"0\".</span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Your Task:</strong><br />You&nbsp;do not need to read input or print anything. Your task is to complete the function <strong>displayContacts()</strong> which takes <strong>n, contact[ ] </strong>and<strong> s</strong> as input parameters and returns a list of list of strings for required prefixes. If some prefix has no matching contact return&nbsp;\"0\" on that list.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:</strong> O(|s| * n * max|contact[i]|)<br /><strong>Expected Auxiliary Space:</strong> O(n * max|contact[i]|)</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; T&nbsp;&le; 100, T = number of test cases<br />1 &le;&nbsp;n &le;&nbsp;50<br />1 &le; |contact[i]| &le;&nbsp;50<br />1 &le;&nbsp;|s| &le;&nbsp;6&nbsp;</span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a list of contacts `contact[]` of length `n`, where each contact is a string representing an entry in a phone directory, and a query string `s`. Implement a search query for the phone directory. For each prefix `p` of the query string `s` (from index 1 to |s|), find all distinct contacts that have the same prefix as `p` and print them in lexicographical increasing order.\n\nNote: If no contacts match a given prefix, return \"0\".",
                "constraints": [
                    "1 <= n <= 50",
                    "1 <= |contact[i]| <= 50 (where contact[i] is a string in the contact list)",
                    "1 <= |s| <= 6 (where s is the query string)"
                ],
                "testcases": [
                    {
                        "input": "n = 3\ncontact[] = {\"geeikistest\", \"geeksforgeeks\", \"geeksfortest\"}\ns = \"geeips\"",
                        "output": "geeikistest geeksforgeeks geeksfortest\ngeeikistest geeksforgeeks geeksfortest\ngeeikistest geeksforgeeks geeksfortest\ngeeikistest\n0\n0",
                        "explanation": "For prefix \"g\": \"geeikistest\", \"geeksforgeeks\", and \"geeksfortest\" are matches.\nFor prefix \"ge\": \"geeikistest\", \"geeksforgeeks\", and \"geeksfortest\" are matches.\nFor prefix \"gee\": \"geeikistest\", \"geeksforgeeks\", and \"geeksfortest\" are matches.\nFor prefix \"geei\": \"geeikistest\" is a match.\nFor prefix \"geeip\": No matches, print \"0\".\nFor prefix \"geeips\": No matches, print \"0\"."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Use such a data structure which can find out the strings in which the prefix is present in linear time.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Map",
                "slug": "map"
            },
            {
                "name": "Trie",
                "slug": "trie"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Advanced Data Structure",
                "slug": "advanced-data-structure"
            }
        ],
        "companies": [
            "amazon",
            "microsoft",
            "snapdeal"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "// Back-end complete function Template for C++\n\nclass Solution{\npublic:\n    // Structure for Trie Node\n    struct TrieNode{\n    \tunordered_map<char,TrieNode*> child;\n    \tbool isLast;\n    \tTrieNode(){\n    \t\tfor (char i = 'a'; i <= 'z'; i++)\n    \t\t\tchild[i] = NULL;\n    \t\tisLast = false;\n    \t}\n    };\n    TrieNode *root = NULL;\n    \n    // Function to insert a string into the Trie\n    void insert(string s){\n    \tint len = s.length();\n    \tTrieNode *itr = root;\n    \tfor (int i = 0; i < len; i++){\n    \t\tTrieNode *nextNode = itr->child[s[i]];\n    \t\tif (nextNode == NULL){\n    \t\t\tnextNode = new TrieNode();\n    \t\t\titr->child[s[i]] = nextNode;\n    \t\t}\n    \t\titr = nextNode;\n    \t\tif (i == len - 1)\n    \t\t\titr->isLast = true;\n    \t}\n    }\n    \n    // Function to insert contact strings into the Trie\n    void insertIntoTrie(string s[],int n){\n    \troot = new TrieNode();\n    \tfor (int i = 0; i < n; i++)\n    \t\tinsert(s[i]);\n    }\n    \n    // Utility function to display contacts starting from given prefix\n    void displayContactsUtil(TrieNode *curNode, string prefix, \n                            vector<string> &vec){\n    \tif (curNode->isLast)\n    \t\t    vec.push_back(prefix);\n    \tfor (char i = 'a'; i <= 'z'; i++){\n    \t\tTrieNode *nextNode = curNode->child[i];\n    \t\tif (nextNode != NULL)\n    \t\t\tdisplayContactsUtil(nextNode, prefix + (char)i, vec);\n    \t}\n    }\n    \n    // Main function to display contacts for a given prefix\n    vector<vector<string>> displayContacts(int n, string contact[], string s)\n    {\n    \t// Insert contact strings into the Trie\n    \tinsertIntoTrie(contact, n);\n    \tTrieNode *prevNode = root;\n        vector<vector<string>> res;\n    \tstring prefix = \"\";\n    \tint len = s.length();\n    \tint i;\n    \t\n    \t// Iterate through the given string prefix\n    \tfor (i = 0; i < len; i++){\n    \t\tvector<string> v;\n    \t\tprefix += (char)s[i];\n    \t\tchar lastChar = prefix[i];\n    \t\tTrieNode *curNode = prevNode->child[lastChar];\n    \t\t\n    \t\t// If no more contacts can be found, add 0 to the result vector\n    \t\tif (curNode == NULL){\n    \t\t\tv.push_back(\"0\");\n    \t\t\tres.push_back(v);\n    \t\t\ti++;\n    \t\t\tbreak;\n    \t\t}\n    \t\tdisplayContactsUtil(curNode, prefix, v);\n    \t\tprevNode = curNode;\n    \t\tres.push_back(v);\n    \t}\n    \t\n    \t// If there are remaining characters in the prefix, add 0 to the result vector\n    \tfor (; i<len; i++){\n    \t    vector<string> v;\n    \t    v.push_back(\"0\");\n    \t    res.push_back(v);\n    \t}\n    \t\n    \t// Return the final result vector\n    \treturn res;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution{\n    // Method to display contacts based on the given prefix\n    static ArrayList<ArrayList<String>> displayContacts(int n, String contact[], String s) {\n        // Create the root trie node\n        trie root = new trie();\n        // Build the trie using the contact strings\n        build(contact, root);\n        // Create an ArrayList to store result\n        ArrayList<ArrayList<String>> A = new ArrayList<>();\n        // Iterate through the prefix string\n        for (int i = 1; i <= s.length(); i++) {\n            // Create an ArrayList to store contacts with matching prefix\n            ArrayList<String> ar = new ArrayList<>();\n            // Find contacts with matching prefix in the trie and store them in ar\n            find(s.substring(0, i), root, ar, contact);\n            // Sort the contacts in ar\n            Collections.sort(ar);\n            // Add ar to the result ArrayList\n            A.add(ar);\n        }\n        // Return the result\n        return A;\n    }\n    \n    // Method to build the trie using the contact strings\n    public static void build(String a[], trie root) {\n        // Create a temp trie node\n        trie temp = null;\n        // Iterate through the contact strings\n        for (int i = 0; i < a.length; i++) {\n            // Set temp as root for each contact string\n            temp = root;\n            // Iterate through each character in the contact string\n            for (int j = 0; j < a[i].length(); j++) {\n                // Check if the character node is null in the trie, if so, then create a new trie node\n                if (temp.ch[a[i].charAt(j) - 'a'] == null)\n                    temp.ch[a[i].charAt(j) - 'a'] = new trie();\n                // Move to the next character node in the trie\n                temp = temp.ch[a[i].charAt(j) - 'a'];\n                // Add the contact string to the node's HashSet\n                temp.arr.add(a[i]);\n            }\n        }\n    }\n    \n    // Method to find contacts with matching prefix in the trie\n    public static void find(String s, trie root, ArrayList<String> ar, String contact[]) {\n        // Initialize a flag to check if any character is missing in the trie\n        int q = 0;\n        // Iterate through the prefix string\n        for (int i = 0; i < s.length(); i++) {\n            // Check if the character node is null in the trie, if so, then set the flag as 1 and break\n            if (root.ch[s.charAt(i) - 'a'] == null) {\n                q = 1;\n                break;\n            }\n            // Move to the next character node in the trie\n            root = root.ch[s.charAt(i) - 'a'];\n        }\n        // If flag is 1, no contact found with matching prefix, add \"0\" to ar\n        if (q == 1) {\n            ar.add(\"0\");\n        } else {\n            // Iterate through the HashSet of the last character node in the trie and add found contacts to ar\n            for (String i : root.arr) {\n                ar.add(i);\n            }\n        }\n    }\n    \n    // Class representing trie node\n    public static class trie {\n        HashSet<String> arr; // HashSet to store contacts at the node\n        trie ch[]; // Array of trie nodes representing characters\n        public trie() {\n            arr = new HashSet<>(); // Initialize the HashSet\n            ch = new trie[26]; // Initialize the character array with size 26\n            for (int i = 0; i < 26; i++) {\n                ch[i] = null; // Set each character node as null\n            }\n        }\n    }\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#User function Template for python3\r\n\r\nclass trieNode:\r\n    def __init__(self):\r\n        self.child=[None]*(26) # initialize an array of 26 elements for child nodes\r\n        self.isLast=False # flag to indicate if the current node is the last character of a contact\r\n        \r\nclass Trie:\r\n    def __init__(self):\r\n        self.root=trieNode() # initialize the root node of the trie\r\n        \r\n    def insert(self,a):\r\n        curr=self.root # start from the root node\r\n        for el in a:\r\n            if curr.child[ord(el)-ord(\"a\")]==None: # if the child node does not exist\r\n                curr.child[ord(el)-ord(\"a\")]=trieNode() # create a new node for the character\r\n            curr=curr.child[ord(el)-ord(\"a\")] # move to the child node\r\n        curr.isLast=True # mark the node as the last character of a contact\r\n        \r\n    def insertIntoTrie(self,contact,n):\r\n        for i in range(n):\r\n            self.insert(contact[i]) # insert each contact into the trie\r\n            \r\n\r\nclass Solution:\r\n    def displayContactsUtil(self,curNode,prefix,vec):\r\n        if curNode.isLast: # if it is the last character of a contact\r\n            vec.append(prefix) # add the contact to the vector\r\n        for c in range(26):\r\n            i=chr(ord(\"a\")+c) # get the character (a-z)\r\n            nextNode=curNode.child[c] # get the child node for the character\r\n            if nextNode!=None:\r\n                self.displayContactsUtil(nextNode,prefix+i,vec) # recursively call the function for the next character\r\n        \r\n\r\n    def displayContacts(self, n, contact, s):\r\n        trie=Trie() # create a trie\r\n        trie.insertIntoTrie(contact,n) # insert the contacts into the trie\r\n        prevnode=trie.root # set the previous node as the root node\r\n        res=[]\r\n        prefix=\"\"\r\n        _len=len(s)\r\n        i=0\r\n        while i<_len:\r\n            v=[]\r\n            prefix+=s[i] # add the current character to the prefix\r\n            last_char=prefix[i] # get the last character of the prefix\r\n            curNode=prevnode.child[ord(last_char)-ord(\"a\")] # get the child node for the last character\r\n            if curNode is None: # if the child node does not exist, there are no matching contacts\r\n                v.append(\"0\")\r\n                res.append(\"0\")\r\n                i+=1\r\n                break\r\n            else:\r\n                self.displayContactsUtil(curNode,prefix,v) # find all contacts starting with the prefix\r\n                prevnode=curNode # update the previous node\r\n                res.append(v[:]) # add the matching contacts to the result\r\n                i+=1\r\n                \r\n        while i<_len:\r\n            res.append([\"0\"]) # if there are no more characters in the string, add \"0\" to the result\r\n            i+=1\r\n        return res # return the result as a list of lists containing matching contacts for each prefix",
                "lang_text": "py"
            },
            {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\n/**\n * @param {number} n\n * @param {string[]} contact\n * @param {string} s\n * @returns {string[][]}\n*/\n\nclass TrieNode {\n    constructor() {\n        this.child = new Array(26);\n        this.isLast = false;\n    }\n}\n\nclass Trie {\n    constructor() {\n        this.root = new TrieNode();\n    }\n    \n    insert(key) {\n        let crawler = this.root;\n        for (let level = 0; level < key.length; level++) {\n            let index = key[level].charCodeAt() - 'a'.charCodeAt();\n            \n            if (crawler.child[index] == null) {\n                crawler.child[index] = new TrieNode();\n            }\n            crawler = crawler.child[index];\n        }\n        crawler.isLast = true;\n    }\n    \n    getAllContactsFromNode(node, prefix, contacts) {\n        if (node.isLast) contacts.push(prefix);\n\n        for (let i = 0; i < 26; i++) {\n            if (node.child[i]) {\n                let newPrefix = prefix + String.fromCharCode(97 + i);\n                this.getAllContactsFromNode(node.child[i], newPrefix, contacts);\n            }\n        }\n    }\n    \n    getMatchingContacts(prefix) {\n        let crawler = this.root;\n        let contacts = [];\n        for (let level = 0; level < prefix.length; level++) {\n            let index = prefix[level].charCodeAt() - 'a'.charCodeAt();\n\n            if (crawler.child[index] == null) {\n                return \"0\";\n            }\n            crawler = crawler.child[index];\n        }\n        this.getAllContactsFromNode(crawler, prefix, contacts);\n        return contacts.length > 0 ? contacts : \"0\";\n    }\n}\n\nclass Solution {\n    //Function to display contacts starting with given prefix.\n    displayContacts(n, contact, s) {\n        let trie = new Trie();\n        for (let i = 0; i < n; i++) {\n            trie.insert(contact[i]);\n        }\n        let results = [];\n        let prefix = \"\";\n        for (let i = 0; i < s.length; i++) {\n            prefix += s[i];\n            results.push(trie.getMatchingContacts(prefix));\n        }\n        return results;\n    }\n}",
                "lang_text": "javascript"
            },
            {
                "lang": "C#",
                "full_func": "\npublic class Solution\n{\n    public class TrieNode\n    {\n        public Dictionary<char, TrieNode> child;\n        public bool isLast;\n\n        public TrieNode()\n        {\n            child = new Dictionary<char, TrieNode>();\n            for (char i = 'a'; i <= 'z'; i++)\n                child[i] = null;\n            isLast = false;\n        }\n    }\n\n    private TrieNode root;\n\n    private void Insert(string s)\n    {\n        int len = s.Length;\n        TrieNode itr = root;\n        for (int i = 0; i < len; i++)\n        {\n            TrieNode nextNode = itr.child[s[i]];\n            if (nextNode == null)\n            {\n                nextNode = new TrieNode();\n                itr.child[s[i]] = nextNode;\n            }\n            itr = nextNode;\n            if (i == len - 1)\n                itr.isLast = true;\n        }\n    }\n\n    private void InsertIntoTrie(string[] contacts, int n)\n    {\n        root = new TrieNode();\n        for (int i = 0; i < n; i++)\n            Insert(contacts[i]);\n    }\n\n    private void DisplayContactsUtil(TrieNode curNode, string prefix, List<string> vec)\n    {\n        if (curNode.isLast)\n            vec.Add(prefix);\n\n        for (char i = 'a'; i <= 'z'; i++)\n        {\n            TrieNode nextNode = curNode.child[i];\n            if (nextNode != null)\n                DisplayContactsUtil(nextNode, prefix + i, vec);\n        }\n    }\n\n    public List<List<string>> displayContacts(int n, string[] contact, string s)\n    {\n        InsertIntoTrie(contact, n);\n\n        TrieNode prevNode = root;\n        List<List<string>> res = new List<List<string>>();\n\n        string prefix = \"\";\n        int len = s.Length;\n\n        for (int i = 0; i < len; i++)\n        {\n            List<string> v = new List<string>();\n            prefix += s[i];\n            char lastChar = prefix[i];\n            TrieNode curNode = prevNode.child[lastChar];\n\n            if (curNode == null)\n            {\n                v.Add(\"0\");\n                res.Add(v);\n                break;\n            }\n\n            DisplayContactsUtil(curNode, prefix, v);\n            prevNode = curNode;\n            res.Add(v);\n        }\n\n        for (int i = prefix.Length; i < len; i++)\n        {\n            List<string> v = new List<string> { \"0\" };\n            res.Add(v);\n        }\n\n        return res;\n    }\n}",
                "lang_text": "csharp"
            }
        ],
        "platform": "GFG"
    }
}