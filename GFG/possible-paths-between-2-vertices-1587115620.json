{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 701246,
            "title": "Possible paths between 2 vertices",
            "titleSlug": "possible-paths-between-2-vertices-1587115620",
            "content": "<p><span style=\"font-size: 18px;\">Given a <strong>Directed Graph</strong> having <strong>V</strong> nodes numbered from <strong>0</strong>&nbsp;to <strong>V-1</strong>, and E&nbsp;directed edges. Given two nodes,&nbsp;<em><strong>source </strong></em>and <em><strong>destination</strong></em>, count the number of ways or paths between these two vertices in the&nbsp;directed graph. These paths should not&nbsp;contain any cycle.<br /><strong>Note:&nbsp;</strong>Graph doesn't contain multiple edges, self-loop, and cycles.</span></p>\n<p><br /><span style=\"font-size: 18px;\"><strong>Example 1:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:\n</strong></span><span style=\"font-size: 18px;\">V = 5, E = 7\nAdj = [{1,2,4}, {3,4}, {4}, {2}, {}]\nsource = 0&nbsp;\ndestination = 4\n</span><span style=\"font-size: 18px;\">\n<strong>Output:</strong> 4\n<strong>Explanation</strong>: \n</span><img src=\"https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/701246/Web/Other/65d4d77c-2d10-4466-b9c3-9ff5503b6fda_1685086895.png\" alt=\"\" /><span style=\"font-size: 18px;\">\nThere are 4 paths from 0 to 4.\n0 -&gt; 4\n0 -&gt; 1 -&gt; 4\n0 -&gt; 2 -&gt; 4\n0 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 4</span>\n</pre>\n<p><br /><span style=\"font-size: 18px;\"><strong>Example 2:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:\n</strong>V = 4, E = 5\nAdj = [{1,3}, {2,3}, {3}, {}]\nsource = 0&nbsp;\ndestination = 3</span><span style=\"font-size: 18px;\">\n<strong>Output:</strong> 3\n<strong>Explanation</strong>:\n</span><img src=\"https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/701246/Web/Other/ba0bea3a-cd8c-4429-9f7a-82093d260a53_1685086895.png\" alt=\"\" />\n<span style=\"font-size: 18px;\">There are 3 paths from 0 to 3.\n0 -&gt; 3\n0 -&gt; 1 -&gt; 3\n0 -&gt; 1 -&gt; 2 -&gt; 3\n</span></pre>\n<p><br /><span style=\"font-size: 18px;\"><strong>Your task:</strong><br />You don't need to read, input, or print anything. Your task is to complete the function&nbsp;<strong>countPaths(),</strong>&nbsp;which takes the integer <strong>V</strong> denoting the number of vertices, <a href=\"https://www.geeksforgeeks.org/graph-and-its-representations/\">adjacency list</a>&nbsp;<strong>adj</strong>, integer <strong>source</strong>, and <strong>destination </strong>as input parameters and returns the number of paths in the graph from the source vertex to the destination vertex.</span></p>\n<p><br /><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:&nbsp;</strong>O(V!)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(V)</span></p>\n<p><br /><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; V, E &le; 100<br />1 &le; source, destination&nbsp;&le; V</span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [],
        "relatedTopics": [
            {
                "name": "DFS",
                "slug": "dfs"
            },
            {
                "name": "Graph",
                "slug": "graph"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C",
                "full_func": "// Function to count the number of paths from source to destination in a given graph\n\nint ans = 0;\n\n// Utility function to recursively explore the paths in the graph\nvoid path_counter_utils(struct graph *g, int src, int dest, int visit[]) {\n    visit[src] = 1;\n\n    if (src == dest) {\n        ans++;    // Increment the count if destination is reached\n    } else {\n        // Explore all the adjacent nodes to the current source node\n        struct ListNode *ptr = g->head[src];\n        for (; ptr != NULL; ptr = ptr->next) {\n            if (visit[ptr->data] == 0) {\n                // Recursively call the function for unvisited adjacent nodes\n                path_counter_utils(g, ptr->data, dest, visit);\n            }\n        }\n    }\n\n    visit[src] = 0;    // Mark the current source node as unvisited\n}\n\n// Main function to count the number of paths\nint path_counter(int V, struct graph *g, int src, int dest) {\n    int visit[V + 5];    // Array to track the visited nodes\n    ans = 0;\n    memset(visit, 0, sizeof(visit));    // Initialize the visited array with 0\n\n    // Call the utility function to count the paths\n    path_counter_utils(g, src, dest, visit);\n    return ans;    // Return the count of paths\n}",
                "lang_text": "c"
            },
            {
                "lang": "C++",
                "full_func": "// Back-end complete function Template for C++\r\n\r\nclass Solution {\r\n  public:\r\n    void countPathsUtil(vector<int> *adj, int u, int d, vector<bool> &visited,\r\n                        int &pathCount) {\r\n        // marking the current vertex as visited.\r\n        visited[u] = true;\r\n\r\n        // if current node is equal to destination node, we increase the count.\r\n        if (u == d)\r\n            pathCount++;\r\n        else {\r\n            vector<int>::iterator i;\r\n            // traversing over the adjacent vertices.\r\n            for (i = adj[u].begin(); i != adj[u].end(); ++i)\r\n\r\n                // if any vertex is not visited, we call the function\r\n                // recursively for adjacent node.\r\n                if (!visited[*i])\r\n                    countPathsUtil(adj, *i, d, visited, pathCount);\r\n        }\r\n        // marking the current vertex as not visited.\r\n        visited[u] = false;\r\n    }\r\n\r\n    // Function to count paths between two vertices in a directed graph.\r\n    int countPaths(int V, vector<int> adj[], int source, int destination) {\r\n        // using boolean array to mark visited nodes and currently\r\n        // marking all the nodes as false.\r\n        vector<bool> visited(V + 1, false);\r\n\r\n        int pathCount = 0;\r\n\r\n        // calling the function to count paths\r\n        countPathsUtil(adj, source, destination, visited, pathCount);\r\n        return pathCount;\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "// Back-end Complete function Template for JAVA\r\n\r\nclass Solution {\r\n    int countPathsUtil(ArrayList<ArrayList<Integer>> adj, int u, int d,\r\n                       int pathCount) {\r\n        // if current node is equal to destination node, we increase the count.\r\n        if (u == d) {\r\n            pathCount++;\r\n        } else {\r\n            Iterator<Integer> i = adj.get(u).listIterator();\r\n            // traversing over the adjacent vertices.\r\n            while (i.hasNext()) {\r\n                int n = i.next();\r\n                // calling the function recursively for adjacent node.\r\n                pathCount = countPathsUtil(adj, n, d, pathCount);\r\n            }\r\n        }\r\n        return pathCount;\r\n    }\r\n\r\n    // Function to count paths between two vertices in a directed graph.\r\n    public int countPaths(int V, ArrayList<ArrayList<Integer>> adj, int source,\r\n                   int destination) {\r\n        int pathCount = 0;\r\n\r\n        // calling the function to count paths.\r\n        pathCount = countPathsUtil(adj, source, destination, pathCount);\r\n        return pathCount;\r\n    }\r\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "class Solution:\n    ans = 0\n\n    def countPathsUtil(self, u, destination, vis, adj):\n\n        #marking the current vertex as visited.\n        vis[u] = True\n\n        #if current node is equal to destination node, we increase the count.\n        if (u == destination):\n            self.ans += 1\n\n        #traversing over the adjacent vertices.\n        for v in adj[u]:\n\n            #if any vertex is not visited, we call the function\n            #recursively for adjacent node.\n            if (vis[v] == False):\n                self.countPathsUtil(v, destination, vis, adj)\n\n        #marking the current vertex as not visited.\n        vis[u] = False\n\n    #Function to count paths between two vertices in a directed graph.\n    def countPaths(self, V, adj, source, destination):\n\n        #using boolean array to mark visited nodes and currently\n        #marking all the nodes as false.\n        vis = [False for i in range(V)]\n\n        #calling the function to count paths\n        self.countPathsUtil(source, destination, vis, adj)\n        return self.ans\n",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "class Solution\n{\n    //Complete this function\n    //Function to count paths between two vertices in a directed graph.\n    public int countPaths(int V, List<int>[] adj, int source, int destination)\n    {\n        //using boolean array to mark visited nodes and currently\n        //marking all the nodes as false.\n        bool[] visited = new bool[V + 1];\n        \n        int pathCount = 0;\n\n        //calling the function to count paths\n        countPathsUtil(adj, source, destination, visited, ref pathCount);\n        return pathCount;\n    }\n    \n    //Function to count paths recursively between two vertices in a directed graph.\n    private void countPathsUtil(List<int>[] adj, int u, int d, bool[] visited, ref int pathCount)\n    {\n        //marking the current vertex as visited.\n        visited[u] = true;\n\n        //if current node is equal to destination node, we increase the count.\n        if (u == d)\n            pathCount++;\n        else\n        {\n            //traversing over the adjacent vertices.\n            foreach (int i in adj[u])\n            {\n                //if any vertex is not visited, we call the function\n                //recursively for adjacent node.\n                if (!visited[i])\n                    countPathsUtil(adj, i, d, visited, ref pathCount);\n            }\n        }\n        \n        //marking the current vertex as not visited.\n        visited[u] = false;\n    }\n}",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "// Back-end complete function Template for javascript\r\n\r\n/**\r\n * @param {number} V\r\n * @param {number[][]} adj\r\n * @param {number} source\r\n * @param {number} destination\r\n * @returns {number}\r\n*/\r\nclass Solution {\r\n    countPathsUtil(adj, u, d, visited) {\r\n        // marking the current vertex as visited.\r\n        visited[u] = true;\r\n\r\n        // if current node is equal to destination node, we increase the count.\r\n        if (u == d)\r\n            this.pathCount++;\r\n        else {\r\n            // traversing over the adjacent vertices.\r\n            for (let i of adj[u])\r\n                // if any vertex is not visited, we call the function\r\n                // recursively for adjacent node.\r\n                if (!visited[i]) this.countPathsUtil(adj, i, d, visited);\r\n        }\r\n        // marking the current vertex as not visited.\r\n        visited[u] = false;\r\n        return\r\n    }\r\n\r\n    // Function to count paths between two vertices in a directed graph.\r\n    countPaths(V, adj, source, destination) {\r\n        // using boolean array to mark visited nodes and currently\r\n        // marking all the nodes as false.\r\n        this.pathCount = 0;\r\n        let visited = new Array(V + 1);\r\n        visited.fill(false);\r\n\r\n        let pathCount = 0;\r\n        // calling the function to count paths.\r\n        this.countPathsUtil(adj, source, destination, visited);\r\n        return this.pathCount;\r\n    }\r\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}