{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 703749,
            "title": "Print all LCS sequences",
            "titleSlug": "print-all-lcs-sequences3413",
            "content": "<p><span style=\"font-size: 18px;\">You are given two strings <strong>s</strong>&nbsp;and <strong>t</strong>. Now your task is to print all longest common sub-sequences in lexicographical order.</span></p>\n<p><strong><span style=\"font-size: 18px;\">Note -</span></strong><span style=\"font-size: 18px;\"> </span><span style=\"font-size: 18px;\">&nbsp;A Sub-sequence is derived from another string by deleting some or none of the elements without changing the order of the remaining elements.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Example 1:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong> s = abaaa, t = baabaca\n<strong>Output: </strong>aaaa abaa baaa<br /><strong>Explanation - </strong>Length of lcs is 4, in lexicographical order they are aaaa, abaa, baaa<br /></span>\n</pre>\n<p><span style=\"font-size: 18px;\"><strong>Example 2:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong> s = aaa, t = a\n<strong>Output: </strong>a</span>\n</pre>\n<p><span style=\"font-size: 18px;\"><strong>Your Task:</strong><br />You do not need to read or print anything. Your task is to complete the function&nbsp;<strong>all_longest_common_subsequences()</strong> which takes strings s and t as first and second parameters respectively and returns a list of strings which contains all possible longest common subsequences in lexicographical order.</span><br />&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>3</sup>)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(k * n) where k is a constant less than n.</span><br />&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; Length of both strings &le; 50</span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given two strings `s` and `t`, find all the longest common subsequences (LCS) in lexicographical order. A subsequence is derived from another string by deleting some or none of the elements without changing the order of the remaining elements.",
                "constraints": [
                    "1 <= Length of both strings <= 50"
                ],
                "testcases": [
                    {
                        "input": "s = abaaa, t = baabaca",
                        "output": "aaaa abaa baaa",
                        "explanation": "The length of the longest common subsequence is 4. The lexicographically sorted LCSs are aaaa, abaa, and baaa."
                    },
                    {
                        "input": "s = aaa, t = a",
                        "output": "a",
                        "explanation": "The length of the longest common subsequence is 1. The lexicographically sorted LCS is a."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Use backtracking to find all common subsequences of lcs length.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class Solution {\n    int dp[101][101];\n    int lcs_len = 0;\n    vector<string> res;\n\n  private:\n    int lcs(string s, string t, int pos1, int pos2) {\n        // base condition\n        if (pos1 == s.size() or pos2 == t.size())\n            return 0;\n        int &ans = dp[pos1][pos2];\n        // if lcs has been computed\n        if (ans != -1)\n            return ans;\n        // if characters are same return previous + 1 else\n        // max of two sequences after removing i'th and j'th\n        // char one by one\n        if (s[pos1] == t[pos2])\n            return ans = 1 + lcs(s, t, pos1 + 1, pos2 + 1);\n        return ans = max(lcs(s, t, pos1 + 1, pos2), lcs(s, t, pos1, pos2 + 1));\n    }\n\n  private:\n    void helper(string s, string t, string cur, int pos1, int pos2, int cur_lcs) {\n        // if currlcs is equal to lcslen then store it\n        if (cur_lcs == lcs_len) {\n            res.push_back(cur);\n            return;\n        }\n        // if we are done with all the characters of both string\n        if (pos1 == s.size() or pos2 == t.size())\n            return;\n        // here we have to print all sub-sequences lexicographically,\n        // that's why we start from 'a'to'z' if this character is\n        // present in both of them then append it in cur and same\n        // remaining part\n        for (char ch = 'a'; ch <= 'z'; ch++) {\n            // f is a flag to tell that we have printed all the\n            // subsequences corresponding to current character\n            bool f = false;\n            for (int i = pos1; i < s.size(); i++) {\n                if (s[i] == ch) {\n                    for (int j = pos2; j < t.size(); j++) {\n                        // if ch is present in both of them and\n                        // remaining length is equal to remaining\n                        // lcs length then add ch in sub-sequenece\n                        if (t[j] == ch and lcs(s, t, i, j) == lcs_len - cur_lcs) {\n                            string new_cur = cur + ch;\n                            helper(s, t, new_cur, i + 1, j + 1, cur_lcs + 1);\n                            f = true;\n                            break;\n                        }\n                    }\n                }\n                // If we found LCS beginning with current character\n                if (f)\n                    break;\n            }\n        }\n    }\n\n  public:\n    vector<string> all_longest_common_subsequences(string s, string t) {\n        memset(dp, -1, sizeof(dp));\n        // Find lcs_length\n        lcs_len = lcs(s, t, 0, 0);\n        // function to get all longest common subsequences\n        helper(s, t, \"\", 0, 0, 0);\n        return res;\n    }\n};\n",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution {\n    // Constants for maximum length and LCS length\n    static int MAX = 55;\n    static int lcslen = 0;\n\n    // DP array and list to store answers\n    static int[][] dp = new int[MAX][MAX];\n    static List<String> ans;\n\n    // Function to find LCS length\n    static int lcs(String str1, String str2, int len1, int len2, int i, int j) {\n        int ret = dp[i][j];\n\n        // Base condition\n        if (i == len1 || j == len2) return ret = 0;\n\n        if (ret != -1) return ret;\n        ret = 0;\n\n        if (str1.charAt(i) == str2.charAt(j))\n            ret = 1 + lcs(str1, str2, len1, len2, i + 1, j + 1);\n        else\n            ret = Math.max(lcs(str1, str2, len1, len2, i + 1, j),\n                           lcs(str1, str2, len1, len2, i, j + 1));\n\n        return dp[i][j] = ret;\n    }\n\n    // Function to print all LCS\n    static void printAll(String str1, String str2, int len1, int len2, char[] data,\n                         int indx1, int indx2, int currlcs) {\n\n        if (currlcs == lcslen) {\n            data[currlcs] = '\\0';\n            ans.add(new String(data));\n            return;\n        }\n\n        if (indx1 == len1 || indx2 == len2) return;\n\n        for (char ch = 'a'; ch <= 'z'; ch++) {\n\n            boolean done = false;\n\n            for (int i = indx1; i < len1; i++) {\n\n                if (ch == str1.charAt(i)) {\n                    for (int j = indx2; j < len2; j++) {\n\n                        if (ch == str2.charAt(j) && dp[i][j] == lcslen - currlcs) {\n                            data[currlcs] = ch;\n                            printAll(str1, str2, len1, len2, data, i + 1, j + 1,\n                                     currlcs + 1);\n                            done = true;\n                            break;\n                        }\n                    }\n                }\n\n                if (done) break;\n            }\n        }\n    }\n\n    // Main function to find all LCS\n    public List<String> all_longest_common_subsequences(String str1, String str2) {\n\n        ans = new ArrayList<>();\n        int len1 = str1.length(), len2 = str2.length();\n\n        // Initialize DP array\n        for (int i = 0; i < MAX; i++) {\n            for (int j = 0; j < MAX; j++) {\n                dp[i][j] = -1;\n            }\n        }\n\n        // Find LCS length and print all LCS\n        lcslen = lcs(str1, str2, len1, len2, 0, 0);\n        char[] data = new char[MAX];\n        printAll(str1, str2, len1, len2, data, 0, 0, 0);\n        return ans;\n    }\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "class Solution:\n    MAX = 55\n\n    def __init__(self):\n        self.lcslen = 0\n        self.dp = [[-1 for _ in range(Solution.MAX)]\n                   for _ in range(Solution.MAX)]\n        self.ans = []\n\n    def lcs(self, str1, str2, len1, len2, i, j):\n        # base condition\n        if i == len1 or j == len2:\n            self.dp[i][j] = 0\n            return self.dp[i][j]\n\n        # if lcs has been computed\n        if self.dp[i][j] != -1:\n            return self.dp[i][j]\n\n        ret = 0\n\n        # if characters are same return previous + 1 else\n        # max of two sequences after removing i'th and j'th\n        # char one by one\n        if str1[i] == str2[j]:\n            ret = 1 + self.lcs(str1, str2, len1, len2, i + 1, j + 1)\n        else:\n            ret = max(self.lcs(str1, str2, len1, len2, i + 1, j),\n                      self.lcs(str1, str2, len1, len2, i, j + 1))\n\n        self.dp[i][j] = ret\n        return ret\n\n    def printAll(self, str1, str2, len1, len2, data, indx1, indx2, currlcs):\n        # if currlcs is equal to lcslen then print\n        if currlcs == self.lcslen:\n            self.ans.append(\"\".join(data[:currlcs]))\n            return\n\n        # if we are done with all the characters of both string\n        if indx1 == len1 or indx2 == len2:\n            return\n\n        # here we have to print all sub-sequences lexicographically,\n        # that's why we start from 'a'to'z' if this character is\n        # present in both of them then append it in data[] and same\n        # remaining part\n        for ch in range(ord('a'), ord('z') + 1):\n            # done is a flag to tell that we have printed all the\n            # subsequences corresponding to current character\n            done = False\n\n            for i in range(indx1, len1):\n                # if character ch is present in str1 then check if\n                # it is present in str2\n                if chr(ch) == str1[i]:\n                    for j in range(indx2, len2):\n                        # if ch is present in both of them and\n                        # remaining length is equal to remaining\n                        # lcs length then add ch in sub-sequence\n                        if chr(ch) == str2[j] and self.dp[i][\n                                j] == self.lcslen - currlcs:\n                            data[currlcs] = chr(ch)\n                            self.printAll(str1, str2, len1, len2, data, i + 1,\n                                          j + 1, currlcs + 1)\n                            done = True\n                            break\n\n                # If we found LCS beginning with current character.\n                if done:\n                    break\n\n    def all_longest_common_subsequences(self, str1, str2):\n        # Find lengths of both strings\n        len1, len2 = len(str1), len(str2)\n\n        self.lcslen = self.lcs(str1, str2, len1, len2, 0, 0)\n\n        # Print all LCS using recursive backtracking\n        # data[] is used to store individual LCS.\n        data = ['a' for _ in range(Solution.MAX)]\n        self.printAll(str1, str2, len1, len2, data, 0, 0, 0)\n        return self.ans\n",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "class Solution {\n    private int[,] dp;\n    private int lcs_len = 0;\n    private List<string> res = new List<string>();\n\n    // Function to calculate LCS length\n    private int LCS(string s, string t, int pos1, int pos2) {\n        // Base condition\n        if (pos1 == s.Length || pos2 == t.Length) return 0;\n\n        // Memoization check\n        if (dp[pos1, pos2] != -1) return dp[pos1, pos2];\n\n        // If characters match, add 1 and proceed\n        if (s[pos1] == t[pos2])\n            return dp[pos1, pos2] = 1 + LCS(s, t, pos1 + 1, pos2 + 1);\n\n        // Otherwise, take the maximum of skipping one character from either string\n        return dp[pos1, pos2] =\n                   Math.Max(LCS(s, t, pos1 + 1, pos2), LCS(s, t, pos1, pos2 + 1));\n    }\n\n    // Helper function to generate all LCS sequences\n    private void Helper(string s, string t, string cur, int pos1, int pos2,\n                        int cur_lcs) {\n        // If current LCS matches the required length, add it to the result\n        if (cur_lcs == lcs_len) {\n            res.Add(cur);\n            return;\n        }\n\n        // If we've processed all characters in either string\n        if (pos1 == s.Length || pos2 == t.Length) return;\n\n        // Check for characters lexicographically\n        for (char ch = 'a'; ch <= 'z'; ch++) {\n            bool found = false;\n\n            for (int i = pos1; i < s.Length; i++) {\n                if (s[i] == ch) {\n                    for (int j = pos2; j < t.Length; j++) {\n                        if (t[j] == ch && LCS(s, t, i, j) == lcs_len - cur_lcs) {\n                            string newCur = cur + ch;\n                            Helper(s, t, newCur, i + 1, j + 1, cur_lcs + 1);\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n                if (found) break;\n            }\n        }\n    }\n\n    // Public function to get all LCS sequences\n    public List<string> all_longest_common_subsequences(string s, string t) {\n        int n = s.Length, m = t.Length;\n\n        // Initialize DP array\n        dp = new int[n + 1, m + 1];\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= m; j++) {\n                dp[i, j] = -1;\n            }\n        }\n\n        // Find LCS length\n        lcs_len = LCS(s, t, 0, 0);\n\n        // Generate all LCS sequences\n        Helper(s, t, \"\", 0, 0, 0);\n\n        // Return the result list\n        return res;\n    }\n}",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "class Solution {\n    constructor() {\n        this.dp = Array.from({length : 101}, () => Array(101).fill(-1));\n        this.lcs_len = 0;\n        this.res = [];\n    }\n\n    lcs(s, t, pos1, pos2) {\n        // base condition\n        if (pos1 === s.length || pos2 === t.length) return 0;\n\n        // if lcs has been computed\n        if (this.dp[pos1][pos2] !== -1) return this.dp[pos1][pos2];\n\n        // if characters are same return previous + 1 else\n        // max of two sequences after removing i'th and j'th\n        // char one by one\n        if (s[pos1] === t[pos2]) {\n            return (this.dp[pos1][pos2] = 1 + this.lcs(s, t, pos1 + 1, pos2 + 1));\n        }\n\n        return (this.dp[pos1][pos2] = Math.max(this.lcs(s, t, pos1 + 1, pos2),\n                                               this.lcs(s, t, pos1, pos2 + 1)));\n    }\n\n    helper(s, t, cur, pos1, pos2, cur_lcs) {\n        // if cur_lcs is equal to lcs_len then store it\n        if (cur_lcs === this.lcs_len) {\n            this.res.push(cur);\n            return;\n        }\n\n        // if we are done with all the characters of both string\n        if (pos1 === s.length || pos2 === t.length) return;\n\n        // here we have to print all sub-sequences lexicographically,\n        // that's why we start from 'a' to 'z'\n        for (let ch = 'a'.charCodeAt(0); ch <= 'z'.charCodeAt(0); ch++) {\n            const char = String.fromCharCode(ch);\n            let f = false;\n\n            for (let i = pos1; i < s.length; i++) {\n                if (s[i] === char) {\n                    for (let j = pos2; j < t.length; j++) {\n                        // if char is present in both of them and\n                        // remaining length is equal to remaining\n                        // lcs length then add char in sub-sequence\n                        if (t[j] === char &&\n                            this.lcs(s, t, i, j) === this.lcs_len - cur_lcs) {\n                            this.helper(s, t, cur + char, i + 1, j + 1, cur_lcs + 1);\n                            f = true;\n                            break;\n                        }\n                    }\n                }\n                // If we found LCS beginning with current character\n                if (f) break;\n            }\n        }\n    }\n\n    all_longest_common_subsequences(s, t) {\n        // Reset dp array and result array\n        this.dp = Array.from({length : 101}, () => Array(101).fill(-1));\n        this.res = [];\n\n        // Find lcs_length\n        this.lcs_len = this.lcs(s, t, 0, 0);\n\n        // function to get all longest common subsequences\n        this.helper(s, t, \"\", 0, 0, 0);\n        return this.res;\n    }\n}\n",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}