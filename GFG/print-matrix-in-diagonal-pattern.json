{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 700405,
            "title": "Print matrix in diagonal pattern",
            "titleSlug": "print-matrix-in-diagonal-pattern",
            "content": "<p><span style=\"font-size: 18px;\">Given a square matrix <strong>mat[][]</strong> of <strong>n*n</strong> size, the task is to determine the <strong>diagonal pattern</strong> which is a linear arrangement of the elements of the matrix as depicted in the following example:</span></p>\n<p><span style=\"font-size: 18px;\"><img style=\"height: 324px; width: 393px;\" src=\"https://contribute.geeksforgeeks.org/wp-content/uploads/matrix-6.png\" alt=\"\" /></span></p>\n<p><span style=\"font-size: 18px;\"><strong>Example 1:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong style=\"font-size: 18px;\">Input:\n</strong><span style=\"font-size: 18px;\">n = 3\nmat[][] = {{1, 2, 3},<br />\\t     {4, 5, 6},<br />\\t     {7, 8, 9}}\n</span><strong style=\"font-size: 18px;\">Output: {</strong><span style=\"font-size: 18px;\">1, 2, 4, 7, 5, 3, 6, 8, 9}<br /></span><strong style=\"font-size: 18px;\">Explaination:<br /></strong><span style=\"font-size: 18px;\"><span style=\"font-size: 18px;\">Starting from (0, 0): 1,\nMove to the right to (0, 1): 2,\nMove diagonally down to (1, 0): 4,\nMove diagonally down to (2, 0): 7,<br />Move diagonally up to (1, 1): 5,\nMove diagonally up to (0, 2): 3,\nMove to the right to (1, 2): 6,\nMove diagonally up to (2, 1): 8,\nMove diagonally up to (2, 2): 9<br />There for the output is {1, 2, 4, 7, 5, 3, 6, 8, 9}.</span></span><span style=\"font-size: 18px;\"><br /></span></span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Example 2:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong style=\"font-size: 18px;\">Input:\n</strong><span style=\"font-size: 18px;\">n = 2\nmat[][] = {{1, 2},<br />\\t     {3, 4}}\n</span><strong style=\"font-size: 18px;\">Output: </strong><span style=\"font-size: 18px;\">{1, 2, 3, 4}<br /></span><strong style=\"font-size: 18px;\">Explaination:</strong><span style=\"font-size: 18px;\"><br />Starting from (0, 0): 1,\nMove to the right to (0, 1): 2,\nMove diagonally down to (1, 0): 3,\nMove to the right to (1, 1): 4<br />There for the output is {1, 2, 3, 4}.</span></span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Your Task:</strong><br />You only need to implement the given function&nbsp;<strong>matrixDiagonally()&nbsp;</strong>which takes a matrix <strong>mat[][]</strong> of size <strong>n*n</strong> as an input and returns a list of integers containing the matrix diagonally. Do not read input, instead use the arguments given in the function.</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:</strong> O(n*n).<br /><strong>Expected Auxiliary Space:</strong> O(</span><span style=\"font-size: 18px;\">n*n</span><span style=\"font-size: 18px;\">).</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 100<br />-100 &lt;= elements of matrix &lt;= 100</span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a square matrix `mat[][]` of size `n*n`, the task is to traverse the matrix in a diagonal pattern. This pattern involves starting from the top-left corner and moving right, then diagonally down, and so on, until all elements are visited.  The goal is to return a linear arrangement (list) of the elements in the order they are visited in this diagonal pattern.",
                "constraints": [
                    "1 <= n <= 100",
                    "-100 <= elements of matrix <= 100"
                ],
                "testcases": [
                    {
                        "input": "n = 3\nmat[][] = {{1, 2, 3},\n\t     {4, 5, 6},\n\t     {7, 8, 9}}",
                        "output": "{1, 2, 4, 7, 5, 3, 6, 8, 9}",
                        "explanation": "The matrix is traversed as follows: 1, then 2, then diagonally down to 4, diagonally down to 7, diagonally up to 5, diagonally up to 3, then move to the right to 6, diagonally up to 8, and finally diagonally up to 9."
                    },
                    {
                        "input": "n = 2\nmat[][] = {{1, 2},\n\t     {3, 4}}",
                        "output": "{1, 2, 3, 4}",
                        "explanation": "The matrix is traversed as follows: 1, then 2, then diagonally down to 3, and then to 4."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Create variables&nbsp;<em>i=0, j=0</em>&nbsp;to store the current indices of row and column</li>\n<li>Run a loop from 0 to n*n, where n is side of the matrix.</li>\n<li>Use a flag&nbsp;<strong>isUp</strong>&nbsp;to decide whether the direction is upwards or downwards. Set&nbsp;<em>isUp = true</em>&nbsp;initially the direction is going upward.</li>\n<li>If isUp = 1 then start printing elements by incrementing column index and decrementing the row index.</li>\n<li>Similarly if isUp = 0, then decrement the column index and increment the row index.</li>\n<li>Move to the next column or row (next starting row and column</li>\n<li>Do this till all the elements get traversed.</li>\n</ol>"
        ],
        "relatedTopics": [
            {
                "name": "Matrix",
                "slug": "matrix"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [
            "amazon"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class Solution {\r\npublic:\r\n    vector<int> matrixDiagonally(vector<vector<int>>& mat) {\r\n        bool ok = true;\r\n        int n = mat.size();\r\n        vector<int> res, r;\r\n        if(n == 0)    return {};\r\n        int m = mat[0].size();\r\n        for(int i= 0;i<m;i++){\r\n            int ii = 0;\r\n            int jj = i;\r\n            vector<int> res;\r\n            while(ii < n && ii >= 0 && jj >= 0 && jj < m){\r\n                if(ok)  res.insert(res.begin(), mat[ii][jj]);\r\n                else    res.push_back(mat[ii][jj]);\r\n                ii++;\r\n                jj--;\r\n            }\r\n            for(int x : res)    r.push_back(x);\r\n            ok = !ok;\r\n        }\r\n        for(int i = 1;i<n;i++){\r\n            int ii = i;\r\n            int jj = m - 1;\r\n            vector<int> res;\r\n            while(ii < n && ii >= 0 && jj >= 0 && jj < m){\r\n                if(ok)  res.insert(res.begin(), mat[ii][jj]);\r\n                else    res.push_back(mat[ii][jj]);\r\n                ii++;\r\n                jj--;\r\n            }\r\n            for(int x : res)    r.push_back(x);\r\n            ok = !ok;\r\n        }\r\n        return r;\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution {\r\n    public int[] matrixDiagonally(int[][] mat) {\r\n        \r\n        // Check for empty matrices\r\n        if (mat == null || mat.length == 0) {\r\n            return new int[0];\r\n        }\r\n        \r\n        // Variables to track the size of the matrix\r\n        int N = mat.length;\r\n        int M = mat[0].length;\r\n        \r\n        // Incides that will help us progress through \r\n        // the matrix, one element at a time.\r\n        int row = 0, column = 0;\r\n        \r\n        // As explained in the article, this is the variable\r\n        // that helps us keep track of what direction we are\r\n        // processing the current diaonal\r\n        int direction = 1;\r\n        \r\n         // The final result array\r\n        int[] result = new int[N*M];\r\n        int r = 0;\r\n        \r\n        // The uber while loop which will help us iterate over all\r\n        // the elements in the array.\r\n        while (row < N && column < M) {\r\n            \r\n            // First and foremost, add the current element to \r\n            // the result matrix. \r\n            result[r++] = mat[row][column];\r\n            \r\n            // Move along in the current diagonal depending upon\r\n            // the current direction.[i, j] -> [i - 1, j + 1] if \r\n            // going up and [i, j] -> [i + 1][j - 1] if going down.\r\n            int new_row = row + (direction == 1 ? -1 : 1);\r\n            int new_column = column + (direction == 1 ? 1 : -1);\r\n            \r\n            // Checking if the next element in the diagonal is within the\r\n            // bounds of the matrix or not. If it's not within the bounds,\r\n            // we have to find the next head. \r\n            if (new_row < 0 || new_row == N || new_column < 0 || new_column == M) {\r\n                \r\n                // If the current diagonal was going in the upwards\r\n                // direction.\r\n                if (direction == 1) {\r\n                    \r\n                    // For an upwards going diagonal having [i, j] as its tail\r\n                    // If [i, j + 1] is within bounds, then it becomes\r\n                    // the next head. Otherwise, the element directly below\r\n                    // i.e. the element [i + 1, j] becomes the next head\r\n                    row += (column == M - 1 ? 1 : 0) ;\r\n                    column += (column < M - 1 ? 1 : 0);\r\n                        \r\n                } else {\r\n                    \r\n                    // For a downwards going diagonal having [i, j] as its tail\r\n                    // if [i + 1, j] is within bounds, then it becomes\r\n                    // the next head. Otherwise, the element directly below\r\n                    // i.e. the element [i, j + 1] becomes the next head\r\n                    column += (row == N - 1 ? 1 : 0);\r\n                    row += (row < N - 1 ? 1 : 0);\r\n                }\r\n                    \r\n                // Flip the direction\r\n                direction = 1 - direction;        \r\n                        \r\n            } else {\r\n                \r\n                row = new_row;\r\n                column = new_column;\r\n            }\r\n        }\r\n        return result;      \r\n    }\r\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "class Solution:\r\n    \r\n    def matrixDiagonally(self, mat):\r\n        \r\n        # Check for an empty matrix\r\n        if not mat or not mat[0]:\r\n            return []\r\n        \r\n        # The dimensions of the matrix\r\n        N, M = len(mat), len(mat[0])\r\n        \r\n        # Incides that will help us progress through \r\n        # the matrix, one element at a time.\r\n        row, column = 0, 0\r\n        \r\n        # As explained in the article, this is the variable\r\n        # that helps us keep track of what direction we are\r\n        # processing the current diaonal\r\n        direction = 1\r\n        \r\n        # Final result array that will contain all the elements\r\n        # of the matrix\r\n        result = []\r\n        \r\n        # The uber while loop which will help us iterate over all\r\n        # the elements in the array.\r\n        while row < N and column < M:\r\n            \r\n            # First and foremost, add the current element to \r\n            # the result matrix. \r\n            result.append(mat[row][column])\r\n            \r\n            # Move along in the current diagonal depending upon\r\n            # the current direction.[i, j] -> [i - 1, j + 1] if \r\n            # going up and [i, j] -> [i + 1][j - 1] if going down.\r\n            new_row = row + (-1 if direction == 1 else 1)\r\n            new_column = column + (1 if direction == 1 else -1)\r\n            \r\n            # Checking if the next element in the diagonal is within the\r\n            # bounds of the matrix or not. If it's not within the bounds,\r\n            # we have to find the next head. \r\n            if new_row < 0 or new_row == N or new_column < 0 or new_column == M:\r\n                \r\n                # If the current diagonal was going in the upwards\r\n                # direction.\r\n                if direction:\r\n                    \r\n                    # For an upwards going diagonal having [i, j] as its tail\r\n                    # If [i, j + 1] is within bounds, then it becomes\r\n                    # the next head. Otherwise, the element directly below\r\n                    # i.e. the element [i + 1, j] becomes the next head\r\n                    row += (column == M - 1)\r\n                    column += (column < M - 1)\r\n                else:\r\n                    \r\n                    # For a downwards going diagonal having [i, j] as its tail\r\n                    # if [i + 1, j] is within bounds, then it becomes\r\n                    # the next head. Otherwise, the element directly below\r\n                    # i.e. the element [i, j + 1] becomes the next head\r\n                    column += (row == N - 1)\r\n                    row += (row < N - 1)\r\n                    \r\n                # Flip the direction\r\n                direction = 1 - direction        \r\n            else:\r\n                row = new_row\r\n                column = new_column\r\n                        \r\n        return result                 ",
                "lang_text": "py"
            },
            {
                "lang": "C#",
                "full_func": "\npublic class Solution {\n    public List<int> matrixDiagonally(int[,] mat) {\n        bool ok = true;\n        int n = mat.GetLength(0);\n        int m = mat.GetLength(1);\n        List<int> result = new List<int>();\n\n        if (n == 0) {\n            return result;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int row = 0;\n            int col = i;\n            var temp = new List<int>();\n            while (row < n && col >= 0) {\n                if (ok) {\n                    temp.Insert(0, mat[row, col]);\n                } else {\n                    temp.Add(mat[row, col]);\n                }\n                row++;\n                col--;\n            }\n            result.AddRange(temp);\n            ok = !ok;\n        }\n        \n        for (int i = 1; i < n; i++) {\n            int row = i;\n            int col = m - 1;\n            var temp = new List<int>();\n            while (row < n && col >= 0) {\n                if (ok) {\n                    temp.Insert(0, mat[row, col]);\n                } else {\n                    temp.Add(mat[row, col]);\n                }\n                row++;\n                col--;\n            }\n            result.AddRange(temp);\n            ok = !ok;\n        }\n        \n        return result;\n    }\n}",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "//Back-end complete function Template for javascript\n\n\nclass Solution {\n    matrixDiagonally(mat) {\n        let ok = true;\n        const n = mat.length;\n        const res = [];\n        const r = [];\n        if (n == 0) return [];\n        const m = mat[0].length;\n\n        for (let i = 0; i < m; i++) {\n            let ii = 0;\n            let jj = i;\n            const res = [];\n            while (ii < n && ii >= 0 && jj >= 0 && jj < m) {\n                if (ok) res.unshift(mat[ii][jj]);\n                else res.push(mat[ii][jj]);\n                ii++;\n                jj--;\n            }\n            res.forEach(x => r.push(x));\n            ok = !ok;\n        }\n\n        for (let i = 1; i < n; i++) {\n            let ii = i;\n            let jj = m - 1;\n            const res = [];\n            while (ii < n && ii >= 0 && jj >= 0 && jj < m) {\n                if (ok) res.unshift(mat[ii][jj]);\n                else res.push(mat[ii][jj]);\n                ii++;\n                jj--;\n            }\n            res.forEach(x => r.push(x));\n            ok = !ok;\n        }\n        return r;\n    }\n}\n",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}