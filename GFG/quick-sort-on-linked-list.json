{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 700124,
            "title": "Quick Sort on Linked List",
            "titleSlug": "quick-sort-on-linked-list",
            "content": "<p><span style=\"font-size: 12pt;\">You are given a Linked List. Sort the given Linked List using <strong>quicksort</strong>.&nbsp;</span></p>\n<p><span style=\"font-size: 12pt;\"><strong>Examples:</strong></span></p>\n<pre><span style=\"font-size: 12pt;\"><strong>Input: </strong>Linked<strong> </strong>list: 1-&gt;6-&gt;2</span><br /><span style=\"font-size: 12pt;\"><strong>Output: </strong>1-&gt;2-&gt;6<br /><img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700124/Web/Other/blobid0_1722180998.png\" width=\"400\" height=\"200\" /><br /><strong>Explanation:</strong></span><br /><span style=\"font-size: 12pt;\">After sorting the nodes, we have 1, 2 and 6.</span></pre>\n<pre><span style=\"font-size: 12pt;\"><strong>Input: </strong>Linked<strong> </strong>list: 1-&gt;9-&gt;3-&gt;8</span><br /><span style=\"font-size: 12pt;\"><strong>Output: </strong>1-&gt;3-&gt;8-&gt;9<br /><img src=\"https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700124/Web/Other/blobid1_1722181152.png\" width=\"400\" height=\"200\" /></span><br /><span style=\"font-size: 12pt;\"><strong>Explanation:</strong></span><br /><span style=\"font-size: 12pt;\">After sorting the nodes, we have 1, 3, 8 and 9. </span></pre>\n<p><span style=\"font-size: 12pt;\"><strong>Constraints:</strong></span><br style=\"font-size: 18px;\" /><span style=\"font-size: 12pt;\">1&lt;= size of linked list &lt;= 10<sup>5</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "You are given a singly linked list. Sort the linked list in ascending order using the quicksort algorithm.",
                "constraints": [
                    "1 <= size of linked list <= 10^5"
                ],
                "testcases": [
                    {
                        "input": "1->6->2",
                        "output": "1->2->6",
                        "explanation": "The sorted linked list is 1, 2, and 6."
                    },
                    {
                        "input": "1->9->3->8",
                        "output": "1->3->8->9",
                        "explanation": "The sorted linked list is 1, 3, 8, and 9."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"color: #0d0d0d; font-family: arial, helvetica, sans-serif; font-size: 12pt; white-space-collapse: preserve; background-color: #ffffff;\">Divide the list using a pivot, sort each partition, and link them together recursively.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [
            "paytm"
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "// Solution class with quickSort function\nclass Solution {\n  public:\n    struct Node* partition(Node* head, Node* end) {\n        struct Node* pivot = head;\n        struct Node* curr = head->next;\n        struct Node* prev = head;\n        while (curr != end->next) {\n            if (pivot->data > curr->data) {\n                swap(prev->next->data, curr->data);\n                prev = prev->next;\n            }\n            curr = curr->next;\n        }\n        swap(prev->data, pivot->data);\n        return prev;\n    }\n\n    struct Node* getTail(struct Node* cur) {\n        while (cur != NULL && cur->next != NULL)\n            cur = cur->next;\n        return cur;\n    }\n\n    // Here the sorting happens exclusive of the end node\n    struct Node* quickSortRecur(struct Node* head, struct Node* end) {\n        // Base condition\n        if (!head || head == end)\n            return head;\n\n        // Partition the list, newHead and newEnd will be updated by the partition\n        // function\n        struct Node* pivot = partition(head, end);\n        Node *newHead = head, *newEnd = end;\n\n        // If pivot is the smallest element - no need to recur for the left part.\n        if (newHead != pivot) {\n            // Set the node before the pivot node as NULL\n            struct Node* tmp = newHead;\n            while (tmp->next != pivot)\n                tmp = tmp->next;\n            tmp->next = NULL;\n\n            // Recur for the list before pivot\n            newHead = quickSortRecur(newHead, tmp);\n\n            // Change next of last node of the left half to pivot\n            tmp = getTail(newHead);\n            tmp->next = pivot;\n        }\n\n        // Recur for the list after the pivot element\n        pivot->next = quickSortRecur(pivot->next, newEnd);\n\n        return newHead;\n    }\n\n    struct Node* quickSort(struct Node* head) {\n        return quickSortRecur(head, getTail(head));\n    }\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class GfG {\n    // Function to perform quicksort on a linked list\n    public static Node quickSort(Node node) {\n        // Initialize the last node as the tail\n        node = quickSortRec(node, getTail(node));\n\n        return node;\n    }\n\n    // Function to get the tail node of the linked list\n    public static Node getTail(Node n) {\n        // Iterate through the linked list to find the last node\n        while (n != null && n.next != null) n = n.next;\n\n        return n;\n    }\n\n    // Inner class to store the new head and new end of a partition\n    static class Res { Node newHead = null, newEnd = null; }\n\n    // Recursive function to perform quicksort on the linked list\n    public static Node quickSortRec(Node head, Node last) {\n        // Base case: if the list is empty or has only one element, return the list\n        if (head == null || head == last) return head;\n\n        // Create two result objects to store the partition\n        Res r = new Res();\n        Res s = new Res();\n\n        // Partition the list and get the pivot node\n        Node pivot = partition(head, last, r, s);\n\n        // If the new head of the left partition is not the pivot,\n        // rearrange the nodes to maintain the correct order\n        if (r.newHead != pivot) {\n            Node tmp = r.newHead;\n            while (tmp.next != pivot) tmp = tmp.next;\n            tmp.next = null;\n\n            // Recursively sort the left partition\n            r.newHead = quickSortRec(r.newHead, tmp);\n\n            // Get the tail of the sorted left partition and connect it to the pivot\n            tmp = getTail(r.newHead);\n            tmp.next = pivot;\n        }\n\n        // Recursively sort the right partition\n        pivot.next = quickSortRec(pivot.next, s.newEnd);\n\n        // Return the head of the sorted list\n        return r.newHead;\n    }\n\n    // Function to partition the list around a pivot element\n    public static Node partition(Node head, Node last, Res r, Res s) {\n        // Choose the last node as the pivot node\n        Node pivot = last;\n        Node prev = null, cur = head, tail = pivot;\n\n        // Iterate through the list and rearrange the nodes based on the pivot\n        while (cur != pivot) {\n            if (cur.data < pivot.data) {\n                // If the current node is smaller than the pivot,\n                // move it to the left partition\n                if (r.newHead == null) r.newHead = cur;\n\n                prev = cur;\n                cur = cur.next;\n            } else {\n                // If the current node is greater than the pivot,\n                // move it to the right partition\n                if (prev != null) prev.next = cur.next;\n\n                Node tmp = cur.next;\n                cur.next = null;\n                tail.next = cur;\n                tail = cur;\n                cur = tmp;\n            }\n        }\n\n        // If no node was moved to the left partition,\n        // set the pivot as the new head\n        if (r.newHead == null) r.newHead = pivot;\n\n        // Set the new end of the right partition\n        s.newEnd = tail;\n\n        // Return the pivot node\n        return pivot;\n    }\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "#Back-end complete function Template for Python 3\n\n\ndef quickSort(head):\n    if head is None:\n        return None\n\n    #sorting linked list using quicksort algorithm\n\n    h, t = mysort(head)\n    t.next = None\n    return h\n\n\ndef mysort(head):\n    \"\"\"\n    :type head: ListNode\n    :rtype: ListNode\n    \"\"\"\n\n    if head is None:\n        return None, None\n\n    #base cases\n    #if head is the only node in the linked list\n    if head and head.next is None:\n        return head, head\n\n    #partitioning the linked list based on head node\n    left = None\n    pleft = None\n    right = None\n    pright = None\n\n    #keeping track of head node\n    phead = head\n\n    #setting p as the next node\n    p = head.next\n\n    #iterating over the linked list\n    while p:\n        if p.data < head.data:\n            #if node value is less than head value, move it to the left partition\n            if left is None:\n                left = p\n                pleft = p\n                p = p.next\n                pleft.next = None\n            else:\n                pleft.next = p\n                pleft = p\n                p = p.next\n                pleft.next = None\n        elif p.data > head.data:\n            #if node value is greater than head value, move it to the right partition\n            if right is None:\n                right = p\n                pright = p\n                p = p.next\n                pright.next = None\n            else:\n                pright.next = p\n                pright = p\n                p = p.next\n                pright.next = None\n        elif p.data == head.data:\n            #if node value is equal to head value, move it to the end of the sorted list\n            phead.next = p\n            phead = p\n            p = p.next\n            phead.next = None\n\n    #recursively sort the left and right partitions\n    lhead, ltail = mysort(left)\n    rhead, rtail = mysort(right)\n\n    if lhead is None and rhead is None:\n        #if both left and right partitions are empty, return head and phead as tail\n        return head, phead\n    if lhead is None and rhead is not None:\n        #if left partition is empty and right partition is not empty, link phead to rhead\n        phead.next = rhead\n        return head, rtail\n    elif lhead and rhead is None:\n        #if left partition is not empty and right partition is empty, link ltail to head\n        ltail.next = head\n        return lhead, phead\n    elif lhead and rhead:\n        #if both left and right partitions are not empty, link ltail to head and phead to rhead\n        ltail.next = head\n        phead.next = rhead\n        return lhead, rtail\n",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "class Solution {\n    // Function to perform quicksort on a linked list\n    quickSort(head) {\n        // Initialize the last node as the tail\n        head = this.quickSortRec(head, this.getTail(head));\n        return head;\n    }\n\n    // Function to get the tail node of the linked list\n    getTail(node) {\n        // Iterate through the linked list to find the last node\n        while (node !== null && node.next !== null) {\n            node = node.next;\n        }\n        return node;\n    }\n\n    // Recursive function to perform quicksort on the linked list\n    quickSortRec(head, last) {\n        // Base case: if the list is empty or has only one element, return the list\n        if (head === null || head === last) return head;\n\n        // Create two result objects to store the partition\n        let partitionResult = this.partition(head, last);\n        let pivot = partitionResult.pivot;\n        let newHead = partitionResult.newHead;\n        let newEnd = partitionResult.newEnd;\n\n        // If the new head of the left partition is not the pivot,\n        // rearrange the nodes to maintain the correct order\n        if (newHead !== pivot) {\n            let tmp = newHead;\n            while (tmp.next !== pivot) {\n                tmp = tmp.next;\n            }\n            tmp.next = null;\n\n            // Recursively sort the left partition\n            newHead = this.quickSortRec(newHead, tmp);\n\n            // Get the tail of the sorted left partition and connect it to the pivot\n            tmp = this.getTail(newHead);\n            tmp.next = pivot;\n        }\n\n        // Recursively sort the right partition\n        pivot.next = this.quickSortRec(pivot.next, newEnd);\n\n        // Return the head of the sorted list\n        return newHead;\n    }\n\n    // Function to partition the list around a pivot element\n    partition(head, last) {\n        // Choose the last node as the pivot node\n        let pivot = last;\n        let prev = null, cur = head, tail = pivot;\n\n        let newHead = null, newEnd = null;\n\n        // Iterate through the list and rearrange the nodes based on the pivot\n        while (cur !== pivot) {\n            if (cur.data < pivot.data) {\n                // If the current node is smaller than the pivot,\n                // move it to the left partition\n                if (newHead === null) newHead = cur;\n\n                prev = cur;\n                cur = cur.next;\n            } else {\n                // If the current node is greater than the pivot,\n                // move it to the right partition\n                if (prev !== null) prev.next = cur.next;\n\n                let tmp = cur.next;\n                cur.next = null;\n                tail.next = cur;\n                tail = cur;\n                cur = tmp;\n            }\n        }\n\n        // If no node was moved to the left partition,\n        // set the pivot as the new head\n        if (newHead === null) newHead = pivot;\n\n        // Set the new end of the right partition\n        newEnd = tail;\n\n        // Return the pivot node\n        return {pivot, newHead, newEnd};\n    }\n}",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}