{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 701710,
            "title": "Range GCD Queries",
            "titleSlug": "range-gcd-queries3654",
            "content": "<p><span style=\"font-size:18px\">You are given an array <strong>arr </strong>of size <strong>N, </strong>and<strong>&nbsp;Q</strong>&nbsp;queries.&nbsp; You have to find GCD of the elements in the given range alongside updating the value of the array as per query.</span><br />\n<strong>Note:</strong><span style=\"font-size:18px\"> 0-based indexing is used.</span></p>\n\n<p><strong><span style=\"font-size:18px\">Example 1:</span></strong></p>\n\n<pre>\n<strong><span style=\"font-size:18px\">Input:\n</span></strong><span style=\"font-size:18px\">N = 6, Q = 3\narr[] = {2,3,4,6,8,16}\nQueries = findRangeGCD(0,2)\n&nbsp;\\t   updateValue(3,8)\n&nbsp;\\t   findRangeGCD(2,5)\n<strong>Output:\n</strong>1\n4<strong>\nExplanation: </strong>There are 3 queries:&nbsp;\nQuery 1 : gcd(2, 3, 4) = 1\nQuery 2&nbsp;: 6&nbsp;changes to 8\nQuery 3&nbsp;: gcd(4, 8, 8, 16) = 4</span>\n</pre>\n\n<p><span style=\"font-size:18px\"><strong>Your Task:</strong><br />\nComplete<strong>&nbsp;findRangeGcd</strong> and <strong>updateValue </strong>function<strong>.<br />\nfindRangeGcd: </strong>This function takes L, R, st (segment tree array), and n(size of arr) as arguments and returns the range GCD.<br />\n<strong>updateValue:&nbsp; </strong>This function takes index, new_val, arr, st (segment tree array), and n(size of arr) as arguments and updates arr[index] to new_val.</span></p>\n\n<p><span style=\"font-size:18px\"><strong>Expected Time Complexity:&nbsp;</strong>O(Q*Log(N)*Log(N)).<br />\n<strong>Expected Auxiliary Space:&nbsp;</strong>O(1).</span></p>\n\n<p><span style=\"font-size:18px\"><strong>Constraints:</strong><br />\n1 &lt;= N &lt;= 10<sup>5</sup><br />\n1 &lt;= Q &lt;= 10<sup>5</sup><br />\n0 &lt;= L, R, index &lt;= N-1<br />\n1 &lt;= arr[i], value<strong>&nbsp;</strong>&lt;= 10<sup>5</sup></span></p>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given an array `arr` of size `N` and `Q` queries, implement functions to find the Greatest Common Divisor (GCD) of elements within a specified range and update element values in the array. The queries are processed in the order they are given.\n\nImplement the following functions:\n\n*   `findRangeGcd(L, R, st, n)`: Returns the GCD of elements in `arr` from index `L` to `R` (inclusive). `st` represents a pre-computed segment tree (you don't need to implement segment tree building) and `n` is the size of the array `arr`.\n*   `updateValue(index, new_val, arr, st, n)`: Updates the element at index `index` in `arr` to `new_val`.  `st` represents a pre-computed segment tree that also needs to be updated after the array is updated, and `n` is the size of the array `arr`.  (You don't need to implement segment tree building, but you DO need to update it in this function.)",
                "constraints": [
                    "1 <= N <= 10^5",
                    "1 <= Q <= 10^5",
                    "0 <= L, R, index <= N-1",
                    "1 <= arr[i], value <= 10^5"
                ],
                "testcases": [
                    {
                        "input": "N = 6, Q = 3\narr = [2,3,4,6,8,16]\nQueries = findRangeGCD(0,2)\n         updateValue(3,8)\n         findRangeGCD(2,5)",
                        "output": "1\n4",
                        "explanation": "Query 1: gcd(2, 3, 4) = 1\nQuery 2: arr[3] changes from 6 to 8\nQuery 3: gcd(4, 8, 8, 16) = 4"
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            ""
        ],
        "relatedTopics": [
            {
                "name": "Segment-Tree",
                "slug": "segment-tree"
            },
            {
                "name": "Advanced Data Structure",
                "slug": "advanced-data-structure"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "// Back-end complete function template for C++\n\n\nclass Solution\n{\n    public:\n    //recursive function to get gcd of given range of array indexes.\n    int findGcd(int ss, int se, int qs, int qe, int si, int st[]) \n    {\n        //if segment of this node is outside the given range, we return 0.\n        if (ss > qe || se < qs) \n        return 0;\n        \n        //if segment of this node is a part of given range, we return st[si].\n        if (qs <= ss && qe >= se)\n        return st[si];\n        \n        //if a part of this segment overlaps with the given range, we call\n        //the function recursively for the children nodes.\n        int mid = ss + (se - ss) / 2;\n        return gcd(findGcd(ss, mid, qs, qe, si * 2 + 1, st),\n                   findGcd(mid + 1, se, qs, qe, si * 2 + 2, st));\n    }\n    \n    //Function to find gcd of given range.\n    int findRangeGcd(int ss, int se, int st[], int n) \n    {\n        //base case for invalid input.\n        if (ss < 0 || se > n - 1 || ss > se) {\n            return -1;\n        }\n        return findGcd(0, n - 1, ss, se, 0, st);\n    }\n    \n    //recursive function to update nodes which have given index in their range.\n    void updateValueUtil(int ss,int se,int index,int new_val,int si, int st[])\n    {\n        //base cases\n        if (index < ss || index > se) return;\n        if (se == ss) {\n            st[si] = new_val;\n            return;\n        }\n        \n        //if the input index is in range of this node then we update\n        //the value of the node and its children.\n        int mid = getMid(ss, se);\n        if (index <= mid)\n            updateValueUtil(ss, mid, index, new_val, 2 * si + 1, st);\n        else\n            updateValueUtil(mid + 1, se, index, new_val, 2 * si + 2, st);\n    \n        st[si] = __gcd(st[si * 2 + 1], st[si * 2 + 2]);\n    }\n    \n    //Function to update a value in input array and segment tree.\n    //It uses updateValueUtil() to update the value in segment tree.\n    void updateValue(int index, int new_val, int *arr, int st[], int n)\n    {\n        //base case for invalid input.\n        if (index < 0 || index > n - 1) {\n            return;\n        }\n        arr[index] = new_val;\n        \n        //updating the value of nodes in segment tree.\n        updateValueUtil(0, n - 1, index, new_val, 0, st);\n    }\n};\n",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\nclass Solution\n{\n    // Function to find gcd of 2 numbers. \n    private static int gcd(int a, int b) \n    { \n        if (a < b) \n        { \n            // If b greater than a swap a and b \n            int temp = b; \n            b = a; \n            a = temp; \n        } \n  \n        if (b==0) \n            return a; \n        return gcd(b,a%b); \n    } \n    \n    //recursive function to get gcd of given range of array indexes.\n    public static int findGcd(int ss, int se, int qs, int qe, int si,int st[]) \n    { \n        //if segment of this node is outside the given range, we return 0.\n        if (ss>qe || se < qs) \n            return 0; \n  \n        //if segment of this node is part of given range then we return st[si].\n        if (qs<=ss && qe>=se) \n            return st[si]; \n  \n        //if a part of this segment overlaps with the given range, we call\n        //the function recursively for the children nodes.\n        int mid = ss+(se-ss)/2; \n        return gcd(findGcd(ss, mid, qs, qe, si*2+1,st), \n                   findGcd(mid+1, se, qs, qe, si*2+2,st)); \n    } \n    \n    //Function to find gcd of given range.\n    public static int findRangeGcd(int ss, int se, int st[],int n) \n    { \n        //base case for invalid input.\n        if (ss<0 || se > n-1 || ss>se) \n            throw new IllegalArgumentException(\"Invalid arguments\"); \n  \n        return findGcd(0, n-1, ss, se, 0,st); \n    } \n    \n    //recursive function to update nodes which have given index in their range. \n    public static void updateValueUtil(int ss, int se, int index, \n                                             int new_val, int si, int st[])\n    {\n        //base cases\n        if (index < ss || index > se) \n        return;\n        if (se == ss) {\n            st[si] = new_val;\n            return;\n        }\n        \n        //if the input index is in range of this node then we update\n        //the value of the node and its children. \n        int mid = ss+(se-ss)/2; \n        if (index <= mid)\n            updateValueUtil(ss, mid, index, new_val, 2 * si + 1, st);\n        else\n            updateValueUtil(mid + 1, se, index, new_val, 2 * si + 2, st);\n    \n        st[si] = gcd(st[si * 2 + 1], st[si * 2 + 2]);\n}\n\n\n  //Function to update a value in input array and segment tree.\n  //It uses updateValueUtil() to update the value in segment tree.\n  public static void updateValue(int index,int new_val,int arr[],int st[],int n) \n  {\n        //base case for invalid input.\n        if (index < 0 || index > n - 1) {\n            return;\n        }\n        arr[index] = new_val;\n        \n        //updating the value of nodes in segment tree.\n        updateValueUtil(0, n - 1, index, new_val, 0, st);\n    }\n}\n",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\n\nclass Solution:\n    \n    def gcd(self,a,b):\n    \n        if a<b:\n            a,b=b,a\n        if b==0:\n            return a\n        return self.gcd(b,a%b)\n        \n    #Function to find gcd of given range.\n    def findRangeGcd(self,li,rv,arr,st,n):\n        \n        return self.frg(st,0,n-1,li,rv,0)\n    \n    #recursive function to get gcd of given range of array indexes.    \n    def frg(self,st,ss,se,qs,qe,si):\n        \n        #if segment of this node is outside the given range, we return 0.\n        if ss>qe or se<qs:\n            return 0\n        \n        #if segment of this node is part of given range then we return st[si].\n        if ss>=qs and se<=qe:\n            return st[si]\n        \n        #if a part of this segment overlaps with the given range, we call\n        #the function recursively for the children nodes.    \n        mid=ss+(se-ss)//2\n        a=self.frg(st,ss,mid,qs,qe,si*2+1)\n        b=self.frg(st,mid+1,se,qs,qe,si*2+2)\n        \n        n=self.gcd(a,b)\n        return n\n    \n    #Function to update a value in input array and segment tree.    \n    def updateValue(self,li,rv,arr,st,n):\n        \n        #updating the value of nodes in segment tree.\n        self.uv(st,li,rv,0,n-1,0)\n    \n    #recursive function to update nodes which have given index in their range.    \n    def uv(self,st,li,rv,ss,se,si):\n        \n        #base cases\n        if ss>li or se<li:\n            return\n        if ss==se:\n            st[si]=rv\n            return\n        \n        #if the input index is in range of this node then we update\n        #the value of the node and its children.\n        mid=ss+(se-ss)//2\n        \n        self.uv(st,li,rv,ss,mid,si*2+1)\n        self.uv(st,li,rv,mid+1,se,si*2+2)\n        \n        st[si]=self.gcd(st[si*2+1],st[si*2+2])\n        \n        ",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": null,
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "//Back-end complete function Template for javascript\n\n/**\n * updateValue\n * Function use to update the value present in given array arr at index to new_val\n * @param {number[]} arr (given array)\n * @param {number} n (size of arr)\n * @param {number} index (need to update)\n * @param {number} new_val (given value to which we need to update index)\n * @param {number[]} st (constructed segment-tree)\n * \n * \n * findRangeGcd\n * Finding The gcd of given Range\n * @param {number[]} st (constructed segment-tree)\n * @param {number} n\n * @param {number} l\n * @param {number} r\n * @returns {number}\n*/\n\nclass Solution \n{\n    gcd(a,b)\n    {\n        if(b==0)\n        return a;\n        return this.gcd(b,a%b);\n    }\n    \n    //recursive function to update nodes which have given index in their range.\n    updateValueUtil(ss, se, index, new_val, si, st)\n    {\n        //base cases\n        if (index < ss || index > se) return;\n        if (se == ss) {\n            st[si] = new_val;\n            return;\n        }\n        \n        //if the input index is in range of this node then we update\n        //the value of the node and its children.\n        let mid = getMid(ss, se);\n        if (index <= mid)\n            this.updateValueUtil(ss, mid, index, new_val, 2 * si + 1, st);\n        else\n            this.updateValueUtil(mid + 1, se, index, new_val, 2 * si + 2, st);\n    \n        st[si] =this.gcd(st[si * 2 + 1], st[si * 2 + 2]);\n    }\n\n    //Function to update a value in input array and segment tree.\n    //It uses updateValueUtil() to update the value in segment tree.\n\tupdateValue(index, new_val, arr, st, n)\n\t{\n       //base case for invalid input.\n        if (index < 0 || index > n - 1) {\n            return;\n        }\n        arr[index] = new_val;\n        \n        //updating the value of nodes in segment tree.\n        this.updateValueUtil(0, n - 1, index, new_val, 0, st);\n    }\n    \n    //recursive function to get gcd of given range of array indexes.\n    findGcd(ss, se, qs, qe, si, st) \n    {\n        //if segment of this node is outside the given range, we return 0.\n        if (ss > qe || se < qs) return 0;\n        \n        //if segment of this node is part of given range then we return st[si].\n        // return the sum of the segment.\n        if (qs <= ss && qe >= se) \n        return st[si];\n        \n        //if a part of this segment overlaps with the given range, we call\n        //the function recursively for the children nodes.\n        let mid = Math.floor(ss + (se - ss) / 2);\n        return this.gcd(this.findGcd(ss, mid, qs, qe, si * 2 + 1, st),\n                   this.findGcd(mid + 1, se, qs, qe, si * 2 + 2, st));\n    }\n\n    //Function to find gcd of given range.\n    findRangeGcd(l, r, st, n)\n    {\n        //base case for invalid input.\n        if (l < 0 || r > n - 1 || l > r) {\n            return -1;\n        }\n        return this.findGcd(0, n - 1, l, r, 0, st);\n    }\n}\n",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}