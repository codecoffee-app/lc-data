{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 701771,
            "title": "Renaming Cities",
            "titleSlug": "renaming-cities28581833",
            "content": "<p><span style=\"font-size:18px\">Some cities are going to be renamed and accordingly name of their railway stations will also change. Changing the name of railway station should also result in changed station code.&nbsp;Railways have an idea that station code should be the shortest prefix out of all railway stations renamed prior to this. If some city has same name, then&nbsp;prefix will be the name with suffix as the count of occurence of that city prior to this and including this, seperated with spaces.</span></p>\n\n<p><span style=\"font-size:18px\">Given&nbsp;N&nbsp;renamed cities consisting of lowercase alphabets only. The task is to generate a&nbsp;station ID&nbsp;for all the stations.</span></p>\n\n<p><span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\n\n<pre>\n<span style=\"font-size:18px\"><strong>Input:\n</strong>N = 6\nCities[] = {shimla,safari,jammu,delhi,\n\\t\\t    jammu,dehradun}\n<strong>Output:\n</strong>s\nsa\nj\nd\njammu 2\ndeh<strong>\nExplanation: </strong>Till&nbsp;shimla, no stations are there.\nSo, it&#39;s first character will be the unique\nsmallest prefix. For safari, first character of\nshimla matches, so unique smallest prefix is&nbsp;sa\nSimilarly,&nbsp;j&nbsp;is smallest unique prefix for&nbsp;jammu\nand&nbsp;d&nbsp;is for delhi. For last city&nbsp;jammu, we have\ncountered&nbsp;jammu before, and therefor no smallest\nprefix is possible. So, we can generate its code\nas jammu with suffix equal to the count of jammu,\ni.e, 2. Smallest unique prefix is&nbsp;jammu2. Now,\ndelhi can be renamed as d, and dehradun can be\nrenamed as deh, since deh is the smallest non\nmatching prefix.&nbsp;</span>\n</pre>\n\n<p><span style=\"font-size:18px\"><strong>Your Task:</strong><br />\nComplete&nbsp;<strong>check</strong>&nbsp;function which takes&nbsp;array of strings&nbsp;and&nbsp;number of string&nbsp;&#39;n&#39; as arguments and print the require answer in the function itself. You have to provide new line in the function itself.</span></p>\n\n<p><span style=\"font-size:18px\"><strong>Constraints:</strong><br />\n1 &lt;= N &lt;= 10<sup>6</sup><br />\n1 &lt;= Word Length &lt;= 100</span></p>\n\n<p><span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong>&nbsp;O(N *&nbsp;WORD_LEN).<br />\n<strong>Expected Auxiliary Space:</strong>&nbsp;O(N * WORD_LEN).</span></p>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            ""
        ],
        "relatedTopics": [
            {
                "name": "Strings",
                "slug": "strings"
            },
            {
                "name": "Trie",
                "slug": "trie"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Advanced Data Structure",
                "slug": "advanced-data-structure"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function template for c++\n\nclass Solution\n{\n    public:\n    //Function to insert string into TRIE.\n    void insertInTrie(Node *root, string s)\n    {\n        //if not present, we insert key into trie. If the key is prefix \n        //of trie node, we just mark the leaf node.\n        for(int i = 0;i<=s.length()-1;i++)\n        {\n            if(root->mp[s[i]] == NULL){\n                root->mp[s[i]] = newNode();\n            }\n            root = root->mp[s[i]];\n        }\n        //marking last node as leaf.\n        root->isEndOfWord = true;\n    }\n    \n    //Function to use TRIE data structure and search the given string.\n    int searchInTrie(Node *root, string s)\n    {\n        int i;\n        for( i = 0;i<s.length()-1; i++){\n            if(root->mp[s[i]] == NULL){\n                return i;\n            }\n            root = root->mp[s[i]];\n        }\n        \n        if(root->isEndOfWord == false)\n        return i;\n        \n        return INT_MAX;\n    }\n    \n    void check(string *arr, int n) \n    {\n        map<string,int> mp;\n        Node *root = newNode();\n        for(int i = 0;i<n;i++)\n        {\n            //searching if the string is already present in the trie or not.\n            int k = searchInTrie(root, arr[i]); \n            string s = arr[i];\n            \n            //if the string is present already in the trie we increase the\n            //counter to count the number of times it appears in the trie.\n            if(k == INT_MAX)\n            { \n                mp[s]++; \n                cout << s;\n                    \n                if(mp[s] > 1)\n                    cout << \" \" << mp[s];\n                cout << endl;\n            }\n            else\n            {\n                //printing index upto which string can be uniquely identified.\n                for(int j = 0;j<=k;j++){ \n                    cout << s[j];\n                }\n                //inserting the string.\n                insertInTrie(root, s); \n                mp[s]++;\n                if(mp[s] > 1)\n                    cout << \" \" << mp[s];\n                cout << endl;\n            }\n        }\n    }\n};\n\n\n",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end complete function Template for Java\n\nclass Solution\n{\n    //Function to insert string into TRIE.\n\tpublic static void insertInTrie(Node root, String s)\n\t{\n\t    //if not present, we insert key into trie. If the key is prefix \n        //of trie node, we just mark the leaf node.\n\t    for(int i=0;i<s.length();i++)\n\t    {\n\t        if(root.mp.containsKey(s.charAt(i))==false)\n\t        {\n\t            root.mp.put(s.charAt(i),new Node());\n\t        }\n\t        root=root.mp.get(s.charAt(i));\n\t    }\n\t    //marking last node as leaf.\n\t    root.isEndOfWord=true;\n\t}\n\t\n\t//Function to use TRIE data structure and search the given string.\n\tpublic static int searchInTrie(Node root, String s)\n\t{\n\t    int i=0;\n\t    for(i=0;i<s.length();i++)\n\t    {\n\t         if(root.mp.containsKey(s.charAt(i))==false)\n\t         return i;\n\t         root=root.mp.get(s.charAt(i));\n\t    }\n\t    \n\t    if(root.isEndOfWord==false)\n\t    {\n\t        return i;\n\t    }\n\t    \n\t    return Integer.MAX_VALUE;\n\t}\n\t\n\tpublic static void check(String arr[],int n)\n\t{\n\t    TreeMap<String,Integer>temp=new TreeMap<>();\n\t    Node root=new Node();\n\t    \n\t    for(int i=0;i<n;i++)\n\t    {\n\t        //searching if the string is already present in the trie or not.\n\t        int k=searchInTrie(root,arr[i]);\n\t        String s=arr[i];\n\t        \n\t        //if the string is present already in the trie we increase the\n            //counter to count the number of times it appears in the trie.\n\t        if(k==Integer.MAX_VALUE)\n\t        {\n\t            if(temp.containsKey(s)){\n\t                int val=temp.get(s);\n\t                val++;\n\t                temp.put(s,val);\n\t            }\n\t            else\n\t                temp.put(s,1);\n\t            \n\t            System.out.print(s);\n\t            \n\t            if(temp.get(s)>1)\n\t                System.out.print(\" \"+temp.get(s));\n\t            System.out.println();\n\t        }\n\t        \n\t        else\n\t        {\n\t            //printing index upto which string can be uniquely identified.\n\t            for(int j=0;j<=k;j++)\n\t            {\n\t                if(j<s.length())\n\t                System.out.print(s.charAt(j));\n\t            }\n\t            //inserting the string.\n\t            insertInTrie(root,s);\n\t            if(temp.containsKey(s)){\n\t                int val=temp.get(s);\n\t                val++;\n\t                temp.put(s,val);\n\t            }\n\t            else\n\t                temp.put(s,1);\n\t            \n\t            if(temp.get(s)>1)\n\t                System.out.print(\" \"+temp.get(s));\n\t            System.out.println();\n\t            \n\t        }\n\t    }\n\t}\n}\n",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end complete function Template for Python 3\n\nclass Solution:\n    def getNode(self):\n        return TrieNode()\n    \n    def _charToIndex(self,ch):\n    \n        return ord(ch)-ord('a')\n    \n    #Function to insert string into TRIE.  \n    def insert(self,root, key):\n    \n        pCrawl = root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n    \n            if not pCrawl.children[index]:\n                pCrawl.children[index] = self.getNode()\n            pCrawl = pCrawl.children[index]\n    \n        #marking last node as leaf.\n        pCrawl.isEndOfWord = True\n    \n    #Function to use TRIE data structure and search the given string.\n    def search(self,root, key):\n    \n        pCrawl = root\n        length = len(key)\n        for level in range(length-1):\n            index =self. _charToIndex(key[level])\n            if not pCrawl.children[index]:\n                return level\n            pCrawl = pCrawl.children[index]\n    \n        if(pCrawl.isEndOfWord==False):\n            return length-1\n        return -1\n    \n    def check(self,lst, n):\n        mp = {}\n        root = self.getNode()\n        for i in range(n):\n            \n            #searching if the string is already present in the trie or not.\n            k = self.search(root, lst[i])\n            s = lst[i]\n            \n            #if the string is present already in the trie we increase the\n            #counter to count the number of times it appears in the trie.\n            if (k==-1):\n                if s not in mp:\n                    mp[s]=1\n                else:\n                    mp[s]+=1\n                print(s, end=\" \")\n                if(mp[s]>1):\n                    print(mp[s])\n                else:\n                    print()\n            else:\n                \n                #printing index upto which string can be uniquely identified.\n                for j in range(k+1):\n                    print(s[j], end=\"\")\n                    \n                #inserting the string.\n                self.insert(root, s)\n                if s not in mp:\n                    mp[s]=1\n                else:\n                    mp[s]+=1\n                if(mp[s]>1):\n                    print(mp[s])\n                else:\n                    print()\n",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "//Back-end complete function Template for csharp\n\nclass Solution\n{\n    //Function to insert string into TRIE.\n    public void insert(TrieNode root, string key)\n    {\n        int level;\n        int length = key.Length;\n        int index;\n\n        TrieNode pCrawl = root;\n\n        //if not present, we insert key into trie. If the key is prefix \n        //of trie node, we just mark the leaf node.\n        for (level = 0; level < length; level++)\n        {\n            index = key[level] - 'a';\n            if (pCrawl.children[index] == null)\n                pCrawl.children[index] = new TrieNode();\n\n            pCrawl = pCrawl.children[index];\n        }\n\n        //marking last node as leaf.\n        pCrawl.isLeaf = true;\n    }\n\n    //Function to use TRIE data structure and search the given string.\n    public int search(TrieNode root, string key)\n    {\n        int level;\n        int length = key.Length;\n        int index;\n        TrieNode pCrawl = root;\n\n        for (level = 0; level < length - 1; level++)\n        {\n            index = key[level] - 'a';\n\n            if (pCrawl.children[index] == null) return level;\n\n            pCrawl = pCrawl.children[index];\n        }\n        if (pCrawl.isLeaf == false) return level;\n        return int.MaxValue;\n    }\n    public void check(string[] arr, int n)\n    {\n        Dictionary<string, int> mp = new Dictionary<string, int>();\n        TrieNode root = new TrieNode();\n        for (int i = 0; i < n; i++)\n        {\n            //searching if the string is already present in the trie or not.\n            int k = search(root, arr[i]);\n            string s = arr[i];\n\n            //if the string is present already in the trie we increase the\n            //counter to count the number of times it appears in the trie.\n            if (k == int.MaxValue)\n            {\n                if (mp.ContainsKey(s))\n                    mp[s]++;\n                else\n                    mp.Add(s, 1);\n                Console.Write(s);\n\n                if (mp[s] > 1)\n                    Console.Write(\" \" + mp[s]);\n                Console.WriteLine();\n            }\n            else\n            {\n                //printing index upto which string can be uniquely identified.\n                for (int j = 0; j <= k; j++)\n                {\n                    Console.Write(s[j]);\n                }\n                //inserting the string.\n                insert(root, s);\n                if (mp.ContainsKey(s))\n                    mp[s]++;\n                else\n                    mp.Add(s, 1);\n                if (mp[s] > 1)\n                    Console.Write(\" \" + mp[s]);\n                Console.WriteLine();\n            }\n        }\n    }\n}",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "class Node{\n    constructor(){ \n        this.count1 = 0;\n        this.isEndOfWord = false;\n        this.mp = new Map();\n    }\n}\n\n\n\nlet INT_MAX=1e9;\n/**\n * @param {string[]} arr\n * @param {number} n\n*/\nclass Solution \n{\n    //Function to insert string into TRIE.\n    insertInTrie(root, s)\n    {\n        for(let i = 0;i<=s.length-1;i++){\n            if(!root.mp.has(s[i])){\n                root.mp.set(s[i] , new Node());\n            }\n    \n            root = root.mp.get(s[i]);\n        }\n        //marking last node as leaf.\n        root.isEndOfWord = true;\n    }\n    \n    //Function to use TRIE data structure and search the given string.\n    searchInTrie(root, s)\n    {\n        let i;\n        for( i = 0;i<s.length-1; i++){\n            if(!root.mp.has(s[i])){\n                return i;\n            }\n            root = root.mp.get(s[i]);\n        }\n        \n        if(root.isEndOfWord == false)\n        return i;\n        \n        return INT_MAX;\n    }\n    \n    check(arr, n) {\n        let mp = new Map();\n        let root = new Node();\n        for(let i = 0;i<n;i++)\n        {\n            //searching if the string is already present in the trie or not.\n            let k = this.searchInTrie(root, arr[i]); \n            let s = arr[i];\n            \n            //if the string is present already in the trie we increase the\n            //counter to count the number of times it appears in the trie.\n            if(k == INT_MAX){ \n                if(mp.has(s)) \n                    mp.set(s,1+mp.get(s));\n                else\n                    mp.set(s,0);\n                    \n                if(mp.get(s) > 1)\n                    console.log(s+\" \" + mp.get(s));\n                else\n                    console.log(s);\n            }\n            else{\n                let ans=\"\";\n                //printing index upto which string can be uniquely identified.\n                for(let j = 0;j<=k;j++){\n                    ans+=s[j];\n                }\n                //inserting the string.\n                this.insertInTrie(root, s); \n                if(mp.has(s)) \n                    mp.set(s,1+mp.get(s));\n                else\n                    mp.set(s,1);\n                if(mp.has(s) && mp.get(s) > 1)\n                    ans+= \" \" + mp.get(s);\n                console.log(ans);\n                }\n            }\n    }\n}\n",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}