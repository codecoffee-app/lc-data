{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 705546,
            "title": "Satisfy the equation",
            "titleSlug": "satisfy-the-equation5847",
            "content": "<p><span style=\"font-size: 18px;\">Given an array <strong>A[ ]</strong> of <strong>N</strong> of&nbsp; integers, find the distinct index of values that satisfy<strong> A + B = C + D</strong> where <strong>A,B,C</strong> &amp; <strong>D</strong> are integers values in the array.<br /><strong>Note: </strong>As there may be multiple pairs satisfying the equation return lexicographically smallest order of&nbsp;&nbsp;A, B, C and D and return&nbsp;all as -1 if there are no pairs satisfying the equation.</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Example 1:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong></span>\n<span style=\"font-size: 18px;\"><strong>N = </strong>7</span>\n<span style=\"font-size: 18px;\"><strong>A[] = </strong>{3, 4, 7, 1, 2, 9, 8}</span>\n<span style=\"font-size: 18px;\"><strong>Output:</strong></span>\n<span style=\"font-size: 18px;\">0 2 3 5</span>\n<span style=\"font-size: 18px;\"><strong>Explanation:</strong></span>\n<span style=\"font-size: 18px;\">A[0] + A[2] = 3+7 = 10\nA[3] + A[5] = 1+9 = 10</span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Example 2:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:</strong></span>\n<span style=\"font-size: 18px;\"><strong>N = </strong>4</span>\n<span style=\"font-size: 18px;\"><strong>A[] = </strong>{424, 12, 31, 7}</span>\n<span style=\"font-size: 18px;\"><strong>Output:</strong></span>\n<span style=\"font-size: 18px;\">-1 -1 -1 -1</span>\n<span style=\"font-size: 18px;\"><strong>Explanation:</strong></span>\n<span style=\"font-size: 18px;\">There are no pairs satisfying the equation.</span></pre>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>satisfyEqn()</strong> which takes an Integer N and an array A[] of size N as input and returns a vector of 4 integers denoting A, B, C, and D respectively.</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:</strong> O(N<sup>2</sup>*logN<sup>2</sup>)<br /><strong>Expected Auxiliary Space:</strong> O(N<sup>2</sup>)</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Constraints:</strong></span><br /><span style=\"font-size: 18px;\">1 &lt;= N &lt;= 500<br />1 &lt;= A[i] &lt;= 10<sup>5</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given an array `A` of `N` integers, find distinct indices `a`, `b`, `c`, and `d` such that `A[a] + A[b] = A[c] + A[d]`.  Return the lexicographically smallest such `a b c d`. If no such indices exist, return `-1 -1 -1 -1`.",
                "constraints": [
                    "1 <= N <= 500",
                    "1 <= A[i] <= 10^5"
                ],
                "testcases": [
                    {
                        "input": "N = 7\nA[] = {3, 4, 7, 1, 2, 9, 8}",
                        "output": "0 2 3 5",
                        "explanation": "`A[0] + A[2] = 3 + 7 = 10` and `A[3] + A[5] = 1 + 9 = 10`. The indices 0, 2, 3, and 5 satisfy the condition."
                    },
                    {
                        "input": "N = 4\nA[] = {424, 12, 31, 7}",
                        "output": "-1 -1 -1 -1",
                        "explanation": "No combination of distinct indices satisfies the equation `A[a] + A[b] = A[c] + A[d]`."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Use HashMap to store all pair sums possible first.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Hash",
                "slug": "hash"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class Solution {\r\n  public:\r\n    vector<int> satisfyEqn(int A[], int N) {\r\n        \r\n        // Create an empty Hash to store mapping from sum to \r\n        // pair indexes \r\n        map<int, pair<int, int> > Hash;\r\n        vector<int> Ans;\r\n        \r\n        int flag = 0;\r\n    \r\n        for(int i=0; i<N; ++i)\r\n        {\r\n            for(int j=i+1; j<N; ++j)\r\n            {\r\n                // If sum of current pair is not in hash, \r\n                // then store it and continue to next pair \r\n                int sum = A[i] + A[j];\r\n                \r\n                if (Hash.find(sum) == Hash.end())\r\n                {\r\n                    Hash[sum] = make_pair(i, j); \r\n                    continue;\r\n                }\r\n\r\n                // Find previous pair \r\n                pair<int, int> pp = Hash[sum];// pp->previous pair\r\n\r\n                if(pp.first != i && pp.first != j && pp.second != i && pp.second != j)\r\n                {\r\n                    vector<int> ans(4);\r\n\r\n                    ans[0] = pp.first;\r\n                    ans[1] = pp.second;\r\n                    ans[2] = i;\r\n                    ans[3] = j;\r\n\r\n                    if (Ans.size() == 0)\r\n                        Ans = ans;\r\n\r\n                    // Checking whether the current pairs are lexiographically smallest\r\n                    else\r\n                    {\r\n                        bool shouldReplace = false;\r\n                        for (int i1 = 0; i1 < Ans.size(); i1++)\r\n                        {\r\n                            if (Ans[i1] < ans[i1])\r\n                                break;\r\n                            if (Ans[i1] > ans[i1])\r\n                            {\r\n                                shouldReplace = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        // We replace the pairs if we find a lexiographically smaller pair\r\n                        if (shouldReplace)\r\n                            Ans = ans;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(Ans.size() == 0)\r\n        {\r\n            vector<int> a(4,-1);\r\n            return a;\r\n        }\r\n        \r\n        return Ans;\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution {\r\n    static class pair{\r\n        int a,b;\r\n        public pair(int a,int b){\r\n            this.a=a;\r\n            this.b=b;\r\n        }\r\n    }\r\n    static int[] satisfyEqn(int[] A, int N) {\r\n        // code here\r\n        HashMap<Integer,pair> hm=new HashMap<>();\r\n        ArrayList<Integer> Ans=new ArrayList<>();\r\n    \r\n        for(int i=0; i<N; ++i)\r\n        {\r\n            for(int j=i+1; j<N; ++j)\r\n            {\r\n                // If sum of current pair is not in hash, \r\n                // then store it and continue to next pair \r\n                int sum = A[i] + A[j];\r\n                \r\n                if (!hm.containsKey(sum))\r\n                {\r\n                    hm.put(sum,new pair(i,j));\r\n                    continue;\r\n                }\r\n\r\n                // Find previous pair \r\n                pair pp = hm.get(sum);// pp->previous pair\r\n\r\n                if(pp.a != i && pp.a != j && pp.b != i && pp.b != j)\r\n                {\r\n                    int ans[]=new int[4];\r\n\r\n                    ans[0] = pp.a;\r\n                    ans[1] = pp.b;\r\n                    ans[2] = i;\r\n                    ans[3] = j;\r\n\r\n                    if (Ans.size() == 0)\r\n                    {\r\n                        for(int k=0;k<4;k++){\r\n                            Ans.add(ans[k]);\r\n                        }\r\n                    }\r\n\r\n                    // Checking whether the current pairs are lexiographically smallest\r\n                    else\r\n                    {\r\n                        boolean shouldReplace = false;\r\n                        for (int i1 = 0; i1 < Ans.size(); i1++)\r\n                        {\r\n                            if (Ans.get(i1) < ans[i1])\r\n                                break;\r\n                            if (Ans.get(i1) > ans[i1])\r\n                            {\r\n                                shouldReplace = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        // We replace the pairs if we find a lexiographically smaller pair\r\n                        if (shouldReplace)\r\n                            for(int k=0;k<4;k++){\r\n                                Ans.set(k,ans[k]);\r\n                            }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if(Ans.size() == 0)\r\n        {\r\n            return new int[]{-1,-1,-1,-1};\r\n        }\r\n        int arr[]=new int[4];\r\n        for(int i=0;i<4;i++){\r\n            arr[i]=Ans.get(i);\r\n        }\r\n        return arr;\r\n    }\r\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "class Solution:\r\n    def satisfyEqn(self, A, N):\r\n        Hash={} #create an empty dictionary to store sums\r\n        Ans=[] #create an empty list to store the final answer\r\n        flag=0 #initialize a flag variable to 0\r\n        for i in range(N): #loop through the elements in A\r\n            for j in range(i+1,N): #loop through the elements after index i in A\r\n                sum=A[i]+A[j] #calculate the sum of the current pair of elements\r\n                if sum not in Hash: #if the sum is not present in the dictionary\r\n                    Hash[sum]=(i,j) #add the sum as a key and the pair of indices as its value\r\n                else: #if the sum is already present in the dictionary\r\n                    pp=Hash[sum] #get the pair of indices for the sum\r\n                    if pp[0]!=i and pp[0]!=j and pp[1]!=i and pp[1]!=j: #if the pair of indices is not the same as the current pair\r\n                        ans=[] #create an empty list to store the indices\r\n                        ans.append(pp[0]) #add the first index from the dictionary pair\r\n                        ans.append(pp[1]) #add the second index from the dictionary pair\r\n                        ans.append(i) #add the first index from the current pair\r\n                        ans.append(j) #add the second index from the current pair\r\n                        if not Ans: #if the final answer list is empty\r\n                            Ans=ans[:] #copy the current list of indices as the final answer\r\n                        else: #if the final answer list is not empty\r\n                            shouldReplace=False #initialize a variable to determine if the current list of indices should replace the final answer\r\n                            for i1 in range(len(Ans)): #loop through the elements in the final answer list\r\n                                if Ans[i1]<ans[i1]: #if the corresponding element in the final answer list is smaller than the corresponding element in the current list\r\n                                    break #break the loop\r\n                                if Ans[i1]>ans[i1]: #if the corresponding element in the final answer list is larger than the corresponding element in the current list\r\n                                    shouldReplace=True #set the variable to indicate that the current list should replace the final answer\r\n                                    break #break the loop\r\n                            if shouldReplace: #if the current list should replace the final answer\r\n                                Ans=ans #replace the final answer with the current list\r\n        if not Ans: #if no valid indices were found\r\n            return [-1,-1,-1,-1] #return a list of -1\r\n        return Ans #return the list of valid indices if any were found",
                "lang_text": "python3"
            },
            {
                "lang": "C#",
                "full_func": "// User function Template for C#\nclass Solution {\n    // Function to satisfy the equation.\n    public List<int> satisfyEqn(int[] A, int N) {\n        // Create an empty Dictionary to store mapping from sum to\n        // pair indexes\n        Dictionary<int, KeyValuePair<int, int>> Hash =\n            new Dictionary<int, KeyValuePair<int, int>>();\n        List<int> Ans = new List<int>();\n\n        for (int i = 0; i < N; ++i) {\n            for (int j = i + 1; j < N; ++j) {\n                // If sum of current pair is not in dictionary,\n                // then store it and continue to next pair\n                int sum = A[i] + A[j];\n\n                if (!Hash.ContainsKey(sum)) {\n                    Hash[sum] = new KeyValuePair<int, int>(i, j);\n                    continue;\n                }\n\n                // Find previous pair\n                KeyValuePair<int, int> pp = Hash[sum]; // pp->previous pair\n\n                if (pp.Key != i && pp.Key != j && pp.Value != i && pp.Value != j) {\n                    List<int> ans = new List<int>();\n\n                    ans.Add(pp.Key);\n                    ans.Add(pp.Value);\n                    ans.Add(i);\n                    ans.Add(j);\n\n                    if (Ans.Count == 0) Ans = ans;\n\n                    // Checking whether the current pairs are lexiographically smallest\n                    else {\n                        bool shouldReplace = false;\n                        for (int i1 = 0; i1 < Ans.Count; i1++) {\n                            if (Ans[i1] < ans[i1]) break;\n                            if (Ans[i1] > ans[i1]) {\n                                shouldReplace = true;\n                                break;\n                            }\n                        }\n                        // We replace the pairs if we find a lexiographically smaller\n                        // pair\n                        if (shouldReplace) Ans = ans;\n                    }\n                }\n            }\n        }\n\n        if (Ans.Count == 0) {\n            List<int> a = new List<int> { -1, -1, -1, -1 };\n            return a;\n        }\n\n        return Ans;\n    }\n}",
                "lang_text": "csharp"
            },
            {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\r\n/**\r\n * @param {number[]} A\r\n * @param {number} N\r\n * @returns {number[]}\r\n*/\r\n\r\nclass Solution\r\n{\r\n    //Function to satisfy the given equation.\r\n    satisfyEqn(A, N)\r\n    {\r\n        let Hash={};\r\n        let Ans=[];\r\n        let flag=0;\r\n        for (let i = 0; i < N; i++) {\r\n            for (let j = i+1; j < N; j++) {\r\n                let sum = A[i]+A[j];\r\n                if (!(sum in Hash)) {\r\n                    Hash[sum] = [i, j];\r\n                }\r\n                else {\r\n                    let pp = Hash[sum];\r\n                    if (pp[0] !== i && pp[0] !== j && pp[1] !== i && pp[1] !== j) {\r\n                        let ans = [];\r\n                        ans.push(pp[0]);\r\n                        ans.push(pp[1]);\r\n                        ans.push(i);\r\n                        ans.push(j);\r\n                        if (Ans.length === 0) {\r\n                            Ans = ans.slice();\r\n                        }\r\n                        else {\r\n                            let shouldReplace = false;\r\n                            for (let i1 = 0; i1 < Ans.length; i1++) {\r\n                                if (Ans[i1] < ans[i1]) {\r\n                                    break;\r\n                                }\r\n                                if (Ans[i1] > ans[i1]) {\r\n                                    shouldReplace = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (shouldReplace) {\r\n                                Ans = ans.slice();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (Ans.length === 0) {\r\n            return [-1,-1,-1,-1];\r\n        }\r\n        return Ans;\r\n    }\r\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}