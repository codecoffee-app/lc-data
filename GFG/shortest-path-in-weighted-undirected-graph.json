{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 712228,
            "title": "Shortest Path in Weighted undirected graph",
            "titleSlug": "shortest-path-in-weighted-undirected-graph",
            "content": "<p><span style=\"font-size: 18px;\">You are given a weighted undirected graph having <strong>n</strong> vertices numbered from <strong>1 to n</strong> and <strong>m</strong> edges along with their weights. Find the <strong>shortest&nbsp;</strong></span><strong style=\"font-size: 18px;\">weight </strong><span style=\"font-size: 18px;\"><strong>path </strong>between the vertex 1 and the vertex <strong>n</strong>,&nbsp;</span><span style=\"font-size: 18px;\"> if there exists a path, and return<strong> </strong>a list of integers whose first element is the <strong>weight </strong>of the path, and the rest consist of the nodes on that path. If no path exists, then return a list containing a single element <strong>-1</strong>.</span></p>\n<p><span style=\"font-size: 18px;\">The input list of edges is as follows - <strong>{a, b, w}</strong>, denoting there is an edge between <strong>a</strong> and <strong>b</strong>, and <strong>w</strong> is the weight of that edge.</span></p>\n<p><strong><em><span style=\"font-size: 18px;\">Note:</span></em><span style=\"font-size: 18px;\"> </span></strong><span >The driver code here will first check&nbsp;if the&nbsp;weight of the path&nbsp;returned is&nbsp;<strong>equal</strong>&nbsp;to the&nbsp;<strong>sum </strong>of the weights along the nodes on that path, if&nbsp;<strong>equal</strong>&nbsp;it will output the&nbsp;weight of the path,&nbsp;else&nbsp;<strong>-2</strong>. In case the list contains only a single element (<strong>-1</strong>)&nbsp;it will simply output <strong>-1</strong>.&nbsp;</span></p>\n<p><strong><span style=\"font-size: 18px;\">Examples :</span></strong></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input: </strong>n = 5, m= 6, edges = [[1, 2, 2], [2, 5, 5], [2, 3, 4], [1, 4, 1], [4, 3, 3], [3, 5, 1]]\n<strong>Output: </strong>5\n<strong>Explanation: </strong>Shortest path from 1 to n is by the path 1 4 3 5 whose weight is 5. <br /></span></pre>\n<pre><span style=\"font-size: 18px;\"><strong>Input: </strong>n = 2, m= 1, edges = [[1, 2, 2]]\n<strong>Output: </strong>2\n<strong>Explanation: </strong>Shortest path from 1 to 2 is by the path 1 2 whose weight is 2. </span></pre>\n<pre><span style=\"font-size: 18px;\"><strong>Input: </strong>n = 2, m= 0, edges = [ ]\n<strong>Output: </strong>-1\n<strong>Explanation: </strong>Since there are no edges, so no answer is possible.</span></pre>\n<p><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:</strong> O(m* log(n))<br /><strong>Expected Space Complexity:</strong> O(n+m)</span></p>\n<p><span style=\"font-size: 18px;\"><strong>Constraint:</strong><br />2 &lt;= n &lt;= 10<sup>6</sup><br />0 &lt;= m &lt;= 10<sup>6</sup><br />1 &lt;= a, b &lt;= n<br />1 &lt;= w &lt;= 10<sup>5</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p>Think of a modified form of Dijkstra's algorithm.&nbsp;</p>",
            "<p>Use a priority queue (set) to iteratively explore the shortest paths from the starting node (node 1) to the target node (node n), ensuring that at each step, the node with the smallest accumulated distance is processed next.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Graph",
                "slug": "graph"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "class Solution {\n  public:\n    vector<int> shortestPath(int n, int m, vector<vector<int>>& edges) {\n        // Code here\n        vector<int> ans;\n        vector<int> parent(n + 1);\n        set<pair<int, pair<int, int>>> st;\n        st.insert({0, {1, 1}});\n        vector<int> vis(n + 1);\n        vector<vector<vector<int>>> adj(n + 1);\n        for (auto i : edges) {\n            adj[i[0]].push_back({i[1], i[2]});\n            adj[i[1]].push_back({i[0], i[2]});\n        }\n        int temp = -1;\n        while (!st.empty()) {\n            int d = st.begin()->first;\n            int p = st.begin()->second.first;\n            int par = st.begin()->second.second;\n            st.erase(st.begin());\n            if (vis[p] == 1)\n                continue;\n            parent[p] = par;\n            if (p == n) {\n                temp = d;\n                break;\n            }\n            vis[p] = 1;\n            for (auto j : adj[p]) {\n                st.insert({j[1] + d, {j[0], p}});\n            }\n        }\n\n        if (temp == -1)\n            return {-1};\n        int p = n;\n        while (p != 1) {\n            ans.push_back(p);\n            p = parent[p];\n        }\n        ans.push_back(1);\n        ans.push_back(temp);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Pair {\n    int first;\n    int second;\n\n    public Pair(int first, int second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public static List<Integer> shortestPath(int n, int m, int edges[][]) {\n\n        // Create an adjacency list of pairs of the form node1 -> {node2, edge weight}\n        // where the edge weight is the weight of the edge from node1 to node2.\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < m; i++) {\n            adj.get(edges[i][0]).add(new Pair(edges[i][1], edges[i][2]));\n            adj.get(edges[i][1]).add(new Pair(edges[i][0], edges[i][2]));\n        }\n\n        // Create a priority queue for storing the nodes along with distances\n        // in the form of a pair { dist, node }.\n        PriorityQueue<Pair> pq = new PriorityQueue<Pair>((x, y) -> x.first - y.first);\n\n        // Create a dist array for storing the updated distances and a parent array\n        // for storing the nodes from where the current nodes represented by indices of\n        // the parent array came from.\n        int[] dist = new int[n + 1];\n        int[] parent = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            dist[i] = (int)(1e9);\n            parent[i] = i;\n        }\n\n        dist[1] = 0;\n\n        // Push the source node to the queue.\n        pq.add(new Pair(0, 1));\n        while (pq.size() != 0) {\n\n            // Topmost element of the priority queue is with minimum distance value.\n            Pair it = pq.peek();\n            int node = it.second;\n            int dis = it.first;\n            pq.remove();\n\n            // Iterate through the adjacent nodes of the current popped node.\n            for (Pair iter : adj.get(node)) {\n                int adjNode = iter.first;\n                int edW = iter.second;\n\n                // Check if the previously stored distance value is\n                // greater than the current computed value or not,\n                // if yes then update the distance value.\n                if (dis + edW < dist[adjNode]) {\n                    dist[adjNode] = dis + edW;\n                    pq.add(new Pair(dis + edW, adjNode));\n\n                    // Update the parent of the adjNode to the recent\n                    // node where it came from.\n                    parent[adjNode] = node;\n                }\n            }\n        }\n\n        // Store the final path in the \u2018path\u2019 array.\n        List<Integer> path = new ArrayList<>();\n\n        // If distance to a node could not be found, return an array containing -1.\n        if (dist[n] == 1e9) {\n            path.add(-1);\n            return path;\n        }\n\n        int node = n;\n        // o(N)\n        while (parent[node] != node) {\n            path.add(node);\n            node = parent[node];\n        }\n        path.add(1);\n\n        // Since the path stored is in a reverse order, we reverse the array\n        // to get the final answer and then return the array.\n        path.add(dist[n]);\n        Collections.reverse(path);\n        return path;\n    }\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "from collections import defaultdict\nfrom heapq import heappush, heappop\nfrom typing import List\n\n\nclass Solution:\n\n    def shortestPath(self, n: int, m: int,\n                     edges: List[List[int]]) -> List[int]:\n        par = [-1] * (n + 1)\n        inf = float('inf')\n        dist = [inf] * (n + 1)\n\n        gp = defaultdict(list)\n\n        for a, b, w in edges:\n            gp[a].append((b, w))\n            gp[b].append((a, w))\n\n        pq = []\n        heappush(pq, (0, 1, -1))\n\n        while pq:\n            w, node, p = heappop(pq)\n            if w > dist[node]:\n                continue\n            dist[node] = w\n            par[node] = p\n\n            for adj, d in gp[node]:\n                if dist[adj] > w + d:\n                    dist[adj] = w + d\n                    heappush(pq, (w + d, adj, node))\n\n        if dist[n] == inf:\n            return [-1]\n\n        ans = []\n        p = n\n        while p != -1:\n            ans.append(p)\n            p = par[p]\n\n        ans.append(dist[n])\n        ans.reverse()\n\n        return ans\n",
                "lang_text": "python3"
            },
            {
                "lang": "Javascript",
                "full_func": "class MinPriorityQueue {\n    constructor({compare}) {\n        this.compare = compare;\n        this.data = [];\n    }\n\n    enqueue(element) {\n        this.data.push(element);\n        this._bubbleUp(this.data.length - 1);\n    }\n\n    dequeue() {\n        if (this.data.length === 1) {\n            return this.data.pop();\n        }\n        const top = this.data[0];\n        this.data[0] = this.data.pop();\n        this._bubbleDown(0);\n        return top;\n    }\n\n    isEmpty() { return this.data.length === 0; }\n\n    _bubbleUp(index) {\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n            if (this.compare(this.data[index], this.data[parentIndex]) < 0) {\n                [this.data[index], this.data[parentIndex]] =\n                    [ this.data[parentIndex], this.data[index] ];\n                index = parentIndex;\n            } else {\n                break;\n            }\n        }\n    }\n\n    _bubbleDown(index) {\n        const length = this.data.length;\n        while (true) {\n            const leftChildIndex = 2 * index + 1;\n            const rightChildIndex = 2 * index + 2;\n            let smallestIndex = index;\n\n            if (leftChildIndex < length &&\n                this.compare(this.data[leftChildIndex], this.data[smallestIndex]) < 0) {\n                smallestIndex = leftChildIndex;\n            }\n            if (rightChildIndex < length &&\n                this.compare(this.data[rightChildIndex], this.data[smallestIndex]) <\n                    0) {\n                smallestIndex = rightChildIndex;\n            }\n            if (smallestIndex === index) break;\n\n            [this.data[index], this.data[smallestIndex]] =\n                [ this.data[smallestIndex], this.data[index] ];\n            index = smallestIndex;\n        }\n    }\n}\n\nclass Pair {\n    constructor(first, second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    /**\n     * @param {number} n\n     * @param {number} m\n     * @param {number[][]} edges\n     * @returns {number[]}\n     */\n    shortestPath(n, m, edges) {\n        // Create an adjacency list of pairs of the form node1 -> {node2, edge weight}\n        let adj = Array.from({length : n + 1}, () => []);\n        for (let i = 0; i < m; i++) {\n            adj[edges[i][0]].push(new Pair(edges[i][1], edges[i][2]));\n            adj[edges[i][1]].push(new Pair(edges[i][0], edges[i][2]));\n        }\n\n        // Create a priority queue for storing the nodes along with distances\n        // in the form of a pair { dist, node }.\n        let pq = new MinPriorityQueue({compare : (x, y) => x.first - y.first});\n\n        // Create a dist array for storing the updated distances and a parent array\n        // for storing the nodes from where the current nodes represented by indices of\n        // the parent array came from.\n        let dist = new Array(n + 1).fill(Infinity);\n        let parent = new Array(n + 1);\n        for (let i = 1; i <= n; i++) {\n            parent[i] = i;\n        }\n\n        dist[1] = 0;\n\n        // Push the source node to the queue.\n        pq.enqueue(new Pair(0, 1));\n        while (!pq.isEmpty()) {\n            // Topmost element of the priority queue is with minimum distance value.\n            let it = pq.dequeue();\n            let node = it.second;\n            let dis = it.first;\n\n            // Iterate through the adjacent nodes of the current popped node.\n            for (let iter of adj[node]) {\n                let adjNode = iter.first;\n                let edW = iter.second;\n\n                // Check if the previously stored distance value is\n                // greater than the current computed value or not,\n                // if yes then update the distance value.\n                if (dis + edW < dist[adjNode]) {\n                    dist[adjNode] = dis + edW;\n                    pq.enqueue(new Pair(dis + edW, adjNode));\n\n                    // Update the parent of the adjNode to the recent\n                    // node where it came from.\n                    parent[adjNode] = node;\n                }\n            }\n        }\n\n        // Store the final path in the \u2018path\u2019 array.\n        let path = [];\n\n        // If distance to a node could not be found, return an array containing -1.\n        if (dist[n] === Infinity) {\n            path.push(-1);\n            return path;\n        }\n\n        let node = n;\n        while (parent[node] !== node) {\n            path.push(node);\n            node = parent[node];\n        }\n        path.push(1);\n\n        // Since the path stored is in a reverse order, we reverse the array\n        // to get the final answer and then return the array.\n        path.push(dist[n]);\n        path.reverse();\n        return path;\n    }\n}\n",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}