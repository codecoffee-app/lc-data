{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 713968,
            "title": "Shortest Path Using Atmost One Curved Edge",
            "titleSlug": "shortest-path-using-atmost-one-curved-edge--170647",
            "content": "<p><span style=\"font-size: 18px;\">Given an undirected connected graph of <strong>n</strong> vertices and list of <strong>m</strong> edges in a graph and for each pair of vertices that are connected by an edge.&nbsp;</span></p>\n<p><span style=\"font-size: 18px;\">There are two edges between them, one curved edge and one straight edge i.e. the tuple <strong>(x, y, w1, w2) </strong>means that between vertices <strong>x</strong> and <strong>y</strong>, there is a straight edge with weight <strong>w1</strong> and a curved edge with weight <strong>w2</strong>. </span></p>\n<p><span style=\"font-size: 18px;\">You are given two vertices <strong>a</strong> and <strong>b</strong> and you have to go from <strong>a</strong> to <strong>b</strong> through a series of edges such that in the entire path you can use at most 1 curved edge. Your task is to find the shortest path from <strong>a</strong> to <strong>b</strong> satisfying the above condition. If there is no path from a to b, return <strong>-1</strong>.</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px;\"><strong>Example 1:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:\n</strong>n = 4, m = 4\na = 2, b = 4\nedges = {{1, 2, 1, 4}, {1, 3, 2, 4},\n\\t   {1, 4, 3, 1}, {2, 4, 6, 5}}\n<strong>Output:\n</strong>2\n</span><img src=\"https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/713968/Web/Other/e0873f96-11df-491f-9252-ad8911bbb26d_1685087926.png\" /><span style=\"font-size: 18px;\">\n<strong>Explanation:</strong>\nWe can follow the path 2 -&gt; 1 -&gt; 4.</span>\n<span style=\"font-size: 18px;\">This gives a distance of 1+3 = 4 if we follow\nall straight paths. But we can take the curved\npath  from 1 -&gt; 4, which costs 1. This\nwill result in a cost of 1+1 = 2</span>\n</pre>\n<div><span style=\"font-size: 18px;\"><strong>Example 2:</strong></span></div>\n<pre><span style=\"font-size: 18px;\"><strong>Input:\n</strong>n = 2, m = 1\na = 1, b = 2\nedges = {{1, 2, 4, 1}}\n<strong>Output :</strong>\n1\n</span><img src=\"https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/713968/Web/Other/fcf19135-c88b-48ac-8fc4-bc46efc7ca3f_1685087926.png\" />\n<span style=\"font-size: 18px;\"><strong>Explanation:</strong>\nTake the curved path from 1 to 2 which costs 1. </span>\n</pre>\n<p><br /><span style=\"font-size: 18px;\"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>shortestPath()</strong>&nbsp;which takes 4 integers n, m, a, and b, and a list of lists named edges of size m as input and returns the cost of shortest path from a to b.</span></p>\n<p><br /><span style=\"font-size: 18px;\"><strong>Expected Time Complexity:</strong> O((m+n)log(n))<br /><strong>Expected Auxiliary Space:</strong> O(n+m)</span></p>\n<p><br /><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; n,m &le; 10<sup>5</sup><br />1 &le; a,b &le; n<br />weight of edges &le; 10<sup>4</sup></span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given an undirected connected graph with 'n' vertices and 'm' edges. Each edge between vertices 'x' and 'y' has two associated weights: 'w1' for the straight edge and 'w2' for the curved edge, represented as the tuple (x, y, w1, w2). Find the shortest path from vertex 'a' to vertex 'b', using at most one curved edge in the entire path. If no path exists, return -1.",
                "constraints": [
                    "1 <= n, m <= 10^5",
                    "1 <= a, b <= n",
                    "weight of edges <= 10^4"
                ],
                "testcases": [
                    {
                        "input": "n = 4, m = 4\na = 2, b = 4\nedges = {{1, 2, 1, 4}, {1, 3, 2, 4},\n\t   {1, 4, 3, 1}, {2, 4, 6, 5}}",
                        "output": "2",
                        "explanation": "The shortest path is 2 -> 1 -> 4. Using only straight edges, the cost is 1 + 3 = 4. However, we can use the curved edge from 1 -> 4, which costs 1. The total cost becomes 1 + 1 = 2."
                    },
                    {
                        "input": "n = 2, m = 1\na = 1, b = 2\nedges = {{1, 2, 4, 1}}",
                        "output": "1",
                        "explanation": "The shortest path is 1 -> 2 using the curved edge, costing 1."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Use Dijkstra&#39;s Algorithm.</span></p>",
            "<p><span style=\"font-size:18px\">Run dijkstra from node a. Let&#39;s call Da[i] be the shortest path to node i from node a using only straight edges.</span><br />\n<span style=\"font-size:18px\">Again run dijkstra from node b. Let&#39;s call Db[i] be the shortest path to node i from node b using only straight edges.</span></p>\n\n<p><span style=\"font-size:18px\">Now, check cost using every curved edge once and find the minimum.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Graph",
                "slug": "graph"
            },
            {
                "name": "Shortest Path",
                "slug": "shortest-path"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [
            "uber"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\r\n\r\nclass Solution {\r\n  public:\r\n  \r\n    vector<int> dijkstra(int u, int b, int n, vector<pair<int,int>> adj[]) {\r\n        vector<int> dis;\r\n        dis.assign(n+1, 1000000001);\r\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\r\n        dis[u] = 0;\r\n        pq.push({0, u});\r\n     \r\n        while(!pq.empty()) {\r\n            int u = pq.top().second;\r\n            pq.pop();\r\n    \r\n            for(auto p: adj[u]) {\r\n                  int v = p.first;\r\n                  int w = p.second;\r\n                  if(dis[v] > dis[u] + w) {\r\n                        dis[v] = dis[u] + w;\r\n                        pq.push({dis[v], v});\r\n                  }\r\n            }\r\n        }\r\n        return dis;\r\n    }\r\n\r\n    int shortestPath(int n, int m, int a, int b, vector<vector<int>> &edges) {\r\n        vector<pair<int,int>> adj[n+1];\r\n        vector<vector<int>> curved;\r\n        \r\n        for(int i=0; i<m; i++)\r\n        {\r\n            int u = edges[i][0];\r\n            int v = edges[i][1];\r\n            int w = edges[i][2];\r\n            int cw = edges[i][3];\r\n            \r\n            adj[u].push_back({v, w});\r\n            adj[v].push_back({u, w});\r\n            \r\n            // curved edge weight\r\n            curved.push_back({u, v, cw});\r\n        }\r\n        \r\n        vector<int> da = dijkstra(a, b, n, adj);\r\n        vector<int> db = dijkstra(b, a, n, adj);\r\n        \r\n        int ans = da[b];\r\n \r\n        // ans = min distance from a -> b with at max one curved edge \r\n        // current ans without curved edge from a -> b = da[b]\r\n    \r\n        for(int i=0; i<m; i++)\r\n        {\r\n            int u = curved[i][0];\r\n            int v = curved[i][1];\r\n            int cw = curved[i][2];\r\n    \r\n            ans = min(ans, da[u] + cw + db[v]);\r\n            ans = min(ans, da[v] + cw + db[u]);\r\n        }\r\n        \r\n        if(ans>=1000000001) return -1;\r\n        return ans;\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "//Back-end function Template for Java\r\n\r\nclass Solution {\r\n    static class pair implements Comparable<pair> {\r\n\t\tint to;\r\n\t\tint number;\r\n \r\n\t\tpair(int t, int n) {\r\n\t\t\tnumber = n;\r\n\t\t\tto = t;\r\n\t\t}\r\n \r\n\t\t@Override\r\n\t\tpublic int compareTo(pair o) {\r\n\t\t\treturn Integer.compare(number, o.number);\r\n\t\t}\r\n \r\n\t}\r\n\t\r\n\tstatic int[] dijkstra(int u, int b, int n, ArrayList<pair>[] adj) {\r\n\t    int[] dis = new int[n+1];\r\n\t    for(int i=0; i<=n; i++)\r\n\t        dis[i] = 1000000001;\r\n\t    \r\n\t    PriorityQueue<pair> pq = new PriorityQueue<>();\r\n\t    dis[u] = 0;\r\n\t    pq.add(new pair(u, 0));\r\n\t    \r\n\t    while (!pq.isEmpty())\r\n\t\t{\r\n\t\t\tpair cur = pq.poll();\r\n\t\t\tint v = cur.to;\r\n\t\t\tfor (pair vs : adj[v])\r\n\t\t\t{\r\n\t\t\t    int y = vs.to;\r\n\t\t\t    int w = vs.number;\r\n\t\t\t\tif (dis[y] > dis[v] + w)\r\n\t\t\t\t{\r\n\t\t\t\t\tdis[y] = w + dis[v];\r\n\t\t\t\t\tpq.add(new pair(y,dis[y]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn dis;\r\n\t}\r\n\t\r\n    static int shortestPath(int n, int m, int a, int b, ArrayList<ArrayList<Integer>> edges) {\r\n        ArrayList<pair>[] adj = new ArrayList[n+1];\r\n        ArrayList<ArrayList<Integer>> curved = new ArrayList<>();\r\n        \r\n        for(int i=0; i<=n; i++)\r\n\t\t\tadj[i] = new ArrayList<>();\r\n\t\t\t\r\n\t\tfor(int i=0; i<m; i++)\r\n\t\t{\r\n\t\t    int u = edges.get(i).get(0);\r\n\t\t    int v = edges.get(i).get(1);\r\n\t\t    int w = edges.get(i).get(2);\r\n\t\t    int cw = edges.get(i).get(3);\r\n\t\t    adj[u].add(new pair(v, w));\r\n\t\t\tadj[v].add(new pair(u, w));\r\n\t\t\t\r\n\t\t\t// curved edge weight\r\n            ArrayList<Integer> temp = new ArrayList<>();\r\n            temp.add(u);\r\n            temp.add(v);\r\n            temp.add(cw);\r\n            curved.add(temp);\r\n\t\t}\r\n\t\t\r\n\t\tint[] da = dijkstra(a, b, n, adj);\r\n        int[] db = dijkstra(b, a, n, adj);\r\n        \r\n        int ans = da[b];\r\n        \r\n        // ans = min distance from a -> b with at max one curved edge \r\n        // current ans without curved edge from a -> b = da[b]\r\n    \r\n        for(int i=0; i<m; i++)\r\n        {\r\n            int u = curved.get(i).get(0);\r\n            int v = curved.get(i).get(1);\r\n            int cw = curved.get(i).get(2);\r\n    \r\n            ans = Math.min(ans, da[u] + cw + db[v]);\r\n            ans = Math.min(ans, da[v] + cw + db[u]);\r\n        }\r\n        \r\n        if(ans>=1000000001) return -1;\r\n        return ans;\r\n    }\r\n};",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "#Back-end function Template for python3\r\n\r\nclass Solution:\r\n    def dijkstra(self, u, b, n, adj):\r\n        unused = [] \r\n        dis = [float('inf')]*(n+1)\r\n        \r\n        dis[u] = 0\r\n        \r\n        unused.append((0,u))\r\n        \r\n        heapify(unused)\r\n        \r\n        while unused:\r\n            x, v = heappop(unused)\r\n         \r\n            if x > dis[v]:\r\n                continue\r\n            \r\n            for edge in adj[v]:\r\n                u = edge[0]\r\n                w = edge[1]\r\n                \r\n                if dis[v] + w < dis[u]:\r\n                    dis[u] = dis[v] + w\r\n                    heappush(unused, (dis[u], u))\r\n        \r\n        return dis\r\n        \r\n    def shortestPath(self, n, m, a, b, edges):\r\n        adj = [[] for i in range(n+1)]\r\n        curved = []\r\n        \r\n        for i in range(m):\r\n            u = edges[i][0]\r\n            v = edges[i][1]\r\n            w = edges[i][2]\r\n            cw = edges[i][3]\r\n            \r\n            adj[u].append((v,w))\r\n            adj[v].append((u,w))\r\n            \r\n            # curved edge weight\r\n            curved.append([u, v, cw])\r\n        \r\n        da = self.dijkstra(a,b,n,adj)\r\n        db = self.dijkstra(b,a,n,adj)\r\n        \r\n        ans = da[b]\r\n        \r\n        # ans = min distance from a -> b with at max one curved edge \r\n        # current ans without curved edge from a -> b = da[b]\r\n    \r\n        for i in range(m):\r\n            u = curved[i][0]\r\n            v = curved[i][1]\r\n            cw = curved[i][2]\r\n    \r\n            ans = min(ans, da[u] + cw + db[v])\r\n            ans = min(ans, da[v] + cw + db[u])\r\n            \r\n        if ans >= 1000000001:\r\n            return -1\r\n        return ans",
                "lang_text": "py"
            },
            {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\n/**\n * @param {number} n\n * @param {number} m\n * @param {number[]} a\n * @param {number[]} b\n * @param {number[][]} edges\n * @returns {number}\n*/\n\nclass Solution\n{\n    //Function to find the shortest path for a weighted graph.\n    shortestPath(n, m, a, b, edges)\n    {\n        //Back-end function Template for python3\n\n        function dijkstra(u, b, n, adj) {\n            const unused = [];\n            const dis = new Array(n+1).fill(Number.POSITIVE_INFINITY);\n\n            dis[u] = 0;\n\n            unused.push([0,u]);\n\n            const heapify = arr => {\n                let i = Math.floor(arr.length / 2) - 1;\n                while (i >= 0) {\n                    siftDown(arr, i, arr.length);\n                    i--;\n                }\n            };\n\n            const siftDown = (arr, i, n) => {\n                let largest = i;\n                const left = 2 * i + 1;\n                const right = 2 * i + 2;\n\n                if (left < n && arr[left][0] < arr[largest][0]) {\n                    largest = left;\n                }\n\n                if (right < n && arr[right][0] < arr[largest][0]) {\n                    largest = right;\n                }\n\n                if (largest !== i) {\n                    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n                    siftDown(arr, largest, n);\n                }\n            };\n\n            const heappop = arr => {\n                const popped = arr[0];\n                const last = arr.pop();\n\n                if (arr.length > 0) {\n                    arr[0] = last;\n                    siftDown(arr, 0, arr.length);\n                }\n\n                return popped;\n            };\n\n            const heappush = (arr, item) => {\n                arr.push(item);\n                let i = arr.length - 1;\n\n                while (i > 0) {\n                    const parent = Math.floor((i - 1) / 2);\n\n                    if (arr[i][0] < arr[parent][0]) {\n                        [arr[i], arr[parent]] = [arr[parent], arr[i]];\n                        i = parent;\n                    } else {\n                        break;\n                    }\n                }\n            };\n\n            heapify(unused);\n\n            while (unused.length > 0) {\n                const [x, v] = heappop(unused);\n\n                if (x > dis[v]) {\n                    continue;\n                }\n\n                for (const edge of adj[v]) {\n                    const u = edge[0];\n                    const w = edge[1];\n\n                    if (dis[v] + w < dis[u]) {\n                        dis[u] = dis[v] + w;\n                        heappush(unused, [dis[u], u]);\n                    }\n                }\n            }\n\n            return dis;\n        }\n\n        const adj = new Array(n+1).fill().map(_ => []);\n        const curved = [];\n\n        for (let i = 0; i < m; i++) {\n            const u = edges[i][0];\n            const v = edges[i][1];\n            const w = edges[i][2];\n            const cw = edges[i][3];\n\n            adj[u].push([v,w]);\n            adj[v].push([u,w]);\n\n            curved.push([u, v, cw]);\n        }\n\n        const da = dijkstra(a,b,n,adj);\n        const db = dijkstra(b,a,n,adj);\n\n        let ans = da[b];\n\n        for (let i = 0; i < m; i++) {\n            const u = curved[i][0];\n            const v = curved[i][1];\n            const cw = curved[i][2];\n\n            ans = Math.min(ans, da[u] + cw + db[v]);\n            ans = Math.min(ans, da[v] + cw + db[u]);\n        }\n\n        if (ans >= 1000000001) {\n            return -1;\n        }\n        \n        return ans;\n    }\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}