{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 706078,
            "title": "Shortest Range In BST",
            "titleSlug": "shortest-range-in-bst--141631",
            "content": "<p><span style=\"font-size:18px\">Given a BST (Binary Search Tree), find the shortest range <strong>[x, y]</strong>, such that,&nbsp;at least one node of every level of the&nbsp;BST lies in the&nbsp;range.<br />\r\nIf there are multiple ranges with the same gap (i.e. <strong>(y-x)</strong>) return the range with<strong> </strong>the<strong> smallest x</strong>.</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Example 1:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong>\r\n    </span>&nbsp;\\t  <span style=\"font-size:18px\"> 8\r\n&nbsp; &nbsp; &nbsp; &nbsp;   /&nbsp; &nbsp;\\\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3&nbsp; &nbsp;  10\r\n&nbsp; &nbsp;    /&nbsp; \\&nbsp; &nbsp; &nbsp; \\\r\n&nbsp; &nbsp; &nbsp; 2&nbsp; &nbsp; 6&nbsp; &nbsp; &nbsp; 14\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp;\\&nbsp; &nbsp; &nbsp;/\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4&nbsp;  7&nbsp; &nbsp;12\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp; \\\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11&nbsp;  13\r\n<strong>Output:</strong> 6 11\r\n<strong>Explanation:</strong> Level order traversal of the tree \r\nis [8], [3, 10], [2, 6, 14], [4, 7, 12], [11, 13]. \r\nThe shortest range which satisfies the above \r\nmentioned condition is [6, 11]. </span></pre>\r\n\r\n<p><br />\r\n<span style=\"font-size:18px\"><strong>Example 2:</strong></span></p>\r\n\r\n<pre>\r\n<span style=\"font-size:18px\"><strong>Input:</strong>\r\n   12\r\n&nbsp; &nbsp; \\\r\n&nbsp; &nbsp; &nbsp;13\r\n&nbsp; &nbsp; &nbsp; &nbsp;\\\r\n&nbsp; &nbsp; &nbsp; &nbsp; 14\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\\\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 15\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \\\r\n&nbsp; &nbsp; &nbsp; &nbsp;    16\r\n\r\n<strong>Output:</strong> 12 16\r\n<strong>Explanation:</strong> Each level contains one node, \r\nso the shortest range is [12, 16].</span></pre>\r\n\r\n<p><br />\r\n<span style=\"font-size:18px\"><strong>Your Task:</strong><br />\r\nYou don&#39;t need to read input or print anything. Complete the function <strong>shortestRange() </strong>which takes the root of the tree as an input parameter and returns the pair of numbers</span></p>\r\n\r\n<p><span style=\"font-size:18px\"><strong>Expected Time Complexity:</strong> O(N)<br />\r\n<strong>Expected Auxiliary Space:</strong> O(N)</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-size:18px\"><strong>Constraints:</strong><br />\r\n1 &le; N&nbsp;&le; 10<sup>5</sup><br />\r\n1 &le; Node Value &le; 10<sup>5</sup></span></p>\r\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given a Binary Search Tree (BST), find the shortest range [x, y] such that at least one node from every level of the BST falls within the range. If multiple ranges have the same length (y-x), return the range with the smallest x.",
                "constraints": [
                    "1 <= N <= 10^5",
                    "1 <= Node Value <= 10^5"
                ],
                "testcases": [
                    {
                        "input": "BST: 8 / \\ 3 10 / \\ \\ 2 6 14 / \\ / 4 7 12 / \\ 11 13",
                        "output": "6 11",
                        "explanation": "Level order traversal of the tree is [8], [3, 10], [2, 6, 14], [4, 7, 12], [11, 13]. The shortest range which contains at least one node from each level is [6, 11]."
                    },
                    {
                        "input": "BST: 12 \\ 13 \\ 14 \\ 15 \\ 16",
                        "output": "12 16",
                        "explanation": "Each level contains only one node, so the shortest range encompassing all levels is [12, 16]."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Use two pointer technique in inorder traversal of the tree. Set left pointer at first index and right pointer at root&#39;s index in inorder traversal of the bst. Then check if the current range contains all levels if yes the shift left pointer 1 index right, otherwise increase the right pointer by 1. Continue this process till left pointer reaches the root&#39;s index or right pointer reaches last index.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "two-pointer-algorithm",
                "slug": "two-pointer-algorithm"
            },
            {
                "name": "Binary Search Tree",
                "slug": "binary-search-tree"
            },
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "// Back-end complete function Template for C++\r\n\r\n/*\r\n    root: current node\r\n    depth: depth of current node\r\n    inOrder: inorder traversal of tree\r\n    level: stores levels of the nodes\r\n*/\r\n\r\nclass Solution{\r\n    \r\n    private:\r\n    void storeInOrder(Node *root, int depth, vector<int> &inOrder,\r\n                  vector<int> &level) {\r\n        if (!root) return;\r\n        // recur for left subtree\r\n        storeInOrder(root->left, depth + 1, inOrder, level);\r\n        // store inorder\r\n        inOrder.push_back(root->data);\r\n        // store depth of that node\r\n        level.push_back(depth);\r\n        // recur for right subtree\r\n        storeInOrder(root->right, depth + 1, inOrder, level);\r\n    }\r\n    \r\n    public:\r\n    pair<int, int> shortestRange(Node *root) {\r\n        // inOrder: stores inorder traversal of the bst\r\n        // level: stores level of ith node in inorder traversal\r\n        vector<int> inOrder, level;\r\n        storeInOrder(root, 0, inOrder, level);\r\n        //        for (int u: inOrder) {\r\n        //            cout << u << \" \";\r\n        //        }\r\n        //        cout << \"\\n\";\r\n        //        for (int u: level) {\r\n        //            cout << u << \" \";\r\n        //        }\r\n        //        cout << \"\\n\";\r\n        /*\r\n            cntZero: counts number of zeros\r\n            i: left pointer (initially at 0)\r\n            j: right pointer\r\n            k: index of root in inorder traversal\r\n            maxDepth: maximum depth of bst\r\n            Note: these pointers are on the inorder traversal of the tree\r\n        */\r\n        int i = 0, j = 0, k = 0, cntZero = 0,\r\n            maxDepth = *max_element(level.begin(), level.end()) + 1;\r\n        // stores number of nodes at ith level\r\n        vector<int> depth(maxDepth, 0);\r\n        // first count number of nodes at ith level till the root\r\n        // right pointer initially is at root's index in inorder traversal of bst\r\n        for (k = 0; k < level.size(); k++) {\r\n            depth[level[k]]++;\r\n            if (level[k] == 0) {\r\n                j = k;\r\n                break;\r\n            }\r\n        }\r\n        // count number of levels where there are 0 nodes in the range inorder[i] to\r\n        // inorder[j]\r\n        for (int u : depth) {\r\n            if (u == 0) {\r\n                cntZero++;\r\n            }\r\n        }\r\n        // intially shortest range is [x, y]\r\n        // x=node at 0th index\r\n        // y=node at last index\r\n        // i.e. the whole tree\r\n        int x = *inOrder.begin(), y = inOrder.back();\r\n        // if currently picked range contains all levels change x and y accordingly\r\n        if (cntZero == 0) {\r\n            x = inOrder[i], y = inOrder[j];\r\n        }\r\n        // left pointer can at most go upto root's index(i.e. k)\r\n        // right pointer can go upto last index of inorder traversal of tree\r\n        while (i <= k && j < inOrder.size()) {\r\n            // while right pointer doesn't reach last index\r\n            // and the current range doesn't contain all levels\r\n            while (j < inOrder.size()) {\r\n                // if cntZero is 0 then this range contains all levels\r\n                if (cntZero == 0) {\r\n                    // if previous range is large then change the range\r\n                    if ((y - x) > (inOrder[j] - inOrder[i])) {\r\n                        x = inOrder[i];\r\n                        y = inOrder[j];\r\n                    }\r\n                    break;\r\n                }\r\n                // increase right pointer\r\n                j++;\r\n                if (j >= inOrder.size()) {\r\n                    break;\r\n                }\r\n                // if new level is discovered by this range then cntZero is\r\n                // decreased by 1\r\n                if (depth[level[j]] == 0) {\r\n                    cntZero--;\r\n                }\r\n                // increase count of nodes at that level\r\n                depth[level[j]]++;\r\n            }\r\n            // while current range contains all levels\r\n            // we can shift the left pointer by +1\r\n            while (!cntZero && i <= k) {\r\n                // if previous range is large then change the range\r\n                if ((y - x) > (inOrder[j] - inOrder[i])) {\r\n                    x = inOrder[i];\r\n                    y = inOrder[j];\r\n                }\r\n                // decrease count of nodes at that level\r\n                depth[level[i]]--;\r\n                // if this level is outside the current range then cntZero is\r\n                // increased by 1\r\n                if (depth[level[i]] == 0) {\r\n                    cntZero++;\r\n                }\r\n                // shift left pointer\r\n                i++;\r\n            }\r\n        }\r\n        // return the shortest range\r\n        return {x, y};\r\n    }\r\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\r\n    public Range shortestRange(Node root) {\r\n        // inOrder: stores inorder traversal of the bst\r\n        // level: stores level of ith node in inorder traversal\r\n        ArrayList<Integer> inOrder = new ArrayList<Integer>();\r\n        ArrayList<Integer> level = new ArrayList<Integer>();\r\n        storeInOrder(root, 0, inOrder, level);\r\n        /*\r\n            cntZero: counts number of zeros\r\n            i: left pointer (initially at 0)\r\n            j: right pointer\r\n            k: index of root in inorder traversal\r\n            maxDepth: maximum depth of bst\r\n            Note: these pointers are on the inorder traversal of the tree\r\n        */\r\n        int i = 0, j = 0, k = 0, cntZero = 0,\r\n            maxDepth = Collections.max(level) + 1;\r\n        // stores number of nodes at ith level\r\n        int[] depth = new int[maxDepth];\r\n        // first count number of nodes at ith level till the root\r\n        // right pointer initially is at root's index in inorder traversal of\r\n        // bst\r\n        for (k = 0; k < level.size(); k++) {\r\n            depth[level.get(k)]++;\r\n            if (level.get(k) == 0) {\r\n                j = k;\r\n                break;\r\n            }\r\n        }\r\n        // count number of levels where there are 0 nodes in the range\r\n        // inorder[i] to inorder[j]\r\n        for (int u : depth) {\r\n            if (u == 0) {\r\n                cntZero++;\r\n            }\r\n        }\r\n        // intially shortest range is [x, y]\r\n        // x=node at 0th index\r\n        // y=node at last index\r\n        // i.e. the whole tree\r\n        int x = inOrder.get(0), y = inOrder.get(inOrder.size() - 1);\r\n        // if currently picked range contains all levels change x and y\r\n        // accordingly\r\n        if (cntZero == 0) {\r\n            x = inOrder.get(i);\r\n            y = inOrder.get(j);\r\n        }\r\n        // left pointer can at most go upto root's index(i.e. k)\r\n        // right pointer can go upto last index of inorder traversal of tree\r\n        while (i <= k && j < inOrder.size()) {\r\n            // while right pointer doesn't reach last index\r\n            // and the current range doesn't contain all levels\r\n            while (j < inOrder.size()) {\r\n                // if cntZero is 0 then this range contains all levels\r\n                if (cntZero == 0) {\r\n                    // if previous range is large then change the range\r\n                    if ((y - x) > (inOrder.get(j) - inOrder.get(i))) {\r\n                        x = inOrder.get(i);\r\n                        y = inOrder.get(j);\r\n                    }\r\n                    break;\r\n                }\r\n                j++;\r\n                if (j >= inOrder.size()) {\r\n                    break;\r\n                }\r\n                // if new level is discovered by this range then cntZero is\r\n                // decreased by 1\r\n                if (depth[level.get(j)] == 0) {\r\n                    cntZero--;\r\n                }\r\n                depth[level.get(j)]++;\r\n            }\r\n            // while current range contains all levels\r\n            // we can shift the left pointer by +1\r\n            while (cntZero == 0 && i <= k) {\r\n                if ((y - x) > (inOrder.get(j) - inOrder.get(i))) {\r\n                    x = inOrder.get(i);\r\n                    y = inOrder.get(j);\r\n                }\r\n                depth[level.get(i)]--;\r\n                // if this level is outside the current range then cntZero is\r\n                // increased by 1\r\n                if (depth[level.get(i)] == 0) {\r\n                    cntZero++;\r\n                }\r\n                i++;\r\n            }\r\n        }\r\n        return new Range(x, y);\r\n    }\r\n\r\n    /*\r\n        root: current node\r\n        depth: depth of current node\r\n        inOrder: inorder traversal of tree\r\n        level: stores levels of the nodes\r\n    */\r\n    public void storeInOrder(Node root, int depth, ArrayList<Integer> inOrder,\r\n                      ArrayList<Integer> level) {\r\n        if (root == null) return;\r\n        // recur for left subtree\r\n        storeInOrder(root.left, depth + 1, inOrder, level);\r\n        // store inorder\r\n        inOrder.add(root.data);\r\n        // store depth of that node\r\n        level.add(depth);\r\n        storeInOrder(root.right, depth + 1, inOrder, level);\r\n    }\r\n}",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "'''\r\n    root: current node\r\n    lvl: depth of current node\r\n    lin: inorder traversal of tree\r\n    llv: stores levels of the nodes\r\n'''\r\n\r\nfrom collections import defaultdict\r\nclass Solution:\r\n\r\n    #Function to find the shortest range in a binary tree.\r\n    def shortestRange(self, root):\r\n        global nums\r\n        nums = []\r\n\r\n        #Function to perform level order traversal of the tree.\r\n        def getLevelOrder(root):\r\n            global nums\r\n            q = [root]\r\n            while q:\r\n                c = len(q)\r\n                nums.append([node.data for node in q])\r\n                while c:\r\n                    node = q.pop(0)\r\n                    if node.left:\r\n                        q.append(node.left)\r\n                    if node.right:\r\n                        q.append(node.right)\r\n                    c -= 1\r\n\r\n        #Calling the function to perform level order traversal.\r\n        getLevelOrder(root)\r\n\r\n        n = len(nums)\r\n        m = []\r\n        for k in range(n):\r\n            for num in nums[k]:\r\n                m.append((num, k))\r\n        m = sorted(m)\r\n        d = 0\r\n        left, right = 0, 0\r\n        freq = defaultdict(lambda: 0)\r\n        mn = float('inf')\r\n        a, b = None, None\r\n\r\n        #Sliding window approach to find the shortest range.\r\n        while right < len(m):\r\n            if freq[m[right][1]] == 0:\r\n                d += 1\r\n            freq[m[right][1]] += 1\r\n            if d == n:\r\n                break\r\n            right += 1\r\n        if (m[right][0] - m[left][0]) < mn:\r\n            a, b = m[left][0], m[right][0]\r\n            mn = (m[right][0] - m[left][0])\r\n        while right < len(m):\r\n            while left < right:\r\n                if freq[m[left][1]] > 1:\r\n                    freq[m[left][1]] -= 1\r\n                    left += 1\r\n                    if (m[right][0] - m[left][0]) < mn:\r\n                        a, b = m[left][0], m[right][0]\r\n                        mn = (m[right][0] - m[left][0])\r\n                else:\r\n                    break\r\n            freq[m[left][1]] -= 1\r\n            left += 1\r\n            right += 1\r\n            d -= 1\r\n            while right < len(m):\r\n                if freq[m[right][1]] == 0:\r\n                    d += 1\r\n                freq[m[right][1]] += 1\r\n                if d == n:\r\n                    break\r\n                right += 1\r\n            if d == n and (m[right][0] - m[left][0]) < mn:\r\n                a, b = m[left][0], m[right][0]\r\n                mn = (m[right][0] - m[left][0])\r\n        return [a, b]",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "//User function Template for javascript\n/**\n * @param {TreeNode} root\n * @returns {number[]}\n*/\n\nclass Solution {\n    //Function to find the shortest range in a binary tree.\n    shortestRange(root) {\n        const nums = [];\n\n        //Function to perform level order traversal of the tree.\n        const getLevelOrder = (root) => {\n            const q = [root];\n            while (q.length !== 0) {\n                const c = q.length;\n                const level = [];\n                for (let i = 0; i < c; i++) {\n                    const node = q.shift();\n                    level.push(node.data);\n                    if (node.left) {\n                        q.push(node.left);\n                    }\n                    if (node.right) {\n                        q.push(node.right);\n                    }\n                }\n                nums.push(level);\n            }\n        }\n\n        //Calling the function to perform level order traversal.\n        getLevelOrder(root);\n\n        const n = nums.length;\n        const m = [];\n        for (let k = 0; k < n; k++) {\n            const level = nums[k];\n            for (const num of level) {\n                m.push([num, k]);\n            }\n        }\n        m.sort((a, b) => a[0] - b[0]);\n        let d = 0;\n        let left = 0;\n        let right = 0;\n        const freq = {};\n        let mn = Infinity;\n        let a, b;\n\n        //Sliding window approach to find the shortest range.\n        while (right < m.length) {\n            if (!freq[m[right][1]]) {\n                d++;\n            }\n            freq[m[right][1]] = (freq[m[right][1]] || 0) + 1;\n            if (d === n) {\n                break;\n            }\n            right++;\n        }\n        if (m[right][0] - m[left][0] < mn) {\n            a = m[left][0];\n            b = m[right][0];\n            mn = m[right][0] - m[left][0];\n        }\n        while (right < m.length) {\n            while (left < right) {\n                if (freq[m[left][1]] > 1) {\n                    freq[m[left][1]]--;\n                    left++;\n                    if (m[right][0] - m[left][0] < mn) {\n                        a = m[left][0];\n                        b = m[right][0];\n                        mn = m[right][0] - m[left][0];\n                    }\n                } else {\n                    break;\n                }\n            }\n            freq[m[left][1]]--;\n            left++;\n            right++;\n            d--;\n            while (right < m.length) {\n                if (!freq[m[right][1]]) {\n                    d++;\n                }\n                freq[m[right][1]] = (freq[m[right][1]] || 0) + 1;\n                if (d === n) {\n                    break;\n                }\n                right++;\n            }\n            if (d === n && m[right][0] - m[left][0] < mn) {\n                a = m[left][0];\n                b = m[right][0];\n                mn = m[right][0] - m[left][0];\n            }\n        }\n        return [a, b];\n    }\n}",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}