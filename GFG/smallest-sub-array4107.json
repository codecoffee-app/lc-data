{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 703326,
            "title": "Smallest Subarray GCD",
            "titleSlug": "smallest-sub-array4107",
            "content": "<p><span >Givenn an array <strong>arr[] </strong>and<strong> </strong><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">an integer&nbsp;</span><strong style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">k </strong><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">, find the length of the minimum subarray whose Greatest Common Divisor equals </span><strong style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">k</strong><span style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\">.</span></span></p>\n<p><span ><strong>Note:</strong> If no such subarray exists, return -1.</span></p>\n<p><span ><strong>Examples:</strong></span></p>\n<pre><span ><strong>Input: </strong>arr[] = [6, 9, 7, 10, 12, 24, 36, 27], k = 3\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> GCD of subarray {6,9} is 3. GCD of subarray {24, 36, 27} is also 3,but {6, 9} is the smallest.</span></pre>\n<pre><span ><strong>Input: </strong>arr[] = [9, 12, 15, 24, 36, 27], k = 2\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> GCD 2 is not possible from any subarray from the given array.</span></pre>\n<pre><span ><strong>Input: </strong>arr[] = [1, 2, 4, 8], k = 1\n<strong>Output:</strong> 1</span></pre>\n<p><span ><strong>Expected Time Complexity:</strong> O(n * (logn)<sup>2</sup>)<br /><strong>Expected Auxiliary Space:</strong> O(n * logn)&nbsp;</span></p>\n<p><span ><strong>Constraints:</strong><br />1 &lt;= arr.size() &lt;= 10<sup>5</sup><br />1 &lt;= arr[i] &lt;= 10<sup>5</sup><br />1 &lt;= k &lt;= 100</span></p>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Given an array `arr[]` and an integer `k`, find the length of the smallest subarray whose Greatest Common Divisor (GCD) is equal to `k`. If no such subarray exists, return -1.",
                "constraints": [
                    "1 <= arr.size() <= 10^5",
                    "1 <= arr[i] <= 10^5",
                    "1 <= k <= 100"
                ],
                "testcases": [
                    {
                        "input": "[6, 9, 7, 10, 12, 24, 36, 27], k = 3",
                        "output": "2",
                        "explanation": "The subarray {6, 9} has a GCD of 3, and it's the shortest subarray with that GCD. While {24, 36, 27} also has a GCD of 3, it's longer than {6,9}."
                    },
                    {
                        "input": "[9, 12, 15, 24, 36, 27], k = 2",
                        "output": "-1",
                        "explanation": "No subarray within the given array has a GCD of 2."
                    },
                    {
                        "input": "[1, 2, 4, 8], k = 1",
                        "output": "1",
                        "explanation": "The element 1 itself has a GCD of 1. Therefore, a subarray of length 1 is the minimum possible."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p><span >Use a segment tree to efficiently compute the GCD of subarrays and find the smallest subarray with a GCD equal to&nbsp;k by binary searching for valid subarray lengths.</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Arrays",
                "slug": "arrays"
            },
            {
                "name": "Segment-Tree",
                "slug": "segment-tree"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Advanced Data Structure",
                "slug": "advanced-data-structure"
            }
        ],
        "companies": [],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "\n\nclass Solution {\n  public:\n    // Function to recursively construct the segment tree and calculate gcd\n    int constructSegment(vector<int>& arr, int Seg_start, int Seg_end, vector<int>& ST,\n                         int pos) {\n        if (Seg_start == Seg_end) {\n            ST[pos] = arr[Seg_start];\n            return ST[pos];\n        }\n        int mid = (Seg_start + Seg_end) / 2;\n        ST[pos] = gcd(constructSegment(arr, Seg_start, mid, ST, 2 * pos + 1),\n                      constructSegment(arr, mid + 1, Seg_end, ST, 2 * pos + 2));\n        return ST[pos];\n    }\n\n    // Function to construct segment tree and return ST array\n    vector<int> constructST(vector<int>& arr) {\n        int n = arr.size();\n        int height = (int)ceil(log2(n));\n        int size = 2 * (int)pow(2, height) - 1;\n        vector<int> ST(size);\n        constructSegment(arr, 0, n - 1, ST, 0);\n        return ST;\n    }\n\n    // Function to query gcd of a subarray in segment tree\n    int queryGCD(vector<int>& ST, int Seg_start, int Seg_end, int gcd_start,\n                 int gcd_end, int pos) {\n        if (Seg_start > gcd_end || Seg_end < gcd_start) {\n            return 0; // Return 0 for invalid ranges (neutral for gcd)\n        }\n        if (Seg_start >= gcd_start && Seg_end <= gcd_end) {\n            return ST[pos];\n        }\n        int mid = (Seg_start + Seg_end) / 2;\n        return gcd(queryGCD(ST, Seg_start, mid, gcd_start, gcd_end, 2 * pos + 1),\n                   queryGCD(ST, mid + 1, Seg_end, gcd_start, gcd_end, 2 * pos + 2));\n    }\n\n    // Function to search for the end index of a subarray with common gcd\n    int endSearch(vector<int>& arr, vector<int>& ST, int i, int n, int g) {\n        int start = i;\n        int end = n - 1;\n        int ans = -1;\n        while (start <= end) {\n            int mid = (start + end) / 2;\n            int gcd_value = queryGCD(ST, 0, n - 1, i, mid, 0);\n            if (gcd_value == g) {\n                ans = mid;\n                end = mid - 1; // try to find a smaller valid subarray\n            } else if (gcd_value % g == 0) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return ans;\n    }\n\n    // Function to find the length of the smallest subarray with common gcd k\n    int findSmallestSubArr(vector<int>& arr, int k) {\n        int n = arr.size();\n        vector<int> ST = constructST(arr);\n        int length = -1;\n\n        // Check if any element in the original array is equal to k, return length 1\n        for (int i = 0; i < n; i++) {\n            if (arr[i] == k) {\n                return 1;\n            }\n        }\n\n        // Search for all possible subarrays with gcd k and update length if smaller\n        // length is found\n        for (int i = 0; i < n; i++) {\n            int x = endSearch(arr, ST, i, n, k);\n            if (x != -1) {\n                if (length == -1) {\n                    length = x - i + 1;\n                } else {\n                    length = min(length, x - i + 1);\n                }\n            }\n        }\n\n        // Return the length of the smallest subarray with common gcd k\n        return length;\n    }\n\n    // GCD function\n    int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n};",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "// User function Template for Java\n\nclass Solution {\n    // Function to find the length of the smallest subarray with gcd k\n    int findSmallestSubArr(int[] arr, int k) {\n        int n = arr.length;\n        // Step 1: Build the segment tree\n        int[] st = constructST(arr);\n\n        int length = -1;\n\n        // Step 2: Check if any element in the original array is equal to k\n        for (int i = 0; i < n; i++) {\n            if (arr[i] == k) {\n                return 1;\n            }\n        }\n\n        // Step 3: Search for all possible subarrays with gcd k and update length if\n        // smaller is found\n        for (int i = 0; i < n; i++) {\n            int end = endSearch(arr, st, i, n, k);\n            if (end != -1) {\n                if (length == -1) {\n                    length = end - i + 1;\n                } else {\n                    length = Math.min(length, end - i + 1);\n                }\n            }\n        }\n\n        return length;\n    }\n\n    // Function to construct the segment tree and return the array\n    int[] constructST(int[] arr) {\n        int n = arr.length;\n        int height = (int)Math.ceil(Math.log(n) / Math.log(2));\n        int size = 2 * (int)Math.pow(2, height) - 1;\n        int[] st = new int[size];\n        constructSegment(arr, 0, n - 1, st, 0);\n        return st;\n    }\n\n    // Recursive function to construct the segment tree\n    int constructSegment(int[] arr, int segStart, int segEnd, int[] st, int pos) {\n        if (segStart == segEnd) {\n            st[pos] = arr[segStart];\n            return st[pos];\n        }\n\n        int mid = (segStart + segEnd) / 2;\n        st[pos] = gcd(constructSegment(arr, segStart, mid, st, 2 * pos + 1),\n                      constructSegment(arr, mid + 1, segEnd, st, 2 * pos + 2));\n        return st[pos];\n    }\n\n    // Function to perform binary search for the smallest subarray with gcd k\n    int endSearch(int[] arr, int[] st, int i, int n, int k) {\n        int start = i;\n        int end = n - 1;\n        int mid, ans = -1;\n\n        while (start <= end) {\n            mid = (start + end) / 2;\n            int gcdValue = queryGCD(st, 0, n - 1, i, mid, 0);\n            if (gcdValue == k) {\n                ans = mid;\n                end = mid - 1;\n            } else if (gcdValue % k == 0) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n\n        return ans;\n    }\n\n    // Function to query gcd in the segment tree\n    int queryGCD(int[] st, int segStart, int segEnd, int queryStart, int queryEnd,\n                 int pos) {\n        if (segStart > queryEnd || segEnd < queryStart) {\n            return 0; // Neutral value for gcd\n        }\n        if (segStart >= queryStart && segEnd <= queryEnd) {\n            return st[pos];\n        }\n\n        int mid = (segStart + segEnd) / 2;\n        return gcd(queryGCD(st, segStart, mid, queryStart, queryEnd, 2 * pos + 1),\n                   queryGCD(st, mid + 1, segEnd, queryStart, queryEnd, 2 * pos + 2));\n    }\n\n    // Function to calculate gcd of two numbers\n    int gcd(int a, int b) {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python3",
                "full_func": "# User function Template for python3\n\n\nclass Solution:\n\n    def findSmallestSubArr(self, arr, k):\n        n = len(arr)\n        # Step 1: Build the segment tree\n        st = self.constructST(arr)\n\n        length = sys.maxsize\n\n        # Step 2: Check if any element in the original array is equal to k\n        for i in range(n):\n            if arr[i] == k:\n                return 1\n\n        # Step 3: Search for all possible subarrays with gcd k and update length if smaller is found\n        for i in range(n):\n            end = self.endSearch(arr, st, i, n, k)\n            if end != -1:\n                length = min(length, end - i + 1)\n\n        # If length remains sys.maxsize, return -1, otherwise return the smallest length found\n        return length if length != sys.maxsize else -1\n\n    # Function to construct the segment tree\n    def constructST(self, arr):\n        n = len(arr)\n        height = math.ceil(math.log2(n))\n        size = 2 * (2**height) - 1\n        st = [0] * size\n        self.constructSegment(arr, 0, n - 1, st, 0)\n        return st\n\n    # Recursive function to construct the segment tree\n    def constructSegment(self, arr, seg_start, seg_end, st, pos):\n        if seg_start == seg_end:\n            st[pos] = arr[seg_start]\n            return st[pos]\n\n        mid = (seg_start + seg_end) // 2\n        st[pos] = gcd(\n            self.constructSegment(arr, seg_start, mid, st, 2 * pos + 1),\n            self.constructSegment(arr, mid + 1, seg_end, st, 2 * pos + 2))\n        return st[pos]\n\n    # Function to perform binary search for the smallest subarray with gcd k\n    def endSearch(self, arr, st, i, n, k):\n        start, end = i, n - 1\n        ans = -1\n\n        while start <= end:\n            mid = (start + end) // 2\n            gcd_value = self.queryGCD(st, 0, n - 1, i, mid, 0)\n            if gcd_value == k:\n                ans = mid\n                end = mid - 1\n            elif gcd_value % k == 0:\n                start = mid + 1\n            else:\n                end = mid - 1\n\n        return ans\n\n    # Function to query gcd in the segment tree\n    def queryGCD(self, st, seg_start, seg_end, query_start, query_end, pos):\n        if seg_start > query_end or seg_end < query_start:\n            return 0  # Neutral value for gcd\n        if seg_start >= query_start and seg_end <= query_end:\n            return st[pos]\n\n        mid = (seg_start + seg_end) // 2\n        return gcd(\n            self.queryGCD(st, seg_start, mid, query_start, query_end,\n                          2 * pos + 1),\n            self.queryGCD(st, mid + 1, seg_end, query_start, query_end,\n                          2 * pos + 2))\n",
                "lang_text": "py"
            },
            "javascript": {
                "lang": "Javascript",
                "full_func": "class Solution {\n    // Function to find the length of the smallest subarray with gcd k\n    findSmallestSubArr(arr, k) {\n        const n = arr.length;\n        const st = this.constructST(arr);\n\n        let length = Number.MAX_SAFE_INTEGER;\n\n        // Check if any element in the original array is equal to k\n        for (let i = 0; i < n; i++) {\n            if (arr[i] === k) return 1;\n        }\n\n        // Search for all possible subarrays with gcd k and update length if smaller\n        // length is found\n        for (let i = 0; i < n; i++) {\n            const end = this.endSearch(arr, st, i, n, k);\n            if (end !== -1) {\n                length = Math.min(length, end - i + 1);\n            }\n        }\n\n        // Return the smallest length found or -1 if no such subarray exists\n        return length === Number.MAX_SAFE_INTEGER ? -1 : length;\n    }\n\n    // Function to construct the segment tree\n    constructST(arr) {\n        const n = arr.length;\n        const height = Math.ceil(Math.log2(n));\n        const size = 2 * Math.pow(2, height) - 1;\n        const st = new Array(size).fill(0);\n        this.constructSegment(arr, 0, n - 1, st, 0);\n        return st;\n    }\n\n    // Recursive function to construct the segment tree\n    constructSegment(arr, segStart, segEnd, st, pos) {\n        if (segStart === segEnd) {\n            st[pos] = arr[segStart];\n            return st[pos];\n        }\n\n        const mid = Math.floor((segStart + segEnd) / 2);\n        st[pos] =\n            this.gcd(this.constructSegment(arr, segStart, mid, st, 2 * pos + 1),\n                     this.constructSegment(arr, mid + 1, segEnd, st, 2 * pos + 2));\n        return st[pos];\n    }\n\n    // Function to perform binary search for the smallest subarray with gcd k\n    endSearch(arr, st, i, n, k) {\n        let start = i;\n        let end = n - 1;\n        let ans = -1;\n\n        while (start <= end) {\n            const mid = Math.floor((start + end) / 2);\n            const gcdValue = this.queryGCD(st, 0, n - 1, i, mid, 0);\n            if (gcdValue === k) {\n                ans = mid;\n                end = mid - 1;\n            } else if (gcdValue % k === 0) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n\n        return ans;\n    }\n\n    // Function to query gcd in the segment tree\n    queryGCD(st, segStart, segEnd, queryStart, queryEnd, pos) {\n        if (segStart > queryEnd || segEnd < queryStart) {\n            return 0; // Neutral value for gcd\n        }\n        if (segStart >= queryStart && segEnd <= queryEnd) {\n            return st[pos];\n        }\n\n        const mid = Math.floor((segStart + segEnd) / 2);\n        return this.gcd(\n            this.queryGCD(st, segStart, mid, queryStart, queryEnd, 2 * pos + 1),\n            this.queryGCD(st, mid + 1, segEnd, queryStart, queryEnd, 2 * pos + 2));\n    }\n\n    // Function to compute gcd of two numbers\n    gcd(a, b) {\n        while (b) {\n            [a, b] = [ b, a % b ];\n        }\n        return a;\n    }\n}\n",
                "lang_text": "javascript"
            }
        },
        "platform": "GFG"
    }
}