{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 706254,
            "title": "Open the gates",
            "titleSlug": "word-boggle-ii--141631",
            "content": "<p><span >Geek and his friends went on a trip to one of the hill stations in Geekland. While trekking they found a treasure map, it was in the form of <strong>r x c</strong> size board, each cell on the <strong>map</strong> denotes a latin uppercase letter. On the bottom of the map it was written that there are <strong>n gates</strong> with a specific name and if they could find out the name of the gate on the map that gate would open. Help Geek and his friends to find out the gates they could possibly open with the map they found.&nbsp;</span></p>\n<p><span >A name can be formed by a sequence of adjacent characters on the map. We can move to any of 8 adjacent characters. While forming a word we can move to any of the 8 adjacent cells. A cell can be used only once in one name.</span></p>\n<p><span >&nbsp;<strong>NOTE</strong>: All gate names returned must be different even it occurs multiple times in the input.</span></p>\n<p><span ><strong>Example 1:</strong></span></p>\n<pre><span ><strong>Input: \n</strong>n = 3\ngate_names = {\"ZARA\", \"ZETH\", \"MYTH\"}\nr = 3, c = 3\nmap = A Z E<br />\\t R Y T<br />\\t M A H\n<strong>Output:</strong>\n{\"ZARA\", \"ZETH\", \"MYTH\"}\n<strong>Explanation</strong>: <br /><span style=\"color: #e03e2d;\"><span style=\"color: #000000;\">Opening gate ZARA</span><br />A</span> <span style=\"color: #e03e2d;\">Z</span> E<br /><span style=\"color: #e03e2d;\">R</span> Y T<br />M <span style=\"color: #e03e2d;\">A</span> H<br />Opening gate ZETH<br />A <span style=\"color: #3598db;\">Z</span> <span style=\"color: #3598db;\">E</span><br />R Y <span style=\"color: #3598db;\">T</span><br />M A <span style=\"color: #3598db;\">H</span><br />Opening gate MYTH<br />A Z E<br />R <span style=\"color: #2dc26b;\">Y</span> <span style=\"color: #2dc26b;\">T</span><br /><span style=\"color: #2dc26b;\">M</span> A <span style=\"color: #2dc26b;\">H</span>\n</span></pre>\n<p><span ><strong>Example 2:</strong></span></p>\n<pre><span ><strong>Input:</strong>\nn = 5\ngate_names = {\"NYX\",\"ONYX\",\"VIRA\",\"KARA\", \"NYX\"}\nr = 3, c = 3 \nmap = N O A<br />\\t P Y V<br />\\t K R X\n<strong>Output:</strong>\n{\"NYX\", \"ONYX\"}\n<strong>Explanation</strong>: <br /><span style=\"color: #000000;\">Opening gate NYX<br /><span style=\"color: #e03e2d;\">N</span> O A<br />P <span style=\"color: #e03e2d;\">Y</span> V<br />K R <span style=\"color: #e03e2d;\">X</span><br />Opening gate ONYX<br /><span style=\"color: #3598db;\">N</span> <span style=\"color: #3598db;\">O</span> A<br />P <span style=\"color: #3598db;\">Y</span> V<br />K R <span style=\"color: #3598db;\">X<br /><strong><span style=\"color: #000000;\">Note that NYX is counted only once.</span></strong></span></span></span></pre>\n<p><span ><strong>Your task:</strong><br />You don&rsquo;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>openGates()</strong> which takes the <strong>gate_names</strong> contaning <strong>n</strong> space-separated strings and <strong>r*c map</strong> as input parameters and returns a list of gate names that can be opened</span></p>\n<p><span ><strong>Expected Time Complexity: </strong>O(4^(N^2))<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N^2)</span></p>\n<div><span ><strong>Constraints:</strong><br />1 &le; n &le; 15<br />1 &le; r, c &le; 50<br />1 &le; length of each gate name &le; 60</span></div>\n<div><span >All words of gate_names and all characters of map are uppercase letters from <strong>'A'</strong> to <strong>'Z'</strong></span></div>",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": "NA",
            "dislikes": "NA",
            "rephrased": {
                "body": "Geek and his friends discovered a treasure map while trekking in Geekland. The map is a grid of size r x c, with each cell containing an uppercase letter. The map indicates 'n' gates, each with a specific name. The goal is to determine which gates can be opened by finding their names within the map. A gate name can be formed by traversing adjacent characters (8-directional) on the map. Each cell can be used only once per gate name search. Identify the distinct gate names present within the map.",
                "constraints": [
                    "1 <= n <= 15",
                    "1 <= r, c <= 50",
                    "1 <= length of each gate name <= 60",
                    "All words of gate_names and all characters of map are uppercase letters from 'A' to 'Z'"
                ],
                "testcases": [
                    {
                        "input": "n = 3\ngate_names = {\"ZARA\", \"ZETH\", \"MYTH\"}\nr = 3, c = 3\nmap = A Z E\n\t R Y T\n\t M A H",
                        "output": "{\"ZARA\", \"ZETH\", \"MYTH\"}",
                        "explanation": "ZARA, ZETH, and MYTH can all be found on the map by traversing adjacent cells.  The provided example shows how each name is formed."
                    },
                    {
                        "input": "n = 5\ngate_names = {\"NYX\",\"ONYX\",\"VIRA\",\"KARA\", \"NYX\"}\nr = 3, c = 3 \nmap = N O A\n\t P Y V\n\t K R X",
                        "output": "{\"NYX\", \"ONYX\"}",
                        "explanation": "NYX and ONYX can be found on the map. VIRA and KARA are not present. Note that even though NYX is present twice in the input gate_names, it only appears once in the output set of gate names. Duplicates are removed."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "<p>Use Trie.</p>"
        ],
        "relatedTopics": [
            {
                "name": "Recursion",
                "slug": "recursion"
            },
            {
                "name": "DFS",
                "slug": "dfs"
            },
            {
                "name": "Graph",
                "slug": "graph"
            },
            {
                "name": "Trie",
                "slug": "trie"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            },
            {
                "name": "Advanced Data Structure",
                "slug": "advanced-data-structure"
            }
        ],
        "companies": [
            "amazon",
            "microsoft",
            "makemytrip",
            "directi",
            "google",
            "facebook",
            "yahoo",
            "nvidia"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\nclass Solution {\npublic:\n\n#define char_int(c) ((int)c - (int)'A') \n  \n// Alphabet size \n#define SIZE (26) \n    struct TrieNode { \n    TrieNode* Child[SIZE]; \n  \n    // isLeaf is true if the node represents \n    // end of a word \n    bool leaf; \n}; \n  \n// Returns new trie node (initialized to NULLs) \nTrieNode* getNode() \n{ \n    TrieNode* newNode = new TrieNode; \n    newNode->leaf = false; \n    for (int i = 0; i < SIZE; i++) \n        newNode->Child[i] = NULL; \n    return newNode; \n} \n  \n// If not present, inserts a key into the trie \n// If the key is a prefix of trie node, just \n// marks leaf node \nvoid insert(TrieNode* root, string Key) \n{ \n    int n = Key.size(); \n    TrieNode* pChild = root; \n  \n    for (int i = 0; i < n; i++) { \n        int index = char_int(Key[i]); \n  \n        if (pChild->Child[index] == NULL) \n            pChild->Child[index] = getNode(); \n  \n        pChild = pChild->Child[index]; \n    } \n  \n    // make last node as leaf node \n    pChild->leaf = true; \n} \n  \n// function to check that current location \n// (i and j) is in matrix range \nbool isSafe(int i, int j, vector<vector<bool>>& visited) \n{ \n    int M = visited.size();\n    int N = visited[0].size();\n    return (i >= 0 && i < M && j >= 0 && j < N && !visited[i][j]); \n} \n  \n// A recursive function to print all words present on map \nvoid searchWord(TrieNode* root, vector<vector<char> >& map, int i, \n                int j, vector<vector<bool>> &visited, string str,set<string>& fans) \n{ \n    int M = map.size();\n     int N = map[0].size();\n    // if we found word in trie / gate_names \n    if (root->leaf == true) \n        fans.insert(str); \n  \n    // If both I and j in  range and we visited \n    // that element of matrix first time \n    if (isSafe(i, j, visited)) { \n        // make it visited \n        visited[i][j] = true; \n  \n        // traverse all childs of current root \n        for (int K = 0; K < SIZE; K++) { \n            if (root->Child[K] != NULL) { \n                // current character \n                char ch = (char)K + (char)'A'; \n  \n                // Recursively search reaming character of word \n                // in trie for all 8 adjacent cells of map[i][j] \n                if (isSafe(i + 1, j + 1, visited) \n                    && map[i + 1][j + 1] == ch) \n                    searchWord(root->Child[K], map, \n                               i + 1, j + 1, visited, str + ch,fans); \n                if (isSafe(i, j + 1, visited) \n                    && map[i][j + 1] == ch) \n                    searchWord(root->Child[K], map, \n                               i, j + 1, visited, str + ch,fans); \n                if (isSafe(i - 1, j + 1, visited) \n                    && map[i - 1][j + 1] == ch) \n                    searchWord(root->Child[K], map, \n                               i - 1, j + 1, visited, str + ch,fans); \n                if (isSafe(i + 1, j, visited) \n                    && map[i + 1][j] == ch) \n                    searchWord(root->Child[K], map, \n                               i + 1, j, visited, str + ch,fans); \n                if (isSafe(i + 1, j - 1, visited) \n                    && map[i + 1][j - 1] == ch) \n                    searchWord(root->Child[K], map, \n                               i + 1, j - 1, visited, str + ch,fans); \n                if (isSafe(i, j - 1, visited) \n                    && map[i][j - 1] == ch) \n                    searchWord(root->Child[K], map, \n                               i, j - 1, visited, str + ch,fans); \n                if (isSafe(i - 1, j - 1, visited) \n                    && map[i - 1][j - 1] == ch) \n                    searchWord(root->Child[K], map, \n                               i - 1, j - 1, visited, str + ch,fans); \n                if (isSafe(i - 1, j, visited) \n                    && map[i - 1][j] == ch) \n                    searchWord(root->Child[K], map, \n                               i - 1, j, visited, str + ch,fans); \n            } \n        } \n  \n        // make current element unvisited \n        visited[i][j] = false; \n    } \n} \n  \n// Prints all words present in gate_names. \nvector<string> findWords(vector<vector<char> >& map, TrieNode* root) \n{ \n    // Mark all characters as not visited \n     int M = map.size();\n     int N = map[0].size();\n    vector<vector<bool>> visited;\n    for(int i=0;i<M;i++)\n    { vector<bool> tmp;\n        for(int j=0;j<N;j++)\n        tmp.push_back(0);\n        visited.push_back(tmp);\n    }\n  \n    TrieNode* pChild = root; \n  \n    string str = \"\"; \n    set<string> ans;\n  \n    // traverse all matrix elements \n    for (int i = 0; i < M; i++) { \n        for (int j = 0; j < N; j++) { \n            // we start searching for word in gate_names \n            // if we found a character which is child \n            // of Trie root \n            if (pChild->Child[char_int(map[i][j])]) { \n                str = str + map[i][j]; \n                searchWord(pChild->Child[char_int(map[i][j])], \n                           map, i, j, visited, str,ans); \n                str = \"\"; \n            } \n        } \n    } \n    vector<string> fans;\n    for (auto el: ans)\n        fans.push_back(el);\n    return fans;\n} \n    vector<string> openGates(vector<vector<char> >& map, vector<string>& gate_names) {\n        // Code here\n        TrieNode* root = getNode(); \n        for (int i = 0; i < gate_names.size(); i++) \n        insert(root, gate_names[i]); \n         return findWords(map, root); \n    }\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution\n{\n\n    // Alphabet size\n    static int SIZE = 26;\n    static int M, N;\n\n    // trie Node\n    static class TrieNode\n    {\n        TrieNode[] Child = new TrieNode[SIZE];\n\n        // isLeaf is true if the node represents\n        // end of a word\n        boolean leaf;\n\n        // constructor\n        public TrieNode()\n        {\n            leaf = false;\n            for (int i = 0; i < SIZE; i++)\n                Child[i] = null;\n        }\n    }\n\n    static int char_int(char c){\n        return c-'A';\n    }    // If not present, inserts a key into the trie\n    // If the key is a prefix of trie node, just\n    // marks leaf node\n    void insert(TrieNode root, String Key)\n    {\n        int n = Key.length();\n        TrieNode pChild = root;\n\n        for (int i = 0; i < n; i++)\n        {\n            int index = Key.charAt(i) - 'A';\n            if (pChild.Child[index] == null)\n                pChild.Child[index] = new TrieNode();\n\n            pChild = pChild.Child[index];\n        }\n\n        // make last node as leaf node\n        pChild.leaf = true;\n    }\n\n    // function to check that current location\n    // (i and j) is in matrix range\n    static boolean isSafe(int i, int j, boolean[][] visited)\n    {\n        return (i >= 0 && i < M && j >= 0 && j < N && !visited[i][j]);\n    }\n\n    // A recursive function to print all words present on boggle\n    static void searchWord(TrieNode root, char boggle[][], int i,\n                           int j, boolean visited[][], String str, Set<String> fans)\n    {\n\n        // if we found word in trie / dictionary\n        if (root.leaf == true)\n            fans.add(str);\n\n        // If both I and j in  range and we visited\n        // that element of matrix first time\n        if (isSafe(i, j, visited))\n        {\n            // make it visited\n            visited[i][j] = true;\n\n            // traverse all childs of current root\n\n            for (int k = 0; k < SIZE; k++)\n            {\n                if (root.Child[k] != null)\n                {\n                    // current character\n                    char ch = (char)(k + 'A');\n\n                    // Recursively search reaming character of word\n                    // in trie for all 8 adjacent cells of boggle[i][j]\n                    if (isSafe(i + 1, j + 1, visited)\n                            && boggle[i + 1][j + 1] == ch)\n                        searchWord(root.Child[k], boggle,\n                                   i + 1, j + 1, visited, str + ch, fans);\n                    if (isSafe(i, j + 1, visited)\n                            && boggle[i][j + 1] == ch)\n                        searchWord(root.Child[k], boggle,\n                                   i, j + 1, visited, str + ch, fans);\n                    if (isSafe(i - 1, j + 1, visited)\n                            && boggle[i - 1][j + 1] == ch)\n                        searchWord(root.Child[k], boggle,\n                                   i - 1, j + 1, visited, str + ch, fans);\n                    if (isSafe(i + 1, j, visited)\n                            && boggle[i + 1][j] == ch)\n                        searchWord(root.Child[k], boggle,\n                                   i + 1, j, visited, str + ch, fans);\n                    if (isSafe(i + 1, j - 1, visited)\n                            && boggle[i + 1][j - 1] == ch)\n                        searchWord(root.Child[k], boggle,\n                                   i + 1, j - 1, visited, str + ch, fans);\n                    if (isSafe(i, j - 1, visited)\n                            && boggle[i][j - 1] == ch)\n                        searchWord(root.Child[k], boggle,\n                                   i, j - 1, visited, str + ch, fans);\n                    if (isSafe(i - 1, j - 1, visited)\n                            && boggle[i - 1][j - 1] == ch)\n                        searchWord(root.Child[k], boggle,\n                                   i - 1, j - 1, visited, str + ch, fans);\n                    if (isSafe(i - 1, j, visited)\n                            && boggle[i - 1][j] == ch)\n                        searchWord(root.Child[k], boggle,\n                                   i - 1, j, visited, str + ch, fans);\n                }\n            }\n\n            // make current element unvisited\n            visited[i][j] = false;\n        }\n    }\n\n    // Prints all words present in dictionary.\n    static String[] findWords(char boggle[][], TrieNode root)\n    {\n        // Mark all characters as not visited\n        M = boggle.length;\n        N = boggle[0].length;\n        boolean[][] visited = new boolean[M][N];\n\n\n        TrieNode pChild = root;\n\n        String str = \"\";\n        Set<String> fans = new HashSet<String>();\n\n        // traverse all matrix elements\n        for (int i = 0; i < M; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                // we start searching for word in dictionary\n                // if we found a character which is child\n                // of Trie root\n                if (pChild.Child[char_int(boggle[i][j])] != null)\n                {\n                    str = str + boggle[i][j];\n                    searchWord(pChild.Child[char_int(boggle[i][j])],\n                               boggle, i, j, visited, str, fans);\n                    str = \"\";\n                }\n            }\n        }\n        String []ans = new String[fans.size()];\n        int i = 0;\n        for (String el : fans)\n            ans[i++] = el;\n        return ans;\n    }\n    public String[] wordBoggle(char boggle[][], String[] dictionary)\n    {\n        TrieNode root = new TrieNode();\n        int n = dictionary.length;\n        for (int i = 0; i < n; i++)\n            insert(root, dictionary[i]);\n        return findWords(boggle, root);\n    }\n};",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "SIZE = 26\nclass TrieNode():\n    def __init__(self):\n        self.leaf = False\n        self.child = [None]*SIZE\n        for i in range(SIZE):\n            self.child[i] = None\n\nclass Solution():\n    \n    def insert(self,root,key):\n        \n        n = len(key)\n        pChild = root\n\n        for i in range(n):\n            index = ord(key[i]) - ord('A');\n            if pChild.child[index]==None :\n                pChild.child[index] = TrieNode()\n\n            pChild = pChild.child[index]\n\n        pChild.leaf = True\n    \n    def isSafe(self,i,j,visited) :\n        if i >= 0 and i < self.M and j >= 0 and j < self.N and visited[i][j] == False :\n            return True\n        return False\n\n    def  searchWord(self,root,boggle,i,j,visited,s,fans):\n        if root.leaf == True :\n            fans.add(s)\n\n        if self.isSafe(i,j,visited) :\n            visited[i][j]=True\n\n            for k in range(SIZE):\n                if root.child[k]!=None :\n                    ch = chr(k+ord('A'))\n\n                    if self.isSafe(i + 1, j + 1, visited) and boggle[i + 1][j + 1] == ch :\n                        self.searchWord(root.child[k], boggle,i + 1, j + 1, visited, s + ch, fans)\n\n                    if self.isSafe(i, j + 1, visited) and boggle[i][j + 1] == ch :\n                        self.searchWord(root.child[k], boggle,i, j + 1, visited, s + ch, fans)\n\n                    if self.isSafe(i - 1, j + 1, visited) and boggle[i - 1][j + 1] == ch :\n                        self.searchWord(root.child[k], boggle,i - 1, j + 1, visited, s + ch, fans)\n\n                    if self.isSafe(i + 1, j, visited) and boggle[i + 1][j] == ch :\n                        self.searchWord(root.child[k], boggle,i + 1, j, visited, s + ch, fans)\n\n                    if self.isSafe(i + 1, j - 1, visited) and boggle[i + 1][j - 1] == ch :\n                        self.searchWord(root.child[k], boggle,i + 1, j - 1, visited, s + ch, fans)\n\n                    if self.isSafe(i, j - 1, visited) and boggle[i][j - 1] == ch :\n                        self.searchWord(root.child[k], boggle,i, j - 1, visited, s + ch, fans)\n\n                    if self.isSafe(i - 1, j - 1, visited) and boggle[i - 1][j - 1] == ch :\n                        self.searchWord(root.child[k], boggle,i - 1, j - 1, visited, s + ch, fans)\n\n                    if self.isSafe(i - 1, j, visited) and boggle[i - 1][j] == ch :\n                        self.searchWord(root.child[k], boggle,i - 1, j, visited, s + ch, fans)\n\n            visited[i][j] = False\n\n\n    def findWords(self,boggle,root):\n        # Mark all characters as not visited\n        self.M = len(boggle);\n        self.N = len(boggle[0]);\n        visited = [[False for i in range(self.N)] for i in range(self.M)]\n    \n        pChild = root;\n\n        s = \"\";\n        fans = set()\n        \n        # traverse all matrix elements\n        for i in range(self.M) :\n            for j in range(self.N):\n            \n                # we start searching for word in dictionary\n                # if we found a character which is child\n                # of Trie root\n                index = ord(boggle[i][j]) - ord('A')\n                if (pChild.child[index] != None) :\n                    s = s + boggle[i][j]\n                    self.searchWord(pChild.child[index],boggle, i, j, visited, s, fans)\n                    s = \"\";\n                \n        ans = []\n        for el in fans :\n            ans.append(el)\n        return ans\n\n    def wordBoggle(self,boggle,dictionary):\n        root = TrieNode()\n        n = len(dictionary)\n        for i in range(n):\n            self.insert(root,dictionary[i])\n        \n        return self.findWords(boggle,root)\n",
                "lang_text": "python3"
            },
            {
                "lang": "Javascript",
                "full_func": null,
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}