{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": 706417,
            "title": "Word Ladder II",
            "titleSlug": "word-ladder-ii",
            "content": "<p><span style=\"font-size: 18px;\">Given two distinct words <strong>startWord</strong> and <strong>targetWord</strong>, and a list&nbsp;denoting <strong>wordList</strong>&nbsp;of unique words of equal lengths. </span> <span style=\"font-size: 18px;\">Find all shortest transformation sequence(s) from startWord to targetWord. You can return them in any order possible.</span><br /><span style=\"font-size: 18px;\">Keep&nbsp;the following conditions in mind:</span></p>\n<ul>\n<li><span style=\"font-size: 18px;\">A word can only consist of lowercase characters.</span></li>\n<li><span style=\"font-size: 18px;\">Only one letter can be changed in each transformation.</span></li>\n<li><span style=\"font-size: 18px;\">Each transformed word must exist in the wordList including the targetWord.</span></li>\n<li><span style=\"font-size: 18px;\">startWord may or may not be part of the&nbsp;wordList.</span><span style=\"font-size: 18px;\"> </span></li>\n<li><span style=\"font-size: 18px;\">Return an empty list if there is no such transformation sequence.</span></li>\n</ul>\n<p><span style=\"font-size: 18px;\">The first part of this problem can be found <a href=\"https://practice.geeksforgeeks.org/problems/word-ladder/1/\">here</a>.</span></p>\n<p><br /><strong><span style=\"font-size: 18px;\">Example 1:</span></strong></p>\n<pre><strong><span style=\"font-size: 18px;\">Input:\n</span></strong><span style=\"font-size: 18px;\">startWord = \"der\", targetWord = \"dfs\",\nwordList = {\"des\",\"der\",\"dfr\",\"dgt\",\"dfs\"}\n<strong>Output:\n</strong>der dfr dfs\nder des dfs\n<strong>Explanation:\n</strong>The length of the smallest transformation is 3.\nAnd the following are the only two ways to get\nto targetWord:-\n\"der\" -&gt; \"des\" -&gt; \"dfs\".</span>\n<span style=\"font-size: 18px;\">\"der\" -&gt; \"dfr\" -&gt; \"dfs\".</span>\n</pre>\n<p><span style=\"font-size: 18px;\"><strong>Example 2:</strong></span></p>\n<pre><span style=\"font-size: 18px;\"><strong>Input:\n</strong>startWord = \"gedk\", targetWord = \"geek\", \nwordList = {\"geek\", \"gefk\"}\n<strong>Output:\n</strong>\"gedk\" -&gt; \"geek\"</span>\n</pre>\n<p><br /><span style=\"font-size: 18px;\"><strong>Your Task:</strong><br />You don't need to read or print anything, Your task is to complete the function&nbsp;findSequences<strong>()&nbsp;</strong>which takes startWord, targetWord and wordList as input parameter and returns a list of list of strings of the shortest transformation sequence from startWord to targetWord.<br /><strong>Note: </strong>You don't have to return -1 in case of no possible sequence. Just return the Empty List.</span></p>\n<p><br /><span style=\"font-size: 18px;\"><strong>Expected Time Compelxity:&nbsp;</strong>O(N*(logN * M * 26))<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N * M) where N = length of wordList and M = |wordList<sub>i</sub>|</span></p>\n<p><br /><span style=\"font-size: 18px;\"><strong>Constraints:</strong><br />1 &le; N &le; 100<br />1 &le; M &le; 10</span></p>",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": "NA",
            "dislikes": "NA"
        },
        "similar": [],
        "hints": [
            "<p><span style=\"font-size:18px\">Think of words having difference in only one character as adjacent nodes and solve using BFS algorithm. ie- use a queue to keep track of adjacent nodes.&nbsp;</span></p>"
        ],
        "relatedTopics": [
            {
                "name": "Graph",
                "slug": "graph"
            },
            {
                "name": "BFS",
                "slug": "bfs"
            },
            {
                "name": "Data Structures",
                "slug": "data-structures"
            },
            {
                "name": "Algorithms",
                "slug": "algorithms"
            }
        ],
        "companies": [
            "flipkart",
            "amazon",
            "microsoft",
            "adobe",
            "google"
        ],
        "solutions": [
            {
                "lang": "C++",
                "full_func": "//Back-end complete function Template for C++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<vector<string>> findSequences(string beginWord, string endWord, vector<string>& wordList) {\r\n        unordered_set<string> wordList1;\r\n        \r\n        for(int i=0; i<wordList.size(); i++)\r\n            wordList1.insert(wordList[i]);\r\n        vector<vector<string>> ans;\r\n        queue<vector<string>> paths;\r\n        paths.push({beginWord});\r\n        int level = 1;\r\n        int minLevel = INT_MAX;\r\n        \r\n        //\"visited\" records all the visited nodes on this level\r\n        //these words will never be visited again after this level \r\n        //and should be removed from wordList. This is guaranteed\r\n        // by the shortest path.\r\n        unordered_set<string> visited; \r\n        \r\n        while (!paths.empty()) {\r\n            vector<string> path = paths.front();\r\n            paths.pop();\r\n            if (path.size() > level) {\r\n                //reach a new level\r\n                for (string w : visited) wordList1.erase(w);\r\n                visited.clear();\r\n                if (path.size() > minLevel)\r\n                    break;\r\n                else\r\n                    level = path.size();\r\n            }\r\n            string last = path.back();\r\n            //find next words in wordList by changing\r\n            //each element from 'a' to 'z'\r\n            for (int i = 0; i < last.size(); ++i) {\r\n                string news = last;\r\n                for (char c = 'a'; c <= 'z'; ++c) {\r\n                    news[i] = c;\r\n                    if (wordList1.find(news) != wordList1.end()) {\r\n                    //next word is in wordList\r\n                    //append this word to path\r\n                    //path will be reused in the loop\r\n                    //so copy a new path\r\n                        vector<string> newpath = path;\r\n                        newpath.push_back(news);\r\n                        visited.insert(news);\r\n                        if (news == endWord) {\r\n                            minLevel = level;\r\n                            ans.push_back(newpath);\r\n                        }\r\n                        else\r\n                            paths.push(newpath);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ans; \r\n    }\r\n};",
                "lang_text": "cpp"
            },
            {
                "lang": "Java",
                "full_func": "class Solution {\n    // Function to find all sequences from startWord to targetWord using wordList\n    public ArrayList<ArrayList<String>> findSequences(String startWord,\n                                                      String targetWord,\n                                                      String[] wordList) {\n        // Create a set to store the wordList for fast lookup\n        Set<String> dict = new HashSet<>();\n        // Add all words in the wordList to the set\n        for (String str : wordList) {\n            dict.add(str);\n        }\n        // If the set is empty or does not contain the targetWord, return an empty list\n        if (dict.isEmpty() || !dict.contains(targetWord)) {\n            return new ArrayList<>();\n        }\n        // Create two sets to store words at each level of the breadth-first search\n        Set<String> beginSet = new HashSet<>();\n        Set<String> endSet = new HashSet<>();\n\n        // Add startWord to the beginSet\n        beginSet.add(startWord);\n        // Add targetWord to the endSet\n        endSet.add(targetWord);\n\n        // Create a map to store the parent-child relationships between words\n        Map<String, List<String>> map = new HashMap<>();\n\n        // Call the helper function to build the map and determine if a sequence exists\n        helper(beginSet, endSet, dict, map, false);\n\n        // Create lists to store the sequences from startWord to targetWord\n        ArrayList<ArrayList<String>> res = new ArrayList<>();\n        ArrayList<String> sol = new ArrayList<>(Arrays.asList(startWord));\n\n        // Generate the sequences using the map\n        generateList(startWord, targetWord, map, sol, res);\n\n        // Return the list of sequences\n        return res;\n    }\n\n    // Helper function to generate the sequences\n    private void generateList(String begin, String end, Map<String, List<String>> map,\n                              ArrayList<String> sol, ArrayList<ArrayList<String>> res) {\n        // If begin word is the same as end word, add the solution to the result list\n        if (begin.equals(end)) {\n            res.add(new ArrayList<>(sol));\n            return;\n        }\n        // If the begin word is not in the map, return\n        if (!map.containsKey(begin)) {\n            return;\n        }\n        // Iterate through each word in the map that is connected to the begin word\n        for (String word : map.get(begin)) {\n            // Add the word to the solution\n            sol.add(word);\n            // Recursively generate the sequences\n            generateList(word, end, map, sol, res);\n            // Remove the word from the solution to backtrack\n            sol.remove(sol.size() - 1);\n        }\n    }\n\n    // Helper function to build the map and determine if a sequence exists\n    private boolean helper(Set<String> beginSet, Set<String> endSet, Set<String> dict,\n                           Map<String, List<String>> map, boolean flip) {\n        // If the beginSet is empty, return false indicating no sequence exists\n        if (beginSet.isEmpty()) {\n            return false;\n        }\n        // If the size of beginSet is greater than endSet, swap beginSet and endSet and\n        // flip the flag\n        if (beginSet.size() > endSet.size()) {\n            return helper(endSet, beginSet, dict, map, !flip);\n        }\n        // Create a set to store words at the next level of the breadth-first search\n        Set<String> set = new HashSet<>();\n        // Create a flag to track if a sequence has been found\n        boolean done = false;\n\n        // Remove words in beginSet and endSet from the dictionary\n        dict.removeAll(beginSet);\n        dict.removeAll(endSet);\n\n        // Iterate through each word in the beginSet\n        for (String word : beginSet) {\n            // Convert the word to a character array\n            char[] chs = word.toCharArray();\n            // Iterate through each character in the word\n            for (int i = 0; i < chs.length; ++i) {\n                // Try replacing the character with each lowercase letter\n                for (char c = 'a'; c <= 'z'; ++c) {\n                    // Save the original character\n                    char old = chs[i];\n                    // Replace the character with the lowercase letter\n                    chs[i] = c;\n\n                    // Create the target word with the replaced character\n                    String target = new String(chs);\n\n                    // Create the key-value pair based on the flip flag\n                    String key = flip ? target : word;\n                    String value = flip ? word : target;\n\n                    // Get the list of values for the key in the map or create a new\n                    // list if it doesn't exist\n                    List<String> list = map.getOrDefault(key, new ArrayList<>());\n\n                    // If the endSet contains the target word, set done flag to true and\n                    // add the value to the list\n                    if (endSet.contains(target)) {\n                        done = true;\n                        list.add(value);\n                        map.put(key, list);\n                    }\n\n                    // If done flag is false and the dictionary contains the target\n                    // word, add it to the set and list\n                    if (!done && dict.contains(target)) {\n                        set.add(target);\n                        list.add(value);\n                        map.put(key, list);\n                    }\n                    // Restore the original character\n                    chs[i] = old;\n                }\n            }\n        }\n        // If done flag is true or recursive call using the endSet and set returns true,\n        // return true\n        return done || helper(endSet, set, dict, map, !flip);\n    }\n}",
                "lang_text": "java"
            },
            {
                "lang": "Python3",
                "full_func": "\nimport collections\n\nclass Solution:\n    \n    #Function to find all possible sequences from beginWord to endWord\n    def findSequences(self, beginWord, endWord, wordList):\n        #Creating an empty defaultdict to store the relationships between words\n        tree = collections.defaultdict(set)\n        #Converting wordList into a set for efficient lookup\n        words = set(wordList)\n        #Getting the length of the beginWord\n        n = len(beginWord)\n        #Checking if endWord is not in the wordList, if not return empty list\n        if endWord not in wordList:\n            return []\n        \n        #Initializing variables\n        found = False\n        q = {beginWord}  #Using a set to store the current level of words\n        nq = set()  #Using a set to store the next level of words\n        \n        #While there are words in current level and not found\n        while q and not found:\n            #Removing words in current level from the word set\n            words -= set(q)\n            #Iterating through each word in current level\n            for x in q:\n                #Generating all possible variations of the word by replacing each character with all possible characters\n                for y in [x[:i]+c+x[i+1:] for i in range(n) for c in 'qwertyuiopasdfghjklzxcvbnm']:\n                    #If the variation is in the word set\n                    if y in words:\n                        #If the variation is the endWord, set found to True\n                        if y == endWord: \n                            found = True\n                        #Otherwise, add the variation to the next level set   \n                        else: \n                            nq.add(y)\n                        #Add the relationship between the current word and the variation to the tree dictionary\n                        tree[x].add(y)\n            #Update the current level set to the next level set\n            q, nq = nq, set()\n        \n        #Call the solve function to find all possible sequences from beginWord to endWord\n        return self.solve(beginWord, endWord, tree)\n    \n    #Function to find all possible sequences from beginWord to endWord using the relationships stored in the tree dictionary\n    def solve(self, x, endWord, tree):\n        #If the current word is the endWord, return a list of lists with the current word as the only element in each list\n        if x == endWord:\n            return [[x]]\n        \n        #Use list comprehension to find all possible sequences recursively\n        return [[x] + rest for y in tree[x] for rest in self.solve(y, endWord, tree)]\n",
                "lang_text": "python3"
            },
            {
                "lang": "Javascript",
                "full_func": "\nclass Solution {\n    findSequences(startWord, targetWord, wordList) {\n        let wordSet = new Set(wordList);\n        let ans = [];\n        let paths = [[startWord]];\n        let level = 1;\n        let minLevel = Infinity;\n        let visited = new Set();\n\n        while (paths.length !== 0) {\n            let path = paths.shift();\n            if (path.length > level) {\n                for (let word of visited) {\n                    wordSet.delete(word);\n                }\n                visited.clear();\n                if (path.length > minLevel)\n                    break;\n                else\n                    level = path.length;\n            }\n            let last = path[path.length-1];\n            for (let i = 0; i < last.length; i++) {\n                for (let c = 97; c <= 122; c++) {\n                    let news = last.slice(0,i) + String.fromCharCode(c) +  last.slice(i+1);\n                    if (wordSet.has(news)) {\n                        let newPath = path.slice();\n                        newPath.push(news);\n                        visited.add(news);\n                        if (news === targetWord) {\n                            minLevel = level;\n                            ans.push(newPath);\n                        } else {\n                            paths.push(newPath);\n                        } \n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}",
                "lang_text": "javascript"
            }
        ],
        "platform": "GFG"
    }
}