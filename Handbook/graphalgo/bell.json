[
    {
      "type": "p5",
      "text": "The Bellman-Ford algorithm is used to calculate the shortest path from a starting node to every other node in a graph. You might recall that we’ve already explored Dijkstra’s algorithm (see article link) for solving the same problem. So, what sets Bellman-Ford apart from Dijkstra’s approach?"
    },
    {
      "type": "p5",
      "text": "When studying Dijkstra’s algorithm, we encountered two scenarios where it doesn’t perform well:"
    },
    {
      "type": "ul",
      "text": [
        "The graph includes negative weight edges.",
        "The graph contains a negative weight cycle (In this case, Dijkstra’s algorithm can't compute the correct shortest paths—it keeps revisiting the cycle endlessly, causing it to run forever and eventually trigger a Time Limit Exceeded error)."
      ]
    },
    {
      "type": "p5",
      "text": "Negative Cycle: This refers to a loop in the graph where the total weight of all the edges in the cycle adds up to a negative value."
    },
    {
      "type": "img",
      "text": "https://codecoffee-app.github.io/lc-data/handbook-images/graphalgo/dij/1.webp",
      "style": "w-20 h-18 my-2"
    },
    {
      "type": "p5",
      "text": "Sum: 2 + (-3) + (-1) = -2"
    },
    {
      "type": "p5",
      "text": "The Bellman-Ford algorithm effectively handles these challenges. It can manage negative edge weights and even identify the presence of a negative weight cycle within the graph. However, it's designed specifically for directed graphs. To use it with an undirected graph, you simply need to convert each undirected edge into two directed edges, as shown below:"
    },
    {
      "type": "h4",
      "text": "How Bellman-Ford Works"
    },
    {
      "type": "ol",
      "text": [
        "Set the distance to the source node as 0 and all other nodes as infinity.",
        "Relax all edges |V| - 1 times, where |V| is the number of vertices.",
        "To relax an edge means: if the distance to the destination can be shortened by taking the edge, update the distance.",
        "After |V| - 1 iterations, check for negative weight cycles by checking one more time. If any distance can still be updated, there is a negative cycle."
      ]
    },
    {
      "type": "h4",
      "text": "Manual Walkthrough Example"
    },
    {
      "type": "p5",
      "text": "Let’s walk through an example graph:"
    },
    {
      "type": "code",
      "text": {
        "lang": "text",
        "code": "Vertices: A, B, C, D\nEdges:\nA → B (4)\nA → C (5)\nB → C (-3)\nC → D (4)\nD → B (-6)"
      }
    },
    {
      "type": "p5",
      "text": "We want to find the shortest paths from A to all other vertices."
    },
    {
      "type": "ol",
      "text": [
        "Step 1: Initialize distances. Distance[A] = 0, all others = ∞",
        "Step 2: First iteration (relax all edges):",
        "A → B: 0 + 4 = 4 → Distance[B] = 4",
        "A → C: 0 + 5 = 5 → Distance[C] = 5",
        "B → C: 4 + (-3) = 1 → Distance[C] = 1",
        "C → D: 1 + 4 = 5 → Distance[D] = 5",
        "D → B: 5 + (-6) = -1 → Distance[B] = -1",
        "Step 3: Second iteration:",
        "B → C: -1 + (-3) = -4 → Distance[C] = -4",
        "C → D: -4 + 4 = 0 → Distance[D] = 0",
        "D → B: 0 + (-6) = -6 → Distance[B] = -6",
        "Step 4: Third iteration: values keep reducing.",
        "If values continue to decrease, we detect a negative weight cycle!"
      ]
    },
    {
      "type": "h4",
      "text": "Bellman-Ford Pseudocode"
    },
    {
      "type": "code",
      "text": {
        "lang": "pseudo",
        "code": "function bellmanFord(vertices, edges, source):\n    distance = map with all vertices set to ∞\n    distance[source] = 0\n\n    for i = 1 to vertices - 1:\n        for each (u, v, weight) in edges:\n            if distance[u] + weight < distance[v]:\n                distance[v] = distance[u] + weight\n\n    for each (u, v, weight) in edges:\n        if distance[u] + weight < distance[v]:\n            report \"Negative cycle detected\"\n\n    return distance"
      }
    },
    {
      "type": "h4",
      "text": "Time Complexity"
    },
    {
      "type": "ul",
      "text": [
        "Best Case: O(V × E)",
        "Average Case: O(V × E)",
        "Worst Case: O(V × E)"
      ]
    },
    {
      "type": "p5",
      "text": "Here, V is the number of vertices and E is the number of edges. It’s slower than Dijkstra but works when negative weights are present."
    },
    {
      "type": "h4",
      "text": "When to Use Bellman-Ford"
    },
    {
      "type": "ul",
      "text": [
        "When the graph contains negative edge weights.",
        "When you need to detect negative weight cycles.",
        "Not suitable for very large graphs due to higher time complexity."
      ]
    }
  ]
  