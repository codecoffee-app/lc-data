{
    "failed": false,
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "3245",
            "title": "Alternating Groups III",
            "titleSlug": "alternating-groups-iii",
            "content": "<p>There are some red and blue tiles arranged circularly. You are given an array of integers <code>colors</code> and a 2D integers array <code>queries</code>.</p>\n\n<p>The color of tile <code>i</code> is represented by <code>colors[i]</code>:</p>\n\n<ul>\n\t<li><code>colors[i] == 0</code> means that tile <code>i</code> is <strong>red</strong>.</li>\n\t<li><code>colors[i] == 1</code> means that tile <code>i</code> is <strong>blue</strong>.</li>\n</ul>\n\n<p>An <strong>alternating</strong> group is a contiguous subset of tiles in the circle with <strong>alternating</strong> colors (each tile in the group except the first and last one has a different color from its <b>adjacent</b> tiles in the group).</p>\n\n<p>You have to process queries of two types:</p>\n\n<ul>\n\t<li><code>queries[i] = [1, size<sub>i</sub>]</code>, determine the count of <strong>alternating</strong> groups with size <code>size<sub>i</sub></code>.</li>\n\t<li><code>queries[i] = [2, index<sub>i</sub>, color<sub>i</sub>]</code>, change <code>colors[index<sub>i</sub>]</code> to <code>color<font face=\"monospace\"><sub>i</sub></font></code>.</li>\n</ul>\n\n<p>Return an array <code>answer</code> containing the results of the queries of the first type <em>in order</em>.</p>\n\n<p><strong>Note</strong> that since <code>colors</code> represents a <strong>circle</strong>, the <strong>first</strong> and the <strong>last</strong> tiles are considered to be next to each other.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">colors = [0,1,1,0,1], queries = [[2,1,0],[1,4]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[2]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><strong class=\"example\"><img alt=\"\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-bgimage=\"\" src=\"https://assets.leetcode.com/uploads/2024/06/03/screenshot-from-2024-06-03-20-14-44.png\" style=\"width: 150px; height: 150px; padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #181a1b;\" /></strong></p>\n\n<p>First query:</p>\n\n<p>Change <code>colors[1]</code> to 0.</p>\n\n<p><img alt=\"\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-bgimage=\"\" src=\"https://assets.leetcode.com/uploads/2024/06/03/screenshot-from-2024-06-03-20-20-25.png\" style=\"width: 150px; height: 150px; padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #181a1b;\" /></p>\n\n<p>Second query:</p>\n\n<p>Count of the alternating groups with size 4:</p>\n\n<p><img alt=\"\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-bgimage=\"\" src=\"https://assets.leetcode.com/uploads/2024/06/03/screenshot-from-2024-06-03-20-25-02-2.png\" style=\"width: 150px; height: 150px; padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #181a1b;\" /><img alt=\"\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-bgimage=\"\" src=\"https://assets.leetcode.com/uploads/2024/06/03/screenshot-from-2024-06-03-20-24-12.png\" style=\"width: 150px; height: 150px; padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #181a1b;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">colors = [0,0,1,0,1,1], queries = [[1,3],[2,3,0],[1,5]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[2,0]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-bgimage=\"\" src=\"https://assets.leetcode.com/uploads/2024/06/03/screenshot-from-2024-06-03-20-35-50.png\" style=\"width: 150px; height: 150px; padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #181a1b;\" /></p>\n\n<p>First query:</p>\n\n<p>Count of the alternating groups with size 3:</p>\n\n<p><img alt=\"\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-bgimage=\"\" src=\"https://assets.leetcode.com/uploads/2024/06/03/screenshot-from-2024-06-03-20-37-13.png\" style=\"width: 150px; height: 150px; padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #181a1b;\" /><img alt=\"\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-bgimage=\"\" src=\"https://assets.leetcode.com/uploads/2024/06/03/screenshot-from-2024-06-03-20-36-40.png\" style=\"width: 150px; height: 150px; padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #181a1b;\" /></p>\n\n<p>Second query: <code>colors</code> will not change.</p>\n\n<p>Third query: There is no alternating group with size 5.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= colors.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= colors[i] &lt;= 1</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>queries[i][0] == 1</code> or <code>queries[i][0] == 2</code></li>\n\t<li>For all <code>i</code> that:\n\t<ul>\n\t\t<li><code>queries[i][0] == 1</code>: <code>queries[i].length == 2</code>, <code>3 &lt;= queries[i][1] &lt;= colors.length - 1</code></li>\n\t\t<li><code>queries[i][0] == 2</code>: <code>queries[i].length == 3</code>, <code>0 &lt;= queries[i][1] &lt;= colors.length - 1</code>, <code>0 &lt;= queries[i][2] &lt;= 1</code></li>\n\t</ul>\n\t</li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 53,
            "dislikes": 8,
            "similarQuestions": "[]",
            "topicTags": [
                {
                    "name": "Array",
                    "slug": "array"
                },
                {
                    "name": "Binary Indexed Tree",
                    "slug": "binary-indexed-tree"
                }
            ],
            "stats": "{\"totalAccepted\": \"1.4K\", \"totalSubmission\": \"9.6K\", \"totalAcceptedRaw\": 1397, \"totalSubmissionRaw\": 9645, \"acRate\": \"14.5%\"}",
            "hints": [
                "Try using a segment tree to store the maximal alternating groups.",
                "Store the sizes of these maximal alternating groups in another data structure.",
                "Find the count of the alternating groups of size <code>k</code> with having the count of maximal alternating groups with size greater than or equal to <code>k</code> and the sum of their sizes."
            ],
            "rephrased": {
                "body": "Given a circular arrangement of red and blue tiles represented by an array `colors` (0 for red, 1 for blue), and a list of queries `queries`, process each query and return the results of type 1 queries. An alternating group is a contiguous subset of tiles with alternating colors. Queries are of two types:\n\n1.  `[1, size]`: Count the number of alternating groups of size `size`.\n2.  `[2, index, color]`: Change the color of tile at `index` to `color`.\n\nNote that the tiles are arranged in a circle, so the first and last tiles are considered adjacent.",
                "constraints": [
                    "4 <= colors.length <= 5 * 10^4",
                    "0 <= colors[i] <= 1",
                    "1 <= queries.length <= 5 * 10^4",
                    "queries[i][0] == 1 or queries[i][0] == 2",
                    "For queries of type 1: queries[i].length == 2, 3 <= queries[i][1] <= colors.length - 1",
                    "For queries of type 2: queries[i].length == 3, 0 <= queries[i][1] <= colors.length - 1, 0 <= queries[i][2] <= 1"
                ],
                "testcases": [
                    {
                        "input": "colors = [0,1,1,0,1], queries = [[2,1,0],[1,4]]",
                        "output": "[2]",
                        "explanation": "First, the color at index 1 is changed to 0, resulting in colors = [0, 0, 1, 0, 1]. Then, the number of alternating groups of size 4 is calculated. There are two such groups: [0, 0, 1, 0] starting at index 3, and [0, 1, 0, 0] starting at index 2."
                    },
                    {
                        "input": "colors = [0,0,1,0,1,1], queries = [[1,3],[2,3,0],[1,5]]",
                        "output": "[2,0]",
                        "explanation": "For the first query, the number of alternating groups of size 3 is calculated, resulting in a count of 2. For the second query, the color at index 3 is changed to 0. The updated colors array becomes colors = [0, 0, 1, 0, 1, 1].  For the third query, the number of alternating groups of size 5 is calculated, which is 0 since there are no alternating sequences of length 5 in the array"
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "Try using a segment tree to store the maximal alternating groups.",
            "Store the sizes of these maximal alternating groups in another data structure.",
            "Find the count of the alternating groups of size <code>k</code> with having the count of maximal alternating groups with size greater than or equal to <code>k</code> and the sum of their sizes."
        ],
        "relatedTopics": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Binary Indexed Tree",
                "slug": "binary-indexed-tree"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "struct SegmentTree {\n public:\n  explicit SegmentTree(int n)\n      : n(n), treeIntervalCounts(4 * n), treeIntervalLengths(4 * n) {}\n\n  // Adds val to intervalCounts[i] and updates intervalLengths[i] accordingly.\n  void add(int i, int val) {\n    add(0, 0, n - 1, i, val);\n  }\n\n  // Returns sum(intervalCounts[i..n - 1]).\n  int queryIntervalCounts(int i) const {\n    return query(treeIntervalCounts, 0, 0, n - 1, i, n - 1);\n  }\n\n  // Returns sum(intervalLengths[i..n - 1]).\n  int queryIntervalLengths(int i) const {\n    return query(treeIntervalLengths, 0, 0, n - 1, i, n - 1);\n  }\n\n private:\n  const int n;\n  vector<int> treeIntervalCounts;\n  vector<int> treeIntervalLengths;\n\n  void add(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      treeIntervalCounts[treeIndex] += val;\n      treeIntervalLengths[treeIndex] = treeIntervalCounts[treeIndex] * i;\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      add(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      add(2 * treeIndex + 2, mid + 1, hi, i, val);\n    treeIntervalCounts[treeIndex] =\n        merge(treeIntervalCounts[2 * treeIndex + 1],\n              treeIntervalCounts[2 * treeIndex + 2]);\n    treeIntervalLengths[treeIndex] =\n        merge(treeIntervalLengths[2 * treeIndex + 1],\n              treeIntervalLengths[2 * treeIndex + 2]);\n  }\n\n  int query(const vector<int>& tree, int treeIndex, int lo, int hi, int i,\n            int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return 0;\n    const int mid = (lo + hi) / 2;\n    return merge(query(tree, treeIndex * 2 + 1, lo, mid, i, j),\n                 query(tree, treeIndex * 2 + 2, mid + 1, hi, i, j));\n  }\n\n  int merge(int left, int right) const {\n    return left + right;\n  }\n};\n\nclass Solution {\n public:\n  vector<int> numberOfAlternatingGroups(vector<int>& colors,\n                                        vector<vector<int>>& queries) {\n    const int n = colors.size();\n    vector<int> ans;\n    vector<int> arr{colors};\n    SegmentTree tree(2 * n - 1);\n    set<pair<int, int>> intervals;\n\n    arr.insert(arr.end(), colors.begin(), colors.end());\n\n    // Insert all intervals, each of them is an alternating sequence.\n    int start = 0;\n    for (int i = 1; i < 2 * n - 1; ++i)\n      if (arr[i] == arr[i - 1]) {\n        insert(intervals, {start, i - 1}, tree, n);\n        start = i;\n      }\n    insert(intervals, {start, 2 * n - 2}, tree, n);\n\n    for (const vector<int>& query : queries)\n      if (query[0] == 1) {\n        const int sz = query[1];\n        const pair<int, int>& intervalWithN = findInterval(intervals, n);\n        const int numAlternatingGroups =\n            getNumAlternatingGroups(sz, intervalWithN, tree, n);\n        ans.push_back(numAlternatingGroups);\n      } else {\n        const int index = query[1];\n        const int color = query[2];\n        if (arr[index] == color)\n          continue;\n        update(intervals, index, color, arr, tree, n);\n        if (index < n - 1)\n          update(intervals, index + n, color, arr, tree, n);\n      }\n\n    return ans;\n  }\n\n private:\n  // Returns the number of alternating groups of size `sz`.\n  int getNumAlternatingGroups(int sz, const pair<int, int>& intervalWithN,\n                              const SegmentTree& tree, int n) {\n    const int numIntervals = tree.queryIntervalCounts(sz);\n    const int sumIntervals = tree.queryIntervalLengths(sz);\n    // The number of alternating groups for an interval is |interval| - sz + 1.\n    // Therefore, the number of alternating groups for all intervals is\n    //   sum(|intervals[i]| - sz + 1)\n    // = sum(|intervals[i]) - numIntervals * sz + numIntervals\n    const int numAlternatingGroups =\n        sumIntervals - numIntervals * sz + numIntervals;\n    // We need to check if the interval (l, r) contains n, and if it does, we\n    // need to adjust the number of alternating groups to avoid duplicates.\n    const auto& [l, r] = intervalWithN;\n    // 1. For an interval with l >= n, it wasn't being considered in `insert`\n    // and `remove`.\n    // 2. For an interval with r - l + 1 < sz, it's impossible to form a group\n    // of size `sz`.\n    if (l >= n || r - l + 1 < sz)\n      return numAlternatingGroups;\n    // 3. For an interval with r >= n, it's possible to duplicately count the\n    // groups starting from n.\n    if (r >= n) {  // l < n && r - 1 + 1 >= sz\n      // Groups starting from [l..n) are non-duplicately counted.\n      const int nonDuplicateGroups = n - l;\n      // The number of groups of size `sz` in the interval [l..r].\n      const int numGroups = (r - l + 1) - sz + 1;\n      return numAlternatingGroups - max(0, numGroups - nonDuplicateGroups);\n    }\n    return numAlternatingGroups;\n  }\n\n  // Inserts an interval into `intervals` and updates `tree`.\n  void insert(set<pair<int, int>>& intervals, const pair<int, int>& interval,\n              SegmentTree& tree, int n) {\n    intervals.insert(interval);\n    if (interval.first < n)\n      tree.add(interval.second - interval.first + 1, 1);\n  }\n\n  // Removes an interval from `intervals` and updates `tree`.\n  void remove(set<pair<int, int>>& intervals, const pair<int, int>& interval,\n              SegmentTree& tree, int n) {\n    intervals.erase(interval);\n    if (interval.first < n)\n      tree.add(interval.second - interval.first + 1, -1);\n  }\n\n  // Returns the interval containing the target.\n  pair<int, int> findInterval(const set<pair<int, int>>& intervals,\n                              int target) {\n    auto it = intervals.upper_bound({target, INT_MAX});\n    return (*--it);\n  }\n\n  // Updates the color of the index-th element in `arr` and updates `intervals`\n  // and `tree`.\n  void update(set<pair<int, int>>& intervals, int index, int color,\n              vector<int>& arr, SegmentTree& tree, int n) {\n    arr[index] = color;\n\n    const pair<int, int> intervalWithIndex = findInterval(intervals, index);\n    remove(intervals, intervalWithIndex, tree, n);\n    auto [start, end] = intervalWithIndex;\n\n    // interval [s..i - 1|i|i + 1..e]\n    //    index           ^\n    if (start < index && index < end) {\n      insert(intervals, {start, index - 1}, tree, n);\n      insert(intervals, {index, index}, tree, n);\n      insert(intervals, {index + 1, end}, tree, n);\n      return;\n    }\n\n    // interval [s|s + 1..e]\n    //    index  ^\n    if (start == index && index < end)\n      insert(intervals, {start + 1, end}, tree, n);\n\n    // interval [s..e - 1|e]\n    //    index           ^\n    if (start < index && index == end)\n      insert(intervals, {start, end - 1}, tree, n);\n\n    start = index;\n    end = index;\n    vector<pair<int, int>> intervalsToRemove;\n\n    auto it = intervals.upper_bound({index, INT_MAX});\n\n    for (auto lit = it; lit != intervals.begin();) {\n      --lit;\n      if (arr[lit->second] == arr[start])  // [..lit->second|start..]\n        break;\n      intervalsToRemove.push_back(*lit);\n      start = lit->first;\n    }\n\n    for (auto rit = it; rit != intervals.end(); ++rit) {\n      if (arr[rit->first] == arr[end])  // [..end|rit->first..]\n        break;\n      intervalsToRemove.push_back(*rit);\n      end = rit->second;\n    }\n\n    for (const pair<int, int>& interval : intervalsToRemove)\n      remove(intervals, interval, tree, n);\n\n    insert(intervals, {start, end}, tree, n);\n  }\n};\n",
                "lang_text": "cpp"
            }
        }
    }
}