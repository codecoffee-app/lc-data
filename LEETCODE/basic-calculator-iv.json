{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "770",
            "title": "Basic Calculator IV",
            "titleSlug": "basic-calculator-iv",
            "content": "<p>Given an expression such as <code>expression = &quot;e + 8 - a + 5&quot;</code> and an evaluation map such as <code>{&quot;e&quot;: 1}</code> (given in terms of <code>evalvars = [&quot;e&quot;]</code> and <code>evalints = [1]</code>), return a list of tokens representing the simplified expression, such as <code>[&quot;-1*a&quot;,&quot;14&quot;]</code></p>\n\n<ul>\n\t<li>An expression alternates chunks and symbols, with a space separating each chunk and symbol.</li>\n\t<li>A chunk is either an expression in parentheses, a variable, or a non-negative integer.</li>\n\t<li>A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like <code>&quot;2x&quot;</code> or <code>&quot;-x&quot;</code>.</li>\n</ul>\n\n<p>Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.</p>\n\n<ul>\n\t<li>For example, <code>expression = &quot;1 + 2 * 3&quot;</code> has an answer of <code>[&quot;7&quot;]</code>.</li>\n</ul>\n\n<p>The format of the output is as follows:</p>\n\n<ul>\n\t<li>For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.\n\t<ul>\n\t\t<li>For example, we would never write a term like <code>&quot;b*a*c&quot;</code>, only <code>&quot;a*b*c&quot;</code>.</li>\n\t</ul>\n\t</li>\n\t<li>Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.\n\t<ul>\n\t\t<li>For example, <code>&quot;a*a*b*c&quot;</code> has degree <code>4</code>.</li>\n\t</ul>\n\t</li>\n\t<li>The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.</li>\n\t<li>An example of a well-formatted answer is <code>[&quot;-2*a*a*a&quot;, &quot;3*a*a*b&quot;, &quot;3*b*b&quot;, &quot;4*a&quot;, &quot;5*c&quot;, &quot;-6&quot;]</code>.</li>\n\t<li>Terms (including constant terms) with coefficient <code>0</code> are not included.\n\t<ul>\n\t\t<li>For example, an expression of <code>&quot;0&quot;</code> has an output of <code>[]</code>.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p><strong>Note:</strong> You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;e + 8 - a + 5&quot;, evalvars = [&quot;e&quot;], evalints = [1]\n<strong>Output:</strong> [&quot;-1*a&quot;,&quot;14&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;e - 8 + temperature - pressure&quot;, evalvars = [&quot;e&quot;, &quot;temperature&quot;], evalints = [1, 12]\n<strong>Output:</strong> [&quot;-1*pressure&quot;,&quot;5&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;(e + 8) * (e - 8)&quot;, evalvars = [], evalints = []\n<strong>Output:</strong> [&quot;1*e*e&quot;,&quot;-64&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 250</code></li>\n\t<li><code>expression</code> consists of lowercase English letters, digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39; &#39;</code>.</li>\n\t<li><code>expression</code> does not contain any leading or trailing spaces.</li>\n\t<li>All the tokens in <code>expression</code> are separated by a single space.</li>\n\t<li><code>0 &lt;= evalvars.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= evalvars[i].length &lt;= 20</code></li>\n\t<li><code>evalvars[i]</code> consists of lowercase English letters.</li>\n\t<li><code>evalints.length == evalvars.length</code></li>\n\t<li><code>-100 &lt;= evalints[i] &lt;= 100</code></li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 157,
            "dislikes": 1388,
            "similarQuestions": "[{\"title\": \"Parse Lisp Expression\", \"titleSlug\": \"parse-lisp-expression\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator III\", \"titleSlug\": \"basic-calculator-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Hash Table",
                    "slug": "hash-table"
                },
                {
                    "name": "Math",
                    "slug": "math"
                },
                {
                    "name": "String",
                    "slug": "string"
                },
                {
                    "name": "Stack",
                    "slug": "stack"
                },
                {
                    "name": "Recursion",
                    "slug": "recursion"
                }
            ],
            "stats": "{\"totalAccepted\": \"9.9K\", \"totalSubmission\": \"18K\", \"totalAcceptedRaw\": 9881, \"totalSubmissionRaw\": 17967, \"acRate\": \"55.0%\"}",
            "hints": [
                "One way is with a Polynomial class.  For example,\r\n\r\n* `Poly:add(this, that)` returns the result of `this + that`.\r\n* `Poly:sub(this, that)` returns the result of `this - that`.\r\n* `Poly:mul(this, that)` returns the result of `this * that`.\r\n* `Poly:evaluate(this, evalmap)` returns the polynomial after replacing all free variables with constants as specified by `evalmap`.\r\n* `Poly:toList(this)` returns the polynomial in the correct output format.\r\n\r\n* `Solution::combine(left, right, symbol)` returns the result of applying the binary operator represented by `symbol` to `left` and `right`.\r\n* `Solution::make(expr)` makes a new `Poly` represented by either the constant or free variable specified by `expr`.\r\n* `Solution::parse(expr)` parses an expression into a new `Poly`."
            ],
            "rephrased": {
                "body": "Simplify a given expression consisting of variables, integers, addition, subtraction, and multiplication. You are also given a mapping of variable names to integer values.  The expression alternates between chunks and symbols, separated by spaces. A chunk can be a parenthesized expression, a variable (lowercase letters only), or a non-negative integer.  Variables never have leading coefficients (e.g., '2x' or '-x' are invalid). Evaluation follows standard order of operations (brackets, multiplication, then addition/subtraction).  The output should be a list of tokens representing the simplified expression, formatted according to the following rules:\n\n*   Terms are sorted lexicographically within each term (e.g., \"a*b*c\" instead of \"b*a*c\").\n*   Terms are ordered by degree (number of variables multiplied), largest degree first, with ties broken lexicographically (ignoring the leading coefficient).\n*   Coefficients are placed directly to the left of the variables with an asterisk separator (e.g., \"-2*a*a*a\").  A coefficient of 1 is included.\n*   Terms with a coefficient of 0 are omitted.",
                "constraints": [
                    "1 <= expression.length <= 250",
                    "expression consists of lowercase English letters, digits, '+', '-', '*', '(', ')', ' '.",
                    "expression does not contain any leading or trailing spaces.",
                    "All the tokens in expression are separated by a single space.",
                    "0 <= evalvars.length <= 100",
                    "1 <= evalvars[i].length <= 20",
                    "evalvars[i] consists of lowercase English letters.",
                    "evalints.length == evalvars.length",
                    "-100 <= evalints[i] <= 100",
                    "The given expression is always valid.",
                    "All intermediate results will be in the range of [-2^31, 2^31 - 1]."
                ],
                "testcases": [
                    {
                        "input": "expression = \"e + 8 - a + 5\", evalvars = [\"e\"], evalints = [1]",
                        "output": "[\"-1*a\",\"14\"]",
                        "explanation": "The variable 'e' is substituted with 1, simplifying the expression to 1 + 8 - a + 5, which further simplifies to 14 - a. This is represented as [\"-1*a\",\"14\"] following the output format rules."
                    },
                    {
                        "input": "expression = \"e - 8 + temperature - pressure\", evalvars = [\"e\", \"temperature\"], evalints = [1, 12]",
                        "output": "[\"-1*pressure\",\"5\"]",
                        "explanation": "Substituting 'e' with 1 and 'temperature' with 12, the expression becomes 1 - 8 + 12 - pressure, which simplifies to 5 - pressure. This translates to [\"-1*pressure\",\"5\"] in the specified output format."
                    },
                    {
                        "input": "expression = \"(e + 8) * (e - 8)\", evalvars = [], evalints = []",
                        "output": "[\"1*e*e\",\"-64\"]",
                        "explanation": "Since there are no variables to substitute, the expression remains (e + 8) * (e - 8). Expanding this yields e^2 - 64. This is represented as [\"1*e*e\",\"-64\"] in the requested output format."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Hard",
                "titleSlug": "parse-lisp-expression",
                "title": "Parse Lisp Expression",
                "isPaidOnly": false
            },
            {
                "difficulty": "Hard",
                "titleSlug": "basic-calculator-iii",
                "title": "Basic Calculator III",
                "isPaidOnly": true
            }
        ],
        "hints": [
            "One way is with a Polynomial class.  For example,\r\n\r\n* `Poly:add(this, that)` returns the result of `this + that`.\r\n* `Poly:sub(this, that)` returns the result of `this - that`.\r\n* `Poly:mul(this, that)` returns the result of `this * that`.\r\n* `Poly:evaluate(this, evalmap)` returns the polynomial after replacing all free variables with constants as specified by `evalmap`.\r\n* `Poly:toList(this)` returns the polynomial in the correct output format.\r\n\r\n* `Solution::combine(left, right, symbol)` returns the result of applying the binary operator represented by `symbol` to `left` and `right`.\r\n* `Solution::make(expr)` makes a new `Poly` represented by either the constant or free variable specified by `expr`.\r\n* `Solution::parse(expr)` parses an expression into a new `Poly`."
        ],
        "relatedTopics": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Math",
                "slug": "math"
            },
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Recursion",
                "slug": "recursion"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Poly {\n  friend Poly operator+(const Poly& lhs, const Poly& rhs) {\n    Poly res(lhs);\n    for (const auto& [term, coef] : rhs.terms)\n      res.terms[term] += coef;\n    return res;\n  }\n\n  friend Poly operator-(const Poly& lhs, const Poly& rhs) {\n    Poly res(lhs);\n    for (const auto& [term, coef] : rhs.terms)\n      res.terms[term] -= coef;\n    return res;\n  }\n\n  friend Poly operator*(const Poly& lhs, const Poly& rhs) {\n    Poly res;\n    for (const auto& [a, aCoef] : lhs.terms)\n      for (const auto& [b, bCoef] : rhs.terms)\n        res.terms[merge(a, b)] += aCoef * bCoef;\n    return res;\n  }\n\n  // Friend ostream& operator<<(ostream& os, const Poly& poly) {\n  //   os << \"{\";\n  //   for (const auto& [term, coef] : poly.terms)\n  //     os << term << \": \" << coef << \", \";\n  //   os << \"}\";\n  //   return os;\n  // }\n\n public:\n  vector<string> toList() {\n    vector<string> res;\n    vector<string> keys;\n    for (const auto& [term, _] : terms)\n      keys.push_back(term);\n    sort(keys.begin(), keys.end(), [&](const auto& a, const auto& b) {\n      // Smallest degree is the last\n      if (a == \"1\")\n        return false;\n      if (b == \"1\")\n        return true;\n      const vector<string> as = split(a, '*');\n      const vector<string> bs = split(b, '*');\n      // Largest degree is the first\n      // Breaking ties by lexicographic order\n      return as.size() == bs.size() ? a < b : as.size() > bs.size();\n    });\n    auto concat = [&](const string& term) -> string {\n      if (term == \"1\")\n        return to_string(terms[term]);\n      return to_string(terms[term]) + '*' + term;\n    };\n    for (const string& key : keys)\n      if (terms[key])\n        res.push_back(concat(key));\n    return res;\n  }\n\n  Poly() = default;\n  Poly(const string& term, int coef) {\n    terms[term] = coef;\n  }\n\n private:\n  unordered_map<string, int> terms;\n\n  // E.g. merge(\"a*b\", \"a*c\") -> \"a*a*b*c\"\n  static string merge(const string& a, const string& b) {\n    if (a == \"1\")\n      return b;\n    if (b == \"1\")\n      return a;\n    string res;\n    vector<string> A = split(a, '*');\n    vector<string> B = split(b, '*');\n    int i = 0;  // A's index\n    int j = 0;  // B's index\n    while (i < A.size() && j < B.size())\n      if (A[i] < B[j])\n        res += '*' + A[i++];\n      else\n        res += '*' + B[j++];\n    while (i < A.size())\n      res += '*' + A[i++];\n    while (j < B.size())\n      res += '*' + B[j++];\n    return res.substr(1);\n  }\n\n  static vector<string> split(const string& token, char c) {\n    vector<string> vars;\n    istringstream iss(token);\n    for (string var; getline(iss, var, c);)\n      vars.push_back(var);\n    return vars;\n  }\n};\n\nclass Solution {\n public:\n  vector<string> basicCalculatorIV(string expression, vector<string>& evalvars,\n                                   vector<int>& evalints) {\n    vector<string> tokens = getTokens(expression);\n    unordered_map<string, int> evalMap;\n\n    for (int i = 0; i < evalvars.size(); ++i)\n      evalMap[evalvars[i]] = evalints[i];\n\n    for (string& token : tokens)\n      if (const auto it = evalMap.find(token); it != evalMap.cend())\n        token = to_string(it->second);\n\n    const vector<string>& postfix = infixToPostfix(tokens);\n    return evaluate(postfix).toList();\n  }\n\n private:\n  vector<string> getTokens(const string& s) {\n    vector<string> tokens;\n    int i = 0;\n    for (int j = 0; j < s.length(); ++j)\n      if (s[j] == ' ') {\n        if (i < j)\n          tokens.push_back(s.substr(i, j - i));\n        i = j + 1;\n      } else if (string(\"()+-*\").find(s[j]) != string::npos) {\n        if (i < j)\n          tokens.push_back(s.substr(i, j - i));\n        tokens.push_back(s.substr(j, 1));\n        i = j + 1;\n      }\n    if (i < s.length())\n      tokens.push_back(s.substr(i));\n    return tokens;\n  }\n\n  bool isOperator(const string& token) {\n    return token == \"+\" || token == \"-\" || token == \"*\";\n  }\n\n  vector<string> infixToPostfix(const vector<string>& tokens) {\n    vector<string> postfix;\n    stack<string> ops;\n\n    auto precedes = [](const string& prevOp, const string& currOp) -> bool {\n      if (prevOp == \"(\")\n        return false;\n      return prevOp == \"*\" || currOp == \"+\" || currOp == \"-\";\n    };\n\n    for (const string& token : tokens)\n      if (token == \"(\") {\n        ops.push(token);\n      } else if (token == \")\") {\n        while (ops.top() != \"(\")\n          postfix.push_back(ops.top()), ops.pop();\n        ops.pop();\n      } else if (isOperator(token)) {\n        while (!ops.empty() && precedes(ops.top(), token))\n          postfix.push_back(ops.top()), ops.pop();\n        ops.push(token);\n      } else {  // IsOperand(token)\n        postfix.push_back(token);\n      }\n\n    while (!ops.empty())\n      postfix.push_back(ops.top()), ops.pop();\n\n    return postfix;\n  }\n\n  Poly evaluate(const vector<string>& postfix) {\n    vector<Poly> polys;\n    for (const string& token : postfix)\n      if (isOperator(token)) {\n        const Poly b = polys.back();\n        polys.pop_back();\n        const Poly a = polys.back();\n        polys.pop_back();\n        if (token == \"+\")\n          polys.push_back(a + b);\n        else if (token == \"-\")\n          polys.push_back(a - b);\n        else  // Token == \"*\"\n          polys.push_back(a * b);\n      } else if (token[0] == '-' || all_of(token.begin(), token.end(),\n                                           [](char c) { return isdigit(c); })) {\n        polys.push_back(Poly(\"1\", stoi(token)));\n      } else {\n        polys.push_back(Poly(token, 1));\n      }\n    return polys[0];\n  }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Poly {\n  public Poly add(Poly o) {\n    for (final String term : o.terms.keySet())\n      terms.merge(term, o.terms.get(term), Integer::sum);\n    return this;\n  }\n\n  public Poly minus(Poly o) {\n    for (final String term : o.terms.keySet())\n      terms.merge(term, -o.terms.get(term), Integer::sum);\n    return this;\n  }\n\n  public Poly mult(Poly o) {\n    Poly res = new Poly();\n    for (final String a : terms.keySet())\n      for (final String b : o.terms.keySet())\n        res.terms.merge(merge(a, b), terms.get(a) * o.terms.get(b), Integer::sum);\n    return res;\n  }\n\n  // @Override\n  // Public String toString() {\n  //   StringBuilder sb = new StringBuilder();\n  //   sb.append(\"{\");\n  //   for (final String term : terms.keySet())\n  //     sb.append(term).append(\": \").append(terms.get(term)).append(\", \");\n  //   sb.append(\"}\");\n  //   return sb.toString();\n  // }\n\n  public List<String> toList() {\n    List<String> res = new ArrayList<>();\n    List<String> keys = new ArrayList<>(terms.keySet());\n    Collections.sort(keys, new Comparator<String>() {\n      @Override\n      public int compare(final String a, final String b) {\n        // Smallest degree is the last\n        if (a.equals(\"1\"))\n          return 1;\n        if (b.equals(\"1\"))\n          return -1;\n        String[] as = a.split(\"\\\\*\");\n        String[] bs = b.split(\"\\\\*\");\n        // Largest degree is the first\n        // Breaking ties by lexicographic order\n        return as.length == bs.length ? a.compareTo(b) : bs.length - as.length;\n      }\n    });\n    for (final String key : keys)\n      if (terms.get(key) != 0)\n        res.add(concat(key));\n    return res;\n  }\n\n  public Poly() {}\n  public Poly(final String term, int coef) {\n    terms.put(term, coef);\n  }\n\n  private Map<String, Integer> terms = new HashMap<>();\n\n  // E.g. merge(\"a*b\", \"a*c\") -> \"a*a*b*c\"\n  private static String merge(final String a, final String b) {\n    if (a.equals(\"1\"))\n      return b;\n    if (b.equals(\"1\"))\n      return a;\n    StringBuilder sb = new StringBuilder();\n    String[] A = a.split(\"\\\\*\");\n    String[] B = b.split(\"\\\\*\");\n    int i = 0; // A's index\n    int j = 0; // B's index\n    while (i < A.length && j < B.length)\n      if (A[i].compareTo(B[j]) < 0)\n        sb.append(\"*\").append(A[i++]);\n      else\n        sb.append(\"*\").append(B[j++]);\n    while (i < A.length)\n      sb.append(\"*\").append(A[i++]);\n    while (j < B.length)\n      sb.append(\"*\").append(B[j++]);\n    return sb.substring(1).toString();\n  }\n\n  private String concat(final String term) {\n    if (term.equals(\"1\"))\n      return String.valueOf(terms.get(term));\n    return new StringBuilder().append(terms.get(term)).append('*').append(term).toString();\n  }\n}\n\nclass Solution {\n  public List<String> basicCalculatorIV(String expression, String[] evalvars, int[] evalints) {\n    List<String> tokens = getTokens(expression);\n    Map<String, Integer> evalMap = new HashMap<>();\n\n    for (int i = 0; i < evalvars.length; ++i)\n      evalMap.put(evalvars[i], evalints[i]);\n\n    for (int i = 0; i < tokens.size(); ++i)\n      if (evalMap.containsKey(tokens.get(i)))\n        tokens.set(i, String.valueOf(evalMap.get(tokens.get(i))));\n\n    List<String> postfix = infixToPostfix(tokens);\n    return evaluate(postfix).toList();\n  }\n\n  private List<String> getTokens(final String s) {\n    List<String> tokens = new ArrayList<>();\n    int i = 0;\n    for (int j = 0; j < s.length(); ++j)\n      if (s.charAt(j) == ' ') {\n        if (i < j)\n          tokens.add(s.substring(i, j));\n        i = j + 1;\n      } else if (\"()+-*\".contains(s.substring(j, j + 1))) {\n        if (i < j)\n          tokens.add(s.substring(i, j));\n        tokens.add(s.substring(j, j + 1));\n        i = j + 1;\n      }\n    if (i < s.length())\n      tokens.add(s.substring(i));\n    return tokens;\n  }\n\n  private boolean isOperator(final String token) {\n    return token.equals(\"+\") || token.equals(\"-\") || token.equals(\"*\");\n  }\n\n  private boolean precedes(final String prevOp, final String currOp) {\n    if (prevOp.equals(\"(\"))\n      return false;\n    return prevOp.equals(\"*\") || currOp.equals(\"+\") || currOp.equals(\"-\");\n  }\n\n  private List<String> infixToPostfix(List<String> tokens) {\n    List<String> postfix = new ArrayList<>();\n    Deque<String> ops = new ArrayDeque<>();\n\n    for (final String token : tokens)\n      if (token.equals(\"(\")) {\n        ops.push(token);\n      } else if (token.equals(\")\")) {\n        while (!ops.peek().equals(\"(\"))\n          postfix.add(ops.pop());\n        ops.pop();\n      } else if (isOperator(token)) {\n        while (!ops.isEmpty() && precedes(ops.peek(), token))\n          postfix.add(ops.pop());\n        ops.push(token);\n      } else { // IsOperand(token)\n        postfix.add(token);\n      }\n\n    while (!ops.isEmpty())\n      postfix.add(ops.pop());\n\n    return postfix;\n  }\n\n  private Poly evaluate(List<String> postfix) {\n    LinkedList<Poly> polys = new LinkedList<>();\n    for (final String token : postfix)\n      if (isOperator(token)) {\n        final Poly b = polys.removeLast();\n        final Poly a = polys.removeLast();\n        if (token.equals(\"+\"))\n          polys.add(a.add(b));\n        else if (token.equals(\"-\"))\n          polys.add(a.minus(b));\n        else // Token == \"*\"\n          polys.add(a.mult(b));\n      } else if (token.charAt(0) == '-' || token.chars().allMatch(c -> Character.isDigit(c))) {\n        polys.add(new Poly(\"1\", Integer.parseInt(token)));\n      } else {\n        polys.add(new Poly(token, 1));\n      }\n    return polys.getFirst();\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  # Def __str__(self):\n  #   res = []\n  #   for term, coef in self.terms.items():\n  #     res.append(term + ': ' + str(coef))\n  #   return '{' + ', '.join(res) + '}'\n\n  def toList(self) -> List[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      # Smallest degree is the last\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      # Largest degree is the first\n      # Breaking ties by lexicographic order\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0  # A's index\n    j = 0  # B's index\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: List[str]) -> List[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':  # IsOperator(token)\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:  # IsOperand(token)\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: List[str]) -> Poly:\n    polys: List[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:  # Token == '*'\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]\n",
                "lang_text": "py"
            }
        }
    }
}