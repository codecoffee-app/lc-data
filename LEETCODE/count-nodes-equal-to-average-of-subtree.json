{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "2265",
            "title": "Count Nodes Equal to Average of Subtree",
            "titleSlug": "count-nodes-equal-to-average-of-subtree",
            "content": "<p>Given the <code>root</code> of a binary tree, return <em>the number of nodes where the value of the node is equal to the <strong>average</strong> of the values in its <strong>subtree</strong></em>.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>The <strong>average</strong> of <code>n</code> elements is the <strong>sum</strong> of the <code>n</code> elements divided by <code>n</code> and <strong>rounded down</strong> to the nearest integer.</li>\n\t<li>A <strong>subtree</strong> of <code>root</code> is a tree consisting of <code>root</code> and all of its descendants.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/03/15/image-20220315203925-1.png\" style=\"width: 300px; height: 212px;\" />\n<pre>\n<strong>Input:</strong> root = [4,8,5,0,1,null,6]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> \nFor the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.\nFor the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.\nFor the node with value 0: The average of its subtree is 0 / 1 = 0.\nFor the node with value 1: The average of its subtree is 1 / 1 = 1.\nFor the node with value 6: The average of its subtree is 6 / 1 = 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/03/26/image-20220326133920-1.png\" style=\"width: 80px; height: 76px;\" />\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> For the node with value 1: The average of its subtree is 1 / 1 = 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 2048,
            "dislikes": 40,
            "similarQuestions": "[{\"title\": \"Maximum Average Subtree\", \"titleSlug\": \"maximum-average-subtree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Insufficient Nodes in Root to Leaf Paths\", \"titleSlug\": \"insufficient-nodes-in-root-to-leaf-paths\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Nodes Equal to Sum of Descendants\", \"titleSlug\": \"count-nodes-equal-to-sum-of-descendants\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Tree",
                    "slug": "tree"
                },
                {
                    "name": "Depth-First Search",
                    "slug": "depth-first-search"
                },
                {
                    "name": "Binary Tree",
                    "slug": "binary-tree"
                }
            ],
            "stats": "{\"totalAccepted\": \"123K\", \"totalSubmission\": \"141.7K\", \"totalAcceptedRaw\": 123017, \"totalSubmissionRaw\": 141742, \"acRate\": \"86.8%\"}",
            "hints": [
                "What information do we need to calculate the average? We need the sum of the values and the number of values.",
                "Create a recursive function that returns the size of a node\u2019s subtree, and the sum of the values of its subtree."
            ],
            "rephrased": {
                "body": "Given the root of a binary tree, determine the number of nodes where the node's value equals the average of the values in its subtree.  The average of a subtree is calculated by summing all node values within the subtree and dividing by the total number of nodes in the subtree. The result is then rounded down to the nearest integer. A subtree consists of the root node and all its descendants.",
                "constraints": [
                    "The number of nodes in the tree is in the range [1, 1000].",
                    "0 <= Node.val <= 1000"
                ],
                "testcases": [
                    {
                        "input": "[4,8,5,0,1,null,6]",
                        "output": "5",
                        "explanation": "The node with value 4 has a subtree average of (4 + 8 + 5 + 0 + 1 + 6) / 6 = 4.  The node with value 5 has a subtree average of (5 + 6) / 2 = 5. The node with value 0 has a subtree average of 0 / 1 = 0. The node with value 1 has a subtree average of 1 / 1 = 1. The node with value 6 has a subtree average of 6 / 1 = 6. Therefore, 5 nodes have a value equal to their subtree's average."
                    },
                    {
                        "input": "[1]",
                        "output": "1",
                        "explanation": "The node with value 1 has a subtree average of 1 / 1 = 1. Thus, 1 node has a value equal to its subtree's average."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Medium",
                "titleSlug": "maximum-average-subtree",
                "title": "Maximum Average Subtree",
                "isPaidOnly": true
            },
            {
                "difficulty": "Medium",
                "titleSlug": "insufficient-nodes-in-root-to-leaf-paths",
                "title": "Insufficient Nodes in Root to Leaf Paths",
                "isPaidOnly": false
            },
            {
                "difficulty": "Medium",
                "titleSlug": "count-nodes-equal-to-sum-of-descendants",
                "title": "Count Nodes Equal to Sum of Descendants",
                "isPaidOnly": true
            }
        ],
        "hints": [
            "What information do we need to calculate the average? We need the sum of the values and the number of values.",
            "Create a recursive function that returns the size of a node\u2019s subtree, and the sum of the values of its subtree."
        ],
        "relatedTopics": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-First Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Binary Tree",
                "slug": "binary-tree"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\n public:\n  int averageOfSubtree(TreeNode* root) {\n    int ans = 0;\n    dfs(root, ans);\n    return ans;\n  }\n\n private:\n  pair<int, int> dfs(TreeNode* root, int& ans) {\n    if (root == nullptr)\n      return {0, 0};\n    const auto [leftSum, leftCount] = dfs(root->left, ans);\n    const auto [rightSum, rightCount] = dfs(root->right, ans);\n    const int sum = root->val + leftSum + rightSum;\n    const int count = 1 + leftCount + rightCount;\n    if (sum / count == root->val)\n      ++ans;\n    return {sum, count};\n  }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n  public int averageOfSubtree(TreeNode root) {\n    dfs(root);\n    return ans;\n  }\n\n  private int ans = 0;\n\n  private Pair<Integer, Integer> dfs(TreeNode root) {\n    if (root == null)\n      return new Pair<>(0, 0);\n    Pair<Integer, Integer> left = dfs(root.left);\n    Pair<Integer, Integer> right = dfs(root.right);\n    final int sum = root.val + left.getKey() + right.getKey();\n    final int count = 1 + left.getValue() + right.getValue();\n    if (sum / count == root.val)\n      ++ans;\n    return new Pair<>(sum, count);\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Solution:\n  def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\n    ans = 0\n\n    def dfs(root: Optional[TreeNode]) -> Tuple[int, int]:\n      nonlocal ans\n      if not root:\n        return (0, 0)\n      leftSum, leftCount = dfs(root.left)\n      rightSum, rightCount = dfs(root.right)\n      summ = root.val + leftSum + rightSum\n      count = 1 + leftCount + rightCount\n      if summ // count == root.val:\n        ans += 1\n      return (summ, count)\n\n    dfs(root)\n    return ans\n",
                "lang_text": "py"
            }
        }
    }
}