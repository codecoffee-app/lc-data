{
    "failed": false,
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "3015",
            "title": "Count the Number of Houses at a Certain Distance I",
            "titleSlug": "count-the-number-of-houses-at-a-certain-distance-i",
            "content": "<p>You are given three <strong>positive</strong> integers <code>n</code>, <code>x</code>, and <code>y</code>.</p>\n\n<p>In a city, there exist houses numbered <code>1</code> to <code>n</code> connected by <code>n</code> streets. There is a street connecting the house numbered <code>i</code> with the house numbered <code>i + 1</code> for all <code>1 &lt;= i &lt;= n - 1</code> . An additional street connects the house numbered <code>x</code> with the house numbered <code>y</code>.</p>\n\n<p>For each <code>k</code>, such that <code>1 &lt;= k &lt;= n</code>, you need to find the number of <strong>pairs of houses</strong> <code>(house<sub>1</sub>, house<sub>2</sub>)</code> such that the <strong>minimum</strong> number of streets that need to be traveled to reach <code>house<sub>2</sub></code> from <code>house<sub>1</sub></code> is <code>k</code>.</p>\n\n<p>Return <em>a <strong>1-indexed</strong> array </em><code>result</code><em> of length </em><code>n</code><em> where </em><code>result[k]</code><em> represents the <strong>total</strong> number of pairs of houses such that the <strong>minimum</strong> streets required to reach one house from the other is </em><code>k</code>.</p>\n\n<p><strong>Note</strong> that <code>x</code> and <code>y</code> can be <strong>equal</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/20/example2.png\" style=\"width: 474px; height: 197px;\" />\n<pre>\n<strong>Input:</strong> n = 3, x = 1, y = 3\n<strong>Output:</strong> [6,0,0]\n<strong>Explanation:</strong> Let&#39;s look at each pair of houses:\n- For the pair (1, 2), we can go from house 1 to house 2 directly.\n- For the pair (2, 1), we can go from house 2 to house 1 directly.\n- For the pair (1, 3), we can go from house 1 to house 3 directly.\n- For the pair (3, 1), we can go from house 3 to house 1 directly.\n- For the pair (2, 3), we can go from house 2 to house 3 directly.\n- For the pair (3, 2), we can go from house 3 to house 2 directly.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/20/example3.png\" style=\"width: 668px; height: 174px;\" />\n<pre>\n<strong>Input:</strong> n = 5, x = 2, y = 4\n<strong>Output:</strong> [10,8,2,0,0]\n<strong>Explanation:</strong> For each distance k the pairs are:\n- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4).\n- For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3).\n- For k == 3, the pairs are (1, 5), and (5, 1).\n- For k == 4 and k == 5, there are no pairs.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/20/example5.png\" style=\"width: 544px; height: 130px;\" />\n<pre>\n<strong>Input:</strong> n = 4, x = 1, y = 1\n<strong>Output:</strong> [6,4,2,0]\n<strong>Explanation:</strong> For each distance k the pairs are:\n- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3).\n- For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2).\n- For k == 3, the pairs are (1, 4), and (4, 1).\n- For k == 4, there are no pairs.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= x, y &lt;= n</code></li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 135,
            "dislikes": 29,
            "similarQuestions": "[{\"title\": \"Walls and Gates\", \"titleSlug\": \"walls-and-gates\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Breadth-First Search",
                    "slug": "breadth-first-search"
                },
                {
                    "name": "Graph",
                    "slug": "graph"
                },
                {
                    "name": "Prefix Sum",
                    "slug": "prefix-sum"
                }
            ],
            "stats": "{\"totalAccepted\": \"17.8K\", \"totalSubmission\": \"32.1K\", \"totalAcceptedRaw\": 17816, \"totalSubmissionRaw\": 32128, \"acRate\": \"55.5%\"}",
            "hints": [
                "Start from each house, run a BFS to get all the distances from this house to all the other houses."
            ],
            "rephrased": {
                "body": "Given three positive integers `n`, `x`, and `y`, imagine a city with houses numbered from 1 to `n`. These houses are connected by `n` streets.  Street `i` connects house `i` to house `i + 1` for all `1 <= i <= n - 1`.  Additionally, there's a street directly connecting house `x` and house `y`. Your task is to determine, for each distance `k` (where `1 <= k <= n`), the number of house pairs `(house1, house2)` such that the shortest path between `house1` and `house2` requires exactly `k` streets.  Return a 1-indexed array `result` of length `n`, where `result[k]` represents the total number of house pairs with a shortest path of length `k`.",
                "constraints": [
                    "2 <= n <= 100",
                    "1 <= x, y <= n"
                ],
                "testcases": [
                    {
                        "input": "n = 3, x = 1, y = 3",
                        "output": "[6,0,0]",
                        "explanation": "For k = 1, the pairs are (1, 2), (2, 1), (1, 3), (3, 1), (2, 3), and (3, 2). Therefore result[1] = 6. For k = 2 and k = 3, no such pairs exist, so result[2] = 0 and result[3] = 0."
                    },
                    {
                        "input": "n = 5, x = 2, y = 4",
                        "output": "[10,8,2,0,0]",
                        "explanation": "For k = 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4). Therefore result[1] = 10.\nFor k = 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3). Therefore result[2] = 8.\nFor k = 3, the pairs are (1, 5), and (5, 1). Therefore result[3] = 2.\nFor k = 4 and k = 5, no such pairs exist, so result[4] = 0 and result[5] = 0."
                    },
                    {
                        "input": "n = 4, x = 1, y = 1",
                        "output": "[6,4,2,0]",
                        "explanation": "For k = 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3). Therefore result[1] = 6.\nFor k = 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2). Therefore result[2] = 4.\nFor k = 3, the pairs are (1, 4), and (4, 1). Therefore result[3] = 2.\nFor k = 4, there are no pairs, so result[4] = 0."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Medium",
                "titleSlug": "walls-and-gates",
                "title": "Walls and Gates",
                "isPaidOnly": true
            }
        ],
        "hints": [
            "Start from each house, run a BFS to get all the distances from this house to all the other houses."
        ],
        "relatedTopics": [
            {
                "name": "Breadth-First Search",
                "slug": "breadth-first-search"
            },
            {
                "name": "Graph",
                "slug": "graph"
            },
            {
                "name": "Prefix Sum",
                "slug": "prefix-sum"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\n public:\n  vector<int> countOfPairs(int n, int x, int y) {\n    if (x > y)\n      swap(x, y);\n\n    const int ringLen = y - x + 1;\n    const int leftLineLen = x - 1;\n    const int rightLineLen = n - y;\n\n    vector<int> ans(n);\n    ans = addVectors(ans, bothInRing(n, ringLen));\n    ans = addVectors(ans, bothInTheSameLine(n, leftLineLen));\n    ans = addVectors(ans, bothInTheSameLine(n, rightLineLen));\n    ans = addVectors(ans, lineToRing(n, leftLineLen, ringLen));\n    ans = addVectors(ans, lineToRing(n, rightLineLen, ringLen));\n    ans = addVectors(ans, lineToLine(n, x, y, leftLineLen, rightLineLen));\n    for (int& freq : ans)\n      freq *= 2;\n    return ans;\n  }\n\n private:\n  // Returns the contribution from the scenario where two houses are located in\n  // the ring.\n  vector<int> bothInRing(int n, int ringLen) {\n    vector<int> res(n);\n    for (int k = 1; k <= (ringLen - 1) / 2; ++k)\n      res[k - 1] += ringLen;\n    if (ringLen % 2 == 0)\n      res[ringLen / 2 - 1] += ringLen / 2;\n    return res;\n  }\n\n  // Returns the contribution from the scenario where two houses are either\n  // located in the left line [1, x) or the right line (y, n].\n  vector<int> bothInTheSameLine(int n, int lineLen) {\n    vector<int> res(n);\n    for (int k = 1; k <= lineLen; ++k)\n      res[k - 1] += lineLen - k;\n    return res;\n  }\n\n  // Returns the contribution from the scenario where one house is either\n  // located in the left line [1, x) or the right line (y, n] and the other\n  // house is located in the cycle.\n  vector<int> lineToRing(int n, int lineLen, int ringLen) {\n    vector<int> res(n);\n    for (int k = 1; k <= lineLen + ringLen; ++k) {\n      // min(\n      //   at most k - 1 since we need to give 1 to the line,\n      //   at most ringLen / 2 since for length > ringLen / 2, it can always be\n      //     calculated as ringLen - ringLen / 2\n      // )\n      const int maxInRingLen = min(k - 1, ringLen / 2);\n      // max(at least 0, at lest k - lineLen)\n      const int minInRingLen = max(0, k - lineLen);\n      if (minInRingLen <= maxInRingLen) {\n        // Each ring length contributes 2 to the count due to the split of\n        // paths when entering the ring: One path traverses the upper half of\n        // the ring, and the other traverses the lower half.\n        // This is illustrated as follows:\n        //   Path 1: ... -- x -- (upper half of the ring)\n        //   Path 2: ... -- x -- (lower half of the ring)\n        res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2;\n        if (minInRingLen == 0)\n          // Subtract 1 since there's no split.\n          res[k - 1] -= 1;\n        if (maxInRingLen * 2 == ringLen)\n          // Subtract 1 since the following case only contribute one:\n          //   ... -- x -- (upper half of the ring) -- middle point\n          //   ... -- x -- (upper half of the ring) -- middle point\n          res[k - 1] -= 1;\n      }\n    }\n    return res;\n  }\n\n  // Returns the contribution from the scenario where one house is in the left\n  // line [1, x) and the other house is in the right line (y, n].\n  vector<int> lineToLine(int n, int x, int y, int leftLineLen,\n                         int rightLineLen) {\n    vector<int> res(n);\n    for (int k = 1; k <= leftLineLen + rightLineLen + 2; ++k) {\n      // min(\n      //   at most leftLineLen,\n      //   at most k - 1 - (x < y) since we need to give 1 to the right line\n      //     and if x < y we need to give another 1 to \"x - y\".\n      // )\n      const int maxInLeft = min(leftLineLen, k - 1 - (x < y));\n      // max(at least 1, at least k - rightLineLen - (x < y))\n      const int minInLeft = max(1, k - rightLineLen - (x < y));\n      if (minInLeft <= maxInLeft)\n        res[k - 1] += maxInLeft - minInLeft + 1;\n    }\n    return res;\n  }\n\n  vector<int> addVectors(const vector<int>& a, const vector<int>& b) {\n    vector<int> res(a.size());\n    transform(a.begin(), a.end(), b.begin(), res.begin(), plus<int>());\n    return res;\n  };\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n  public int[] countOfPairs(int n, int x, int y) {\n    if (x > y) {\n      final int temp = x;\n      x = y;\n      y = temp;\n    }\n\n    final int ringLen = y - x + 1;\n    final int leftLineLen = x - 1;\n    final int rightLineLen = n - y;\n\n    int[] ans = new int[n];\n    ans = addVectors(ans, bothInRing(n, ringLen));\n    ans = addVectors(ans, bothInTheSameLine(n, leftLineLen));\n    ans = addVectors(ans, bothInTheSameLine(n, rightLineLen));\n    ans = addVectors(ans, lineToRing(n, leftLineLen, ringLen));\n    ans = addVectors(ans, lineToRing(n, rightLineLen, ringLen));\n    ans = addVectors(ans, lineToLine(n, x, y, leftLineLen, rightLineLen));\n    for (int i = 0; i < ans.length; ++i)\n      ans[i] *= 2;\n    return ans;\n  }\n\n  // Returns the contribution from the scenario where two houses are located in\n  // the ring.\n  private int[] bothInRing(int n, int ringLen) {\n    int[] res = new int[n];\n    for (int k = 1; k <= (ringLen - 1) / 2; ++k)\n      res[k - 1] += ringLen;\n    if (ringLen % 2 == 0)\n      res[ringLen / 2 - 1] += ringLen / 2;\n    return res;\n  }\n\n  // Returns the contribution from the scenario where two houses are either\n  // located in the left line [1, x) or the right line (y, n].\n  private int[] bothInTheSameLine(int n, int lineLen) {\n    int[] res = new int[n];\n    for (int k = 1; k <= lineLen; ++k)\n      res[k - 1] += lineLen - k;\n    return res;\n  }\n\n  // Returns the contribution from the scenario where one house is either\n  // located in the left line [1, x) or the right line (y, n] and the other\n  // house is located in the cycle.\n  private int[] lineToRing(int n, int lineLen, int ringLen) {\n    int[] res = new int[n];\n    for (int k = 1; k <= lineLen + ringLen; ++k) {\n      // min(\n      //   at most k - 1 since we need to give 1 to the line,\n      //   at most ringLen / 2 since for length > ringLen / 2, it can always be\n      //     calculated as ringLen - ringLen / 2\n      // )\n      final int maxInRingLen = Math.min(k - 1, ringLen / 2);\n      // max(at least 0, at lest k - lineLen)\n      final int minInRingLen = Math.max(0, k - lineLen);\n      if (minInRingLen <= maxInRingLen) {\n        // Each ring length contributes 2 to the count due to the split of\n        // paths when entering the ring: One path traverses the upper half of\n        // the ring, and the other traverses the lower half.\n        // This is illustrated as follows:\n        //   Path 1: ... -- x -- (upper half of the ring)\n        //   Path 2: ... -- x -- (lower half of the ring)\n        res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2;\n        if (minInRingLen == 0)\n          // Subtract 1 since there's no split.\n          res[k - 1] -= 1;\n        if (maxInRingLen * 2 == ringLen)\n          // Subtract 1 since the following case only contribute one:\n          //   ... -- x -- (upper half of the ring) -- middle point\n          //   ... -- x -- (upper half of the ring) -- middle point\n          res[k - 1] -= 1;\n      }\n    }\n    return res;\n  }\n\n  // Returns the contribution from the scenario where one house is in the left\n  // line [1, x) and the other house is in the right line (y, n].\n  private int[] lineToLine(int n, int x, int y, int leftLineLen, int rightLineLen) {\n    int[] res = new int[n];\n    for (int k = 1; k <= leftLineLen + rightLineLen + 2; ++k) {\n      // min(\n      //   at most leftLineLen,\n      //   at most k - 1 - (x < y) since we need to give 1 to the right line\n      //     and if x < y we need to give another 1 to \"x - y\".\n      // )\n      final int maxInLeft = Math.min(leftLineLen, k - 1 - (x < y ? 1 : 0));\n      // max(at least 1, at least k - rightLineLen - (x < y))\n      final int minInLeft = Math.max(1, k - rightLineLen - (x < y ? 1 : 0));\n      if (minInLeft <= maxInLeft)\n        res[k - 1] += maxInLeft - minInLeft + 1;\n    }\n    return res;\n  }\n\n  private int[] addVectors(int[] a, int[] b) {\n    for (int i = 0; i < a.length; ++i)\n      a[i] += b[i];\n    return a;\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Solution:\n  def countOfPairs(self, n: int, x: int, y: int) -> List[int]:\n    if x > y:\n      x, y = y, x\n\n    def bothInRing(ringLen: int) -> List[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are located\n      in the ring.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, (ringLen - 1) // 2 + 1):\n        res[k - 1] += ringLen\n      if ringLen % 2 == 0:\n        res[ringLen // 2 - 1] += ringLen // 2\n      return res\n\n    def bothInTheSameLine(lineLen: int) -> List[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are either\n      located in the left line [1, x) or the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + 1):\n        res[k - 1] += lineLen - k\n      return res\n\n    def lineToRing(lineLen: int, ringLen: int) -> List[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is either\n      located in the left line [1, x) or the right line (y, n] and the\n      other house is located in the cycle.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + ringLen):\n        # min(\n        #   at most k - 1 since we need to give 1 to the line,\n        #   at most ringLen / 2 since for length > ringLen / 2, it can always be\n        #     calculated as ringLen - ringLen / 2\n        # )\n        maxInRingLen = min(k - 1, ringLen // 2)\n        # max(at least 0, at lest k - lineLen)\n        minInRingLen = max(0, k - lineLen)\n        if minInRingLen <= maxInRingLen:\n          # Each ring length contributes 2 to the count due to the split of\n          # paths when entering the ring: One path traverses the upper half of\n          # the ring, and the other traverses the lower half.\n          # This is illustrated as follows:\n          #   Path 1: ... -- x -- (upper half of the ring)\n          #   Path 2: ... -- x -- (lower half of the ring)\n          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2\n          if minInRingLen == 0:\n            # Subtract 1 since there's no split.\n            res[k - 1] -= 1\n          if maxInRingLen * 2 == ringLen:\n            # Subtract 1 since the following case only contribute one:\n            #   ... -- x -- (upper half of the ring) -- middle point\n            #   ... -- x -- (upper half of the ring) -- middle point\n            res[k - 1] -= 1\n      return res\n\n    def lineToLine(leftLineLen: int, rightLineLen: int) -> List[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is in the left\n      line [1, x) and the other house is in the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(leftLineLen + rightLineLen + 2):\n        # min(\n        #   at most leftLineLen,\n        #   at most k - 1 - (x < y) since we need to give 1 to the right line\n        #     and if x < y we need to give another 1 to \"x - y\".\n        # )\n        maxInLeft = min(leftLineLen, k - 1 - (x < y))\n        # max(at least 1, at least k - rightLineLen - (x < y))\n        minInLeft = max(1, k - rightLineLen - (x < y))\n        if minInLeft <= maxInLeft:\n          res[k - 1] += maxInLeft - minInLeft + 1\n      return res\n\n    ringLen = y - x + 1\n    leftLineLen = x - 1\n    rightLineLen = (n - y)\n\n    ans = [0] * n\n    ans = list(map(operator.add, ans, bothInRing(ringLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))\n    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))\n    return [freq * 2 for freq in ans]\n",
                "lang_text": "py"
            }
        }
    }
}