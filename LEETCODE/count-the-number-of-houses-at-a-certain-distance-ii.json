{
    "failed": false,
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "3017",
            "title": "Count the Number of Houses at a Certain Distance II",
            "titleSlug": "count-the-number-of-houses-at-a-certain-distance-ii",
            "content": "<p>You are given three <strong>positive</strong> integers <code>n</code>, <code>x</code>, and <code>y</code>.</p>\n\n<p>In a city, there exist houses numbered <code>1</code> to <code>n</code> connected by <code>n</code> streets. There is a street connecting the house numbered <code>i</code> with the house numbered <code>i + 1</code> for all <code>1 &lt;= i &lt;= n - 1</code> . An additional street connects the house numbered <code>x</code> with the house numbered <code>y</code>.</p>\n\n<p>For each <code>k</code>, such that <code>1 &lt;= k &lt;= n</code>, you need to find the number of <strong>pairs of houses</strong> <code>(house<sub>1</sub>, house<sub>2</sub>)</code> such that the <strong>minimum</strong> number of streets that need to be traveled to reach <code>house<sub>2</sub></code> from <code>house<sub>1</sub></code> is <code>k</code>.</p>\n\n<p>Return <em>a <strong>1-indexed</strong> array </em><code>result</code><em> of length </em><code>n</code><em> where </em><code>result[k]</code><em> represents the <strong>total</strong> number of pairs of houses such that the <strong>minimum</strong> streets required to reach one house from the other is </em><code>k</code>.</p>\n\n<p><strong>Note</strong> that <code>x</code> and <code>y</code> can be <strong>equal</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/20/example2.png\" style=\"width: 474px; height: 197px;\" />\n<pre>\n<strong>Input:</strong> n = 3, x = 1, y = 3\n<strong>Output:</strong> [6,0,0]\n<strong>Explanation:</strong> Let&#39;s look at each pair of houses:\n- For the pair (1, 2), we can go from house 1 to house 2 directly.\n- For the pair (2, 1), we can go from house 2 to house 1 directly.\n- For the pair (1, 3), we can go from house 1 to house 3 directly.\n- For the pair (3, 1), we can go from house 3 to house 1 directly.\n- For the pair (2, 3), we can go from house 2 to house 3 directly.\n- For the pair (3, 2), we can go from house 3 to house 2 directly.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/20/example3.png\" style=\"width: 668px; height: 174px;\" />\n<pre>\n<strong>Input:</strong> n = 5, x = 2, y = 4\n<strong>Output:</strong> [10,8,2,0,0]\n<strong>Explanation:</strong> For each distance k the pairs are:\n- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4).\n- For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3).\n- For k == 3, the pairs are (1, 5), and (5, 1).\n- For k == 4 and k == 5, there are no pairs.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/20/example5.png\" style=\"width: 544px; height: 130px;\" />\n<pre>\n<strong>Input:</strong> n = 4, x = 1, y = 1\n<strong>Output:</strong> [6,4,2,0]\n<strong>Explanation:</strong> For each distance k the pairs are:\n- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3).\n- For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2).\n- For k == 3, the pairs are (1, 4), and (4, 1).\n- For k == 4, there are no pairs.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= x, y &lt;= n</code></li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 77,
            "dislikes": 22,
            "similarQuestions": "[{\"title\": \"Walls and Gates\", \"titleSlug\": \"walls-and-gates\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Graph",
                    "slug": "graph"
                },
                {
                    "name": "Prefix Sum",
                    "slug": "prefix-sum"
                }
            ],
            "stats": "{\"totalAccepted\": \"2.7K\", \"totalSubmission\": \"12.8K\", \"totalAcceptedRaw\": 2736, \"totalSubmissionRaw\": 12842, \"acRate\": \"21.3%\"}",
            "hints": [
                "If there were no additional street connecting house <code>x</code> to house <code>y</code>, there would be <code>2 * (n - i)</code> pairs of houses at distance <code>i</code>.",
                "The shortest distance between house <code>i</code> and house <code>j</code> (<code>j < i</code>) is along one of these paths:\r\n- <code>i -> j</code>\r\n- <code>i -> y---x -> j</code>",
                "Try to change the distances calculated by path <code>i ->j</code> to the other path.",
                "Can we use prefix sums to compute the answer?"
            ],
            "rephrased": {
                "body": "Given three positive integers `n`, `x`, and `y`, imagine a city with houses numbered from 1 to `n`.  These houses are connected by streets such that house `i` is connected to house `i+1` for all `1 <= i <= n-1`.  Additionally, there's a street directly connecting house `x` to house `y`.  Your task is to determine, for each possible distance `k` (where `1 <= k <= n-1`), how many pairs of houses `(house1, house2)` have a minimum street distance of exactly `k` between them.  Return a 1-indexed array `result` of length `n-1` where `result[k]` represents the number of house pairs with a minimum street distance of `k`. Note that `x` and `y` can be equal.",
                "constraints": [
                    "2 <= n <= 10^5",
                    "1 <= x, y <= n"
                ],
                "testcases": [
                    {
                        "input": "n = 3, x = 1, y = 3",
                        "output": "[6,0,0]",
                        "explanation": "The shortest path distances are:\n- Distance between (1,2) and (2,1) is 1.\n- Distance between (1,3) and (3,1) is 1.\n- Distance between (2,3) and (3,2) is 1.\nTherefore, there are 6 pairs with a distance of 1, and 0 pairs for distances 2 and 3."
                    },
                    {
                        "input": "n = 5, x = 2, y = 4",
                        "output": "[10,8,2,0,0]",
                        "explanation": "The shortest path distances result in:\n- 10 pairs with distance 1.\n- 8 pairs with distance 2.\n- 2 pairs with distance 3.\n- 0 pairs with distance 4 and 5."
                    },
                    {
                        "input": "n = 4, x = 1, y = 1",
                        "output": "[6,4,2,0]",
                        "explanation": "The shortest path distances are:\n- Distance between (1,2) and (2,1) is 1.\n- Distance between (2,3) and (3,2) is 1.\n- Distance between (3,4) and (4,3) is 1.\n- Distance between (1,3) and (3,1) is 2.\n- Distance between (2,4) and (4,2) is 2.\n- Distance between (1,4) and (4,1) is 3."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Medium",
                "titleSlug": "walls-and-gates",
                "title": "Walls and Gates",
                "isPaidOnly": true
            }
        ],
        "hints": [
            "If there were no additional street connecting house <code>x</code> to house <code>y</code>, there would be <code>2 * (n - i)</code> pairs of houses at distance <code>i</code>.",
            "The shortest distance between house <code>i</code> and house <code>j</code> (<code>j < i</code>) is along one of these paths:\r\n- <code>i -> j</code>\r\n- <code>i -> y---x -> j</code>",
            "Try to change the distances calculated by path <code>i ->j</code> to the other path.",
            "Can we use prefix sums to compute the answer?"
        ],
        "relatedTopics": [
            {
                "name": "Graph",
                "slug": "graph"
            },
            {
                "name": "Prefix Sum",
                "slug": "prefix-sum"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\n public:\n  // Same as 3015. Count the Number of Houses at a Certain Distance I\n  vector<long long> countOfPairs(int n, int x, int y) {\n    if (x > y)\n      swap(x, y);\n\n    const int ringLen = y - x + 1;\n    const int leftLineLen = x - 1;\n    const int rightLineLen = n - y;\n\n    vector<long long> ans(n);\n    ans = addVectors(ans, bothInRing(n, ringLen));\n    ans = addVectors(ans, bothInTheSameLine(n, leftLineLen));\n    ans = addVectors(ans, bothInTheSameLine(n, rightLineLen));\n    ans = addVectors(ans, lineToRing(n, leftLineLen, ringLen));\n    ans = addVectors(ans, lineToRing(n, rightLineLen, ringLen));\n    ans = addVectors(ans, lineToLine(n, x, y, leftLineLen, rightLineLen));\n    for (long long& freq : ans)\n      freq *= 2;\n    return ans;\n  }\n\n private:\n  // Returns the contribution from the scenario where two houses are located in\n  // the ring.\n  vector<long long> bothInRing(int n, int ringLen) {\n    vector<long long> res(n);\n    for (int k = 1; k <= (ringLen - 1) / 2; ++k)\n      res[k - 1] += ringLen;\n    if (ringLen % 2 == 0)\n      res[ringLen / 2 - 1] += ringLen / 2;\n    return res;\n  }\n\n  // Returns the contribution from the scenario where two houses are either\n  // located in the left line [1, x) or the right line (y, n].\n  vector<long long> bothInTheSameLine(int n, int lineLen) {\n    vector<long long> res(n);\n    for (int k = 1; k <= lineLen; ++k)\n      res[k - 1] += lineLen - k;\n    return res;\n  }\n\n  // Returns the contribution from the scenario where one house is either\n  // located in the left line [1, x) or the right line (y, n] and the other\n  // house is located in the cycle.\n  vector<long long> lineToRing(int n, int lineLen, int ringLen) {\n    vector<long long> res(n);\n    for (int k = 1; k <= lineLen + ringLen; ++k) {\n      // min(\n      //   at most k - 1 since we need to give 1 to the line,\n      //   at most ringLen / 2 since for length > ringLen / 2, it can always be\n      //     calculated as ringLen - ringLen / 2\n      // )\n      const int maxInRingLen = min(k - 1, ringLen / 2);\n      // max(at least 0, at lest k - lineLen)\n      const int minInRingLen = max(0, k - lineLen);\n      if (minInRingLen <= maxInRingLen) {\n        // Each ring length contributes 2 to the count due to the split of\n        // paths when entering the ring: One path traverses the upper half of\n        // the ring, and the other traverses the lower half.\n        // This is illustrated as follows:\n        //   Path 1: ... -- x -- (upper half of the ring)\n        //   Path 2: ... -- x -- (lower half of the ring)\n        res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2;\n        if (minInRingLen == 0)\n          // Subtract 1 since there's no split.\n          res[k - 1] -= 1;\n        if (maxInRingLen * 2 == ringLen)\n          // Subtract 1 since the following case only contribute one:\n          //   ... -- x -- (upper half of the ring) -- middle point\n          //   ... -- x -- (upper half of the ring) -- middle point\n          res[k - 1] -= 1;\n      }\n    }\n    return res;\n  }\n\n  // Returns the contribution from the scenario where one house is in the left\n  // line [1, x) and the other house is in the right line (y, n].\n  vector<long long> lineToLine(int n, int x, int y, int leftLineLen,\n                               int rightLineLen) {\n    vector<long long> res(n);\n    for (int k = 1; k <= leftLineLen + rightLineLen + 2; ++k) {\n      // min(\n      //   at most leftLineLen,\n      //   at most k - 1 - (x < y) since we need to give 1 to the right line\n      //     and if x < y we need to give another 1 to \"x - y\".\n      // )\n      const int maxInLeft = min(leftLineLen, k - 1 - (x < y));\n      // max(at least 1, at least k - rightLineLen - (x < y))\n      const int minInLeft = max(1, k - rightLineLen - (x < y));\n      if (minInLeft <= maxInLeft)\n        res[k - 1] += maxInLeft - minInLeft + 1;\n    }\n    return res;\n  }\n\n  vector<long long> addVectors(const vector<long long>& a,\n                               const vector<long long>& b) {\n    vector<long long> res(a.size());\n    transform(a.begin(), a.end(), b.begin(), res.begin(), plus<int>());\n    return res;\n  };\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n  // Same as 3015. Count the Number of Houses at a Certain Distance I\n  public long[] countOfPairs(int n, int x, int y) {\n    if (x > y) {\n      final int temp = x;\n      x = y;\n      y = temp;\n    }\n\n    final int ringLen = y - x + 1;\n    final int leftLineLen = x - 1;\n    final int rightLineLen = n - y;\n\n    long[] ans = new long[n];\n    ans = addVectors(ans, bothInRing(n, ringLen));\n    ans = addVectors(ans, bothInTheSameLine(n, leftLineLen));\n    ans = addVectors(ans, bothInTheSameLine(n, rightLineLen));\n    ans = addVectors(ans, lineToRing(n, leftLineLen, ringLen));\n    ans = addVectors(ans, lineToRing(n, rightLineLen, ringLen));\n    ans = addVectors(ans, lineToLine(n, x, y, leftLineLen, rightLineLen));\n    for (int i = 0; i < ans.length; ++i)\n      ans[i] *= 2;\n    return ans;\n  }\n\n  // Returns the contribution from the scenario where two houses are located in\n  // the ring.\n  private long[] bothInRing(int n, int ringLen) {\n    long[] res = new long[n];\n    for (int k = 1; k <= (ringLen - 1) / 2; ++k)\n      res[k - 1] += ringLen;\n    if (ringLen % 2 == 0)\n      res[ringLen / 2 - 1] += ringLen / 2;\n    return res;\n  }\n\n  // Returns the contribution from the scenario where two houses are either\n  // located in the left line [1, x) or the right line (y, n].\n  private long[] bothInTheSameLine(int n, int lineLen) {\n    long[] res = new long[n];\n    for (int k = 1; k <= lineLen; ++k)\n      res[k - 1] += lineLen - k;\n    return res;\n  }\n\n  // Returns the contribution from the scenario where one house is either\n  // located in the left line [1, x) or the right line (y, n] and the other\n  // house is located in the cycle.\n  private long[] lineToRing(int n, int lineLen, int ringLen) {\n    long[] res = new long[n];\n    for (int k = 1; k <= lineLen + ringLen; ++k) {\n      // min(\n      //   at most k - 1 since we need to give 1 to the line,\n      //   at most ringLen / 2 since for length > ringLen / 2, it can always be\n      //     calculated as ringLen - ringLen / 2\n      // )\n      final int maxInRingLen = Math.min(k - 1, ringLen / 2);\n      // max(at least 0, at lest k - lineLen)\n      final int minInRingLen = Math.max(0, k - lineLen);\n      if (minInRingLen <= maxInRingLen) {\n        // Each ring length contributes 2 to the count due to the split of\n        // paths when entering the ring: One path traverses the upper half of\n        // the ring, and the other traverses the lower half.\n        // This is illustrated as follows:\n        //   Path 1: ... -- x -- (upper half of the ring)\n        //   Path 2: ... -- x -- (lower half of the ring)\n        res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2;\n        if (minInRingLen == 0)\n          // Subtract 1 since there's no split.\n          res[k - 1] -= 1;\n        if (maxInRingLen * 2 == ringLen)\n          // Subtract 1 since the following case only contribute one:\n          //   ... -- x -- (upper half of the ring) -- middle point\n          //   ... -- x -- (upper half of the ring) -- middle point\n          res[k - 1] -= 1;\n      }\n    }\n    return res;\n  }\n\n  // Returns the contribution from the scenario where one house is in the left\n  // line [1, x) and the other house is in the right line (y, n].\n  private long[] lineToLine(int n, int x, int y, int leftLineLen, int rightLineLen) {\n    long[] res = new long[n];\n    for (int k = 1; k <= leftLineLen + rightLineLen + 2; ++k) {\n      // min(\n      //   at most leftLineLen,\n      //   at most k - 1 - (x < y) since we need to give 1 to the right line\n      //     and if x < y we need to give another 1 to \"x - y\".\n      // )\n      final int maxInLeft = Math.min(leftLineLen, k - 1 - (x < y ? 1 : 0));\n      // max(at least 1, at least k - rightLineLen - (x < y))\n      final int minInLeft = Math.max(1, k - rightLineLen - (x < y ? 1 : 0));\n      if (minInLeft <= maxInLeft)\n        res[k - 1] += maxInLeft - minInLeft + 1;\n    }\n    return res;\n  }\n\n  private long[] addVectors(long[] a, long[] b) {\n    for (int i = 0; i < a.length; ++i)\n      a[i] += b[i];\n    return a;\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Solution:\n  # Same as 3015. Count the Number of Houses at a Certain Distance I\n  def countOfPairs(self, n: int, x: int, y: int) -> List[int]:\n    if x > y:\n      x, y = y, x\n\n    def bothInRing(ringLen: int) -> List[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are located\n      in the ring.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, (ringLen - 1) // 2 + 1):\n        res[k - 1] += ringLen\n      if ringLen % 2 == 0:\n        res[ringLen // 2 - 1] += ringLen // 2\n      return res\n\n    def bothInTheSameLine(lineLen: int) -> List[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are either\n      located in the left line [1, x) or the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + 1):\n        res[k - 1] += lineLen - k\n      return res\n\n    def lineToRing(lineLen: int, ringLen: int) -> List[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is either\n      located in the left line [1, x) or the right line (y, n] and the\n      other house is located in the cycle.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + ringLen):\n        # min(\n        #   at most k - 1 since we need to give 1 to the line,\n        #   at most ringLen / 2 since for length > ringLen / 2, it can always be\n        #     calculated as ringLen - ringLen / 2\n        # )\n        maxInRingLen = min(k - 1, ringLen // 2)\n        # max(at least 0, at lest k - lineLen)\n        minInRingLen = max(0, k - lineLen)\n        if minInRingLen <= maxInRingLen:\n          # Each ring length contributes 2 to the count due to the split of\n          # paths when entering the ring: One path traverses the upper half of\n          # the ring, and the other traverses the lower half.\n          # This is illustrated as follows:\n          #   Path 1: ... -- x -- (upper half of the ring)\n          #   Path 2: ... -- x -- (lower half of the ring)\n          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2\n          if minInRingLen == 0:\n            # Subtract 1 since there's no split.\n            res[k - 1] -= 1\n          if maxInRingLen * 2 == ringLen:\n            # Subtract 1 since the following case only contribute one:\n            #   ... -- x -- (upper half of the ring) -- middle point\n            #   ... -- x -- (upper half of the ring) -- middle point\n            res[k - 1] -= 1\n      return res\n\n    def lineToLine(leftLineLen: int, rightLineLen: int) -> List[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is in the left\n      line [1, x) and the other house is in the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(leftLineLen + rightLineLen + 2):\n        # min(\n        #   at most leftLineLen,\n        #   at most k - 1 - (x < y) since we need to give 1 to the right line\n        #     and if x < y we need to give another 1 to \"x - y\".\n        # )\n        maxInLeft = min(leftLineLen, k - 1 - (x < y))\n        # max(at least 1, at least k - rightLineLen - (x < y))\n        minInLeft = max(1, k - rightLineLen - (x < y))\n        if minInLeft <= maxInLeft:\n          res[k - 1] += maxInLeft - minInLeft + 1\n      return res\n\n    ringLen = y - x + 1\n    leftLineLen = x - 1\n    rightLineLen = (n - y)\n\n    ans = [0] * n\n    ans = list(map(operator.add, ans, bothInRing(ringLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))\n    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))\n    return [freq * 2 for freq in ans]\n",
                "lang_text": "py"
            }
        }
    }
}