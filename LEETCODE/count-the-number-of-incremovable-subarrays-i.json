{
    "failed": false,
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "2970",
            "title": "Count the Number of Incremovable Subarrays I",
            "titleSlug": "count-the-number-of-incremovable-subarrays-i",
            "content": "<p>You are given a <strong>0-indexed</strong> array of <strong>positive</strong> integers <code>nums</code>.</p>\n\n<p>A subarray of <code>nums</code> is called <strong>incremovable</strong> if <code>nums</code> becomes <strong>strictly increasing</strong> on removing the subarray. For example, the subarray <code>[3, 4]</code> is an incremovable subarray of <code>[5, 3, 4, 6, 7]</code> because removing this subarray changes the array <code>[5, 3, 4, 6, 7]</code> to <code>[5, 6, 7]</code> which is strictly increasing.</p>\n\n<p>Return <em>the total number of <strong>incremovable</strong> subarrays of</em> <code>nums</code>.</p>\n\n<p><strong>Note</strong> that an empty array is considered strictly increasing.</p>\n\n<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> The 10 incremovable subarrays are: [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], and [1,2,3,4], because on removing any one of these subarrays nums becomes strictly increasing. Note that you cannot select an empty subarray.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [6,5,7,8]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The 7 incremovable subarrays are: [5], [6], [5,7], [6,5], [5,7,8], [6,5,7] and [6,5,7,8].\nIt can be shown that there are only 7 incremovable subarrays in nums.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [8,7,6,6]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The 3 incremovable subarrays are: [8,7,6], [7,6,6], and [8,7,6,6]. Note that [8,7] is not an incremovable subarray because after removing [8,7] nums becomes [6,6], which is sorted in ascending order but not strictly increasing.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 50</code></li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": 134,
            "dislikes": 87,
            "similarQuestions": "[{\"title\": \"Shortest Subarray to be Removed to Make Array Sorted\", \"titleSlug\": \"shortest-subarray-to-be-removed-to-make-array-sorted\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Subarrays That Match a Pattern I\", \"titleSlug\": \"number-of-subarrays-that-match-a-pattern-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Array",
                    "slug": "array"
                },
                {
                    "name": "Two Pointers",
                    "slug": "two-pointers"
                },
                {
                    "name": "Binary Search",
                    "slug": "binary-search"
                },
                {
                    "name": "Enumeration",
                    "slug": "enumeration"
                }
            ],
            "stats": "{\"totalAccepted\": \"18.4K\", \"totalSubmission\": \"35.9K\", \"totalAcceptedRaw\": 18353, \"totalSubmissionRaw\": 35855, \"acRate\": \"51.2%\"}",
            "hints": [
                "Use two loops to check all the subarrays."
            ],
            "rephrased": {
                "body": "Given a 0-indexed array `nums` of positive integers, determine the total number of incremovable subarrays. A subarray is considered incremovable if, upon its removal, the remaining elements of `nums` form a strictly increasing sequence. An empty array is considered strictly increasing.  A subarray is a contiguous non-empty sequence of elements within an array.",
                "constraints": [
                    "1 <= nums.length <= 50",
                    "1 <= nums[i] <= 50"
                ],
                "testcases": [
                    {
                        "input": "[1,2,3,4]",
                        "output": "10",
                        "explanation": "The incremovable subarrays are: [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], and [1,2,3,4]. Removing any of these results in a strictly increasing array."
                    },
                    {
                        "input": "[6,5,7,8]",
                        "output": "7",
                        "explanation": "The incremovable subarrays are: [5], [6], [5,7], [6,5], [5,7,8], [6,5,7] and [6,5,7,8]."
                    },
                    {
                        "input": "[8,7,6,6]",
                        "output": "3",
                        "explanation": "The incremovable subarrays are: [8,7,6], [7,6,6], and [8,7,6,6]. [8,7] is not incremovable because removing it results in [6,6], which is not strictly increasing."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Medium",
                "titleSlug": "shortest-subarray-to-be-removed-to-make-array-sorted",
                "title": "Shortest Subarray to be Removed to Make Array Sorted",
                "isPaidOnly": false
            },
            {
                "difficulty": "Medium",
                "titleSlug": "number-of-subarrays-that-match-a-pattern-i",
                "title": "Number of Subarrays That Match a Pattern I",
                "isPaidOnly": false
            }
        ],
        "hints": [
            "Use two loops to check all the subarrays."
        ],
        "relatedTopics": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            },
            {
                "name": "Enumeration",
                "slug": "enumeration"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\n public:\n  int incremovableSubarrayCount(vector<int>& nums) {\n    const int n = nums.size();\n    const int startIndex = getStartIndexOfSuffix(nums);\n    // If the complete array is strictly increasing, the total number of ways we\n    // can remove elements equals the total number of possible subarrays.\n    if (startIndex == 0)\n      return n * (n + 1) / 2;\n\n    // The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    // nums[0..startIndex], ..., nums[0..n).\n    int ans = n - startIndex + 1;\n\n    // Enumerate each prefix subarray that is strictly increasing.\n    for (int i = 0; i < startIndex; ++i) {\n      if (i > 0 && nums[i] <= nums[i - 1])\n        break;\n      // Since nums[0..i] is strictly increasing, find the first index j in\n      // nums[startIndex..n) such that nums[j] > nums[i]. The valid removals\n      // will then be nums[i + 1..j - 1], nums[i + 1..j], ..., nums[i + 1..n).\n      ans += nums.end() -\n             upper_bound(nums.begin() + startIndex, nums.end(), nums[i]) + 1;\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the start index i of the suffix subarray such that nums[i..n) is\n  // strictly increasing.\n  int getStartIndexOfSuffix(const vector<int>& nums) {\n    for (int i = nums.size() - 2; i >= 0; --i)\n      if (nums[i] >= nums[i + 1])\n        return i + 1;\n    return 0;\n  }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n  public int incremovableSubarrayCount(int[] nums) {\n    final int n = nums.length;\n    final int startIndex = getStartIndexOfSuffix(nums);\n    // If the complete array is strictly increasing, the total number of ways we\n    // can remove elements equals the total number of possible subarrays.\n    if (startIndex == 0)\n      return n * (n + 1) / 2;\n\n    // The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    // nums[0..startIndex], ..., nums[0..n).\n    int ans = n - startIndex + 1;\n\n    // Enumerate each prefix subarray that is strictly increasing.\n    for (int i = 0; i < startIndex; ++i) {\n      if (i > 0 && nums[i] <= nums[i - 1])\n        break;\n      // Since nums[0..i] is strictly increasing, find the first index j in\n      // nums[startIndex..n) such that nums[j] > nums[i]. The valid removals\n      // will then be nums[i + 1..j - 1], nums[i + 1..j], ..., nums[i + 1..n).\n      ans += n - firstGreater(nums, startIndex, nums[i]) + 1;\n    }\n\n    return ans;\n  }\n\n  // Returns the start index i of the suffix subarray such that nums[i..n) is\n  // strictly increasing.\n  private int getStartIndexOfSuffix(int[] nums) {\n    for (int i = nums.length - 2; i >= 0; --i)\n      if (nums[i] >= nums[i + 1])\n        return i + 1;\n    return 0;\n  }\n\n  private int firstGreater(int[] A, int startIndex, int target) {\n    final int i = Arrays.binarySearch(A, startIndex, A.length, target + 1);\n    return i < 0 ? -i - 1 : i;\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Solution:\n  def incremovableSubarrayCount(self, nums: List[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, find the first index j in\n      # nums[startIndex..n) such that nums[j] > nums[i]. The valid removals\n      # will then be nums[i + 1..j - 1], nums[i + 1..j], ..., nums[i + 1..n).\n      ans += n - bisect.bisect_right(nums, nums[i], startIndex) + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: List[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0\n",
                "lang_text": "py"
            }
        }
    }
}