{
    "failed": false,
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "3234",
            "title": "Count the Number of Substrings With Dominant Ones",
            "titleSlug": "count-the-number-of-substrings-with-dominant-ones",
            "content": "<p>You are given a binary string <code>s</code>.</p>\n\n<p>Return the number of <span data-keyword=\"substring-nonempty\">substrings</span> with <strong>dominant</strong> ones.</p>\n\n<p>A string has <strong>dominant</strong> ones if the number of ones in the string is <strong>greater than or equal to</strong> the <strong>square</strong> of the number of zeros in the string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;00011&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">5</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The substrings with dominant ones are shown in the table below.</p>\n</div>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>i</th>\n\t\t\t<th>j</th>\n\t\t\t<th>s[i..j]</th>\n\t\t\t<th>Number of Zeros</th>\n\t\t\t<th>Number of Ones</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>3</td>\n\t\t\t<td>3</td>\n\t\t\t<td>1</td>\n\t\t\t<td>0</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>4</td>\n\t\t\t<td>4</td>\n\t\t\t<td>1</td>\n\t\t\t<td>0</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>3</td>\n\t\t\t<td>01</td>\n\t\t\t<td>1</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>3</td>\n\t\t\t<td>4</td>\n\t\t\t<td>11</td>\n\t\t\t<td>0</td>\n\t\t\t<td>2</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>4</td>\n\t\t\t<td>011</td>\n\t\t\t<td>1</td>\n\t\t\t<td>2</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;101101&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">16</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The substrings with <strong>non-dominant</strong> ones are shown in the table below.</p>\n\n<p>Since there are 21 substrings total and 5 of them have non-dominant ones, it follows that there are 16 substrings with dominant ones.</p>\n</div>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>i</th>\n\t\t\t<th>j</th>\n\t\t\t<th>s[i..j]</th>\n\t\t\t<th>Number of Zeros</th>\n\t\t\t<th>Number of Ones</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>1</td>\n\t\t\t<td>0</td>\n\t\t\t<td>1</td>\n\t\t\t<td>0</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>4</td>\n\t\t\t<td>4</td>\n\t\t\t<td>0</td>\n\t\t\t<td>1</td>\n\t\t\t<td>0</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>4</td>\n\t\t\t<td>0110</td>\n\t\t\t<td>2</td>\n\t\t\t<td>2</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>0</td>\n\t\t\t<td>4</td>\n\t\t\t<td>10110</td>\n\t\t\t<td>2</td>\n\t\t\t<td>3</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>5</td>\n\t\t\t<td>01101</td>\n\t\t\t<td>2</td>\n\t\t\t<td>3</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists only of characters <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code>.</li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 136,
            "dislikes": 31,
            "similarQuestions": "[{\"title\": \"Count Binary Substrings\", \"titleSlug\": \"count-binary-substrings\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "String",
                    "slug": "string"
                },
                {
                    "name": "Sliding Window",
                    "slug": "sliding-window"
                },
                {
                    "name": "Enumeration",
                    "slug": "enumeration"
                }
            ],
            "stats": "{\"totalAccepted\": \"4.5K\", \"totalSubmission\": \"36.8K\", \"totalAcceptedRaw\": 4463, \"totalSubmissionRaw\": 36784, \"acRate\": \"12.1%\"}",
            "hints": [
                "Let us fix the starting index <code>l</code> of the substring and count the number of indices <code>r</code> such that <code>l <= r</code> and the substring <code>s[l..r]</code> has dominant ones.",
                "A substring with dominant ones has at most <code>sqrt(n)</code> zeros.",
                "We cannot iterate over every <code>r</code> and check if the  <code>s[l..r]</code> has dominant ones. Instead, we iterate over the next <code>sqrt(n)</code> zeros to the left of <code>l</code> and count the number of substrings with dominant ones where the current zero is the rightmost zero of the substring."
            ],
            "rephrased": {
                "body": "Given a binary string `s`, return the number of substrings with dominant ones. A string has dominant ones if the number of ones in the string is greater than or equal to the square of the number of zeros in the string.",
                "constraints": [
                    "1 <= s.length <= 4 * 10^4",
                    "s consists only of characters '0' and '1'."
                ],
                "testcases": [
                    {
                        "input": "00011",
                        "output": "5",
                        "explanation": "The substrings with dominant ones are: '1', '1', '01', '11', '011'."
                    },
                    {
                        "input": "101101",
                        "output": "16",
                        "explanation": "There are a total of 21 substrings. The substrings with non-dominant ones are: '0', '0', '0110', '10110', '01101'. Therefore, there are 21 - 5 = 16 substrings with dominant ones."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Easy",
                "titleSlug": "count-binary-substrings",
                "title": "Count Binary Substrings",
                "isPaidOnly": false
            }
        ],
        "hints": [
            "Let us fix the starting index <code>l</code> of the substring and count the number of indices <code>r</code> such that <code>l <= r</code> and the substring <code>s[l..r]</code> has dominant ones.",
            "A substring with dominant ones has at most <code>sqrt(n)</code> zeros.",
            "We cannot iterate over every <code>r</code> and check if the  <code>s[l..r]</code> has dominant ones. Instead, we iterate over the next <code>sqrt(n)</code> zeros to the left of <code>l</code> and count the number of substrings with dominant ones where the current zero is the rightmost zero of the substring."
        ],
        "relatedTopics": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Sliding Window",
                "slug": "sliding-window"
            },
            {
                "name": "Enumeration",
                "slug": "enumeration"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\n public:\n  int numberOfSubstrings(string s) {\n    int ans = 0;\n\n    // Iterate through all possible number of 0s.\n    for (int zero = 0; zero + zero * zero <= s.length(); ++zero) {\n      int lastInvalidPos = -1;\n      vector<int> count(2);\n      for (int l = 0, r = 0; r < s.length(); ++r) {\n        ++count[s[r] - '0'];\n        // Try to shrink the window to maintain the \"minimum\" length of the\n        // valid substring.\n        for (; l < r; ++l)\n          if (s[l] == '0' && count[0] > zero) {\n            --count[0];  // Remove an extra '0'.\n            lastInvalidPos = l;\n          } else if (s[l] == '1' && count[1] - 1 >= zero * zero) {\n            --count[1];  // Remove an extra '1'.\n          } else {\n            break;  // Cannot remove more characters.\n          }\n        if (count[0] == zero && count[1] >= zero * zero)\n          // Add valid substrings ending in s[r] to the answer. They are\n          // s[lastInvalidPos + 1..r], s[lastInvalidPos + 2..r], ..., s[l..r].\n          ans += l - lastInvalidPos;\n      }\n    }\n\n    return ans;\n  }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n  public int numberOfSubstrings(String s) {\n    int ans = 0;\n\n    // Iterate through all possible number of 0s.\n    for (int zero = 0; zero + zero * zero <= s.length(); ++zero) {\n      int lastInvalidPos = -1;\n      int[] count = new int[2];\n      for (int l = 0, r = 0; r < s.length(); ++r) {\n        ++count[s.charAt(r) - '0'];\n        // Try to shrink the window to maintain the \"minimum\" length of the\n        // valid substring.\n        for (; l < r; ++l)\n          if (s.charAt(l) == '0' && count[0] > zero) {\n            --count[0]; // Remove an extra '0'.\n            lastInvalidPos = l;\n          } else if (s.charAt(l) == '1' && count[1] - 1 >= zero * zero) {\n            --count[1]; // Remove an extra '1'.\n          } else {\n            break; // Cannot remove more characters.\n          }\n        if (count[0] == zero && count[1] >= zero * zero)\n          // Add valid substrings ending in s[r] to the answer. They are\n          // s[lastInvalidPos + 1..r], s[lastInvalidPos + 2..r], ..., s[l..r].\n          ans += l - lastInvalidPos;\n      }\n    }\n\n    return ans;\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Solution:\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    #    z^2 + z = n.\n    # => z^2 + z - n = 0.\n    # => z = (-1 + sqrt(1 + 4n)) / 2.\n    maxZero = (-1 + math.sqrt(1 + 4 * len(s))) // 2\n\n    # Iterate through all possible number of 0s.\n    for zero in range(int(maxZero) + 1):\n      lastInvalidPos = -1\n      count = [0, 0]\n      l = 0\n      for r, c in enumerate(s):\n        count[int(c)] += 1\n        # Try to shrink the window to maintain the \"minimum\" length of the\n        # valid substring.\n        while l < r:\n          if s[l] == '0' and count[0] > zero:\n            count[0] -= 1  # Remove an extra '0'.\n            lastInvalidPos = l\n            l += 1\n          elif s[l] == '1' and count[1] - 1 >= zero * zero:\n            count[1] -= 1  # Remove an extra '1'.\n            l += 1\n          else:\n            break  # Cannot remove more characters.\n        if count[0] == zero and count[1] >= zero * zero:\n          # Add valid substrings ending in s[r] to the answer. They are\n          # s[lastInvalidPos + 1..r], s[lastInvalidPos + 2..r], ..., s[l..r].\n          ans += l - lastInvalidPos\n\n    return ans\n",
                "lang_text": "py"
            }
        }
    }
}