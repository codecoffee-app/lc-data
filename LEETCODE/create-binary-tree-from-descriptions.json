{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "2196",
            "title": "Create Binary Tree From Descriptions",
            "titleSlug": "create-binary-tree-from-descriptions",
            "content": "<p>You are given a 2D integer array <code>descriptions</code> where <code>descriptions[i] = [parent<sub>i</sub>, child<sub>i</sub>, isLeft<sub>i</sub>]</code> indicates that <code>parent<sub>i</sub></code> is the <strong>parent</strong> of <code>child<sub>i</sub></code> in a <strong>binary</strong> tree of <strong>unique</strong> values. Furthermore,</p>\n\n<ul>\n\t<li>If <code>isLeft<sub>i</sub> == 1</code>, then <code>child<sub>i</sub></code> is the left child of <code>parent<sub>i</sub></code>.</li>\n\t<li>If <code>isLeft<sub>i</sub> == 0</code>, then <code>child<sub>i</sub></code> is the right child of <code>parent<sub>i</sub></code>.</li>\n</ul>\n\n<p>Construct the binary tree described by <code>descriptions</code> and return <em>its <strong>root</strong></em>.</p>\n\n<p>The test cases will be generated such that the binary tree is <strong>valid</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/example1drawio.png\" style=\"width: 300px; height: 236px;\" />\n<pre>\n<strong>Input:</strong> descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]\n<strong>Output:</strong> [50,20,80,15,17,19]\n<strong>Explanation:</strong> The root node is the node with value 50 since it has no parent.\nThe resulting binary tree is shown in the diagram.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/example2drawio.png\" style=\"width: 131px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> descriptions = [[1,2,1],[2,3,0],[3,4,1]]\n<strong>Output:</strong> [1,2,null,null,3,4]\n<strong>Explanation:</strong> The root node is the node with value 1 since it has no parent.\nThe resulting binary tree is shown in the diagram.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= descriptions.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>descriptions[i].length == 3</code></li>\n\t<li><code>1 &lt;= parent<sub>i</sub>, child<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= isLeft<sub>i</sub> &lt;= 1</code></li>\n\t<li>The binary tree described by <code>descriptions</code> is valid.</li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 894,
            "dislikes": 18,
            "similarQuestions": "[{\"title\": \"Convert Sorted List to Binary Search Tree\", \"titleSlug\": \"convert-sorted-list-to-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number Of Ways To Reconstruct A Tree\", \"titleSlug\": \"number-of-ways-to-reconstruct-a-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Array",
                    "slug": "array"
                },
                {
                    "name": "Hash Table",
                    "slug": "hash-table"
                },
                {
                    "name": "Tree",
                    "slug": "tree"
                },
                {
                    "name": "Depth-First Search",
                    "slug": "depth-first-search"
                },
                {
                    "name": "Breadth-First Search",
                    "slug": "breadth-first-search"
                },
                {
                    "name": "Binary Tree",
                    "slug": "binary-tree"
                }
            ],
            "stats": "{\"totalAccepted\": \"31K\", \"totalSubmission\": \"42.8K\", \"totalAcceptedRaw\": 30964, \"totalSubmissionRaw\": 42803, \"acRate\": \"72.3%\"}",
            "hints": [
                "Could you represent and store the descriptions more efficiently?",
                "Could you find the root node?",
                "The node that is not a child in any of the descriptions is the root node."
            ],
            "rephrased": {
                "body": "You are given a 2D integer array `descriptions` where `descriptions[i] = [parent_i, child_i, isLeft_i]` indicates that `parent_i` is the parent of `child_i` in a binary tree of unique values.  `isLeft_i` indicates whether the child is the left or right child:\n\n*   If `isLeft_i == 1`, then `child_i` is the left child of `parent_i`.\n*   If `isLeft_i == 0`, then `child_i` is the right child of `parent_i`.\n\nConstruct the binary tree described by `descriptions` and return its root.",
                "constraints": [
                    "1 <= descriptions.length <= 10^4",
                    "descriptions[i].length == 3",
                    "1 <= parent_i, child_i <= 10^5",
                    "0 <= isLeft_i <= 1",
                    "The binary tree described by descriptions is valid."
                ],
                "testcases": [
                    {
                        "input": "[[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]",
                        "output": "[50,20,80,15,17,19]",
                        "explanation": "The root node is 50 because it has no parent in the descriptions. The tree is constructed based on the parent-child relationships and left/right indicators provided."
                    },
                    {
                        "input": "[[1,2,1],[2,3,0],[3,4,1]]",
                        "output": "[1,2,null,null,3,4]",
                        "explanation": "The root node is 1 as it has no parent. The tree structure is built following the given parent-child and left/right relationships."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Medium",
                "titleSlug": "convert-sorted-list-to-binary-search-tree",
                "title": "Convert Sorted List to Binary Search Tree",
                "isPaidOnly": false
            },
            {
                "difficulty": "Hard",
                "titleSlug": "number-of-ways-to-reconstruct-a-tree",
                "title": "Number Of Ways To Reconstruct A Tree",
                "isPaidOnly": false
            }
        ],
        "hints": [
            "Could you represent and store the descriptions more efficiently?",
            "Could you find the root node?",
            "The node that is not a child in any of the descriptions is the root node."
        ],
        "relatedTopics": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-First Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Breadth-First Search",
                "slug": "breadth-first-search"
            },
            {
                "name": "Binary Tree",
                "slug": "binary-tree"
            }
        ]
    }
}