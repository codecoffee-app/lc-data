{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "1172",
            "title": "Dinner Plate Stacks",
            "titleSlug": "dinner-plate-stacks",
            "content": "<p>You have an infinite number of stacks arranged in a row and numbered (left to right) from <code>0</code>, each of the stacks has the same maximum capacity.</p>\n\n<p>Implement the <code>DinnerPlates</code> class:</p>\n\n<ul>\n\t<li><code>DinnerPlates(int capacity)</code> Initializes the object with the maximum capacity of the stacks <code>capacity</code>.</li>\n\t<li><code>void push(int val)</code> Pushes the given integer <code>val</code> into the leftmost stack with a size less than <code>capacity</code>.</li>\n\t<li><code>int pop()</code> Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns <code>-1</code> if all the stacks are empty.</li>\n\t<li><code>int popAtStack(int index)</code> Returns the value at the top of the stack with the given index <code>index</code> and removes it from that stack or returns <code>-1</code> if the stack with that given index is empty.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;DinnerPlates&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;popAtStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;popAtStack&quot;, &quot;popAtStack&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;]\n[[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []]\n<strong>Output</strong>\n[null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1]\n\n<strong>Explanation:</strong> \nDinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2\nD.push(1);\nD.push(2);\nD.push(3);\nD.push(4);\nD.push(5);         // The stacks are now:  2  4\n                                           1  3  5\n                                           \ufe48 \ufe48 \ufe48\nD.popAtStack(0);   // Returns 2.  The stacks are now:     4\n                                                       1  3  5\n                                                       \ufe48 \ufe48 \ufe48\nD.push(20);        // The stacks are now: 20  4\n                                           1  3  5\n                                           \ufe48 \ufe48 \ufe48\nD.push(21);        // The stacks are now: 20  4 21\n                                           1  3  5\n                                           \ufe48 \ufe48 \ufe48\nD.popAtStack(0);   // Returns 20.  The stacks are now:     4 21\n                                                        1  3  5\n                                                        \ufe48 \ufe48 \ufe48\nD.popAtStack(2);   // Returns 21.  The stacks are now:     4\n                                                        1  3  5\n                                                        \ufe48 \ufe48 \ufe48 \nD.pop()            // Returns 5.  The stacks are now:      4\n                                                        1  3 \n                                                        \ufe48 \ufe48  \nD.pop()            // Returns 4.  The stacks are now:   1  3 \n                                                        \ufe48 \ufe48   \nD.pop()            // Returns 3.  The stacks are now:   1 \n                                                        \ufe48   \nD.pop()            // Returns 1.  There are no stacks.\nD.pop()            // Returns -1.  There are still no stacks.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= val &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= index &lt;= 10<sup>5</sup></code></li>\n\t<li>At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>push</code>, <code>pop</code>, and <code>popAtStack</code>.</li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 464,
            "dislikes": 61,
            "similarQuestions": "[]",
            "topicTags": [
                {
                    "name": "Hash Table",
                    "slug": "hash-table"
                },
                {
                    "name": "Stack",
                    "slug": "stack"
                },
                {
                    "name": "Design",
                    "slug": "design"
                },
                {
                    "name": "Heap (Priority Queue)",
                    "slug": "heap-priority-queue"
                }
            ],
            "stats": "{\"totalAccepted\": \"17.1K\", \"totalSubmission\": \"52.4K\", \"totalAcceptedRaw\": 17123, \"totalSubmissionRaw\": 52442, \"acRate\": \"32.7%\"}",
            "hints": [
                "Use a data structure to save the plate status. You may need to operate the exact index. Maintain the leftmost vacant stack and the rightmost non-empty stack.",
                "Use a list of stack to store the plate status. Use heap to maintain the leftmost and rightmost valid stack."
            ],
            "rephrased": {
                "body": "Design a `DinnerPlates` class to simulate an infinite number of stacks arranged in a row, numbered from 0. Each stack has the same maximum capacity. Implement the following methods:\n\n*   `DinnerPlates(int capacity)`: Initializes the object with the maximum capacity of the stacks.\n*   `void push(int val)`: Pushes the given integer `val` into the leftmost stack with available capacity (less than `capacity`).\n*   `int pop()`: Returns the value at the top of the rightmost non-empty stack and removes it. Returns -1 if all stacks are empty.\n*   `int popAtStack(int index)`: Returns the value at the top of the stack at the given `index` and removes it. Returns -1 if the stack at that index is empty.",
                "constraints": [
                    "1 <= capacity <= 2 * 10^4",
                    "1 <= val <= 2 * 10^4",
                    "0 <= index <= 10^5",
                    "At most 2 * 10^5 calls will be made to push, pop, and popAtStack."
                ],
                "testcases": [
                    {
                        "input": "[\"DinnerPlates\", \"push\", \"push\", \"push\", \"push\", \"push\", \"popAtStack\", \"push\", \"push\", \"popAtStack\", \"popAtStack\", \"pop\", \"pop\", \"pop\", \"pop\", \"pop\"] \n[[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []]",
                        "output": "[null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1]",
                        "explanation": "Initialize with capacity 2. Push 1, 2, 3, 4, 5. Pop at stack 0 returns 2. Push 20, 21. Pop at stack 0 returns 20. Pop at stack 2 returns 21.  Subsequent pops return 5, 4, 3, 1, and -1 because it becomes empty."
                    }
                ]
            }
        },
        "similar": [],
        "hints": [
            "Use a data structure to save the plate status. You may need to operate the exact index. Maintain the leftmost vacant stack and the rightmost non-empty stack.",
            "Use a list of stack to store the plate status. Use heap to maintain the leftmost and rightmost valid stack."
        ],
        "relatedTopics": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Design",
                "slug": "design"
            },
            {
                "name": "Heap (Priority Queue)",
                "slug": "heap-priority-queue"
            }
        ]
    }
}