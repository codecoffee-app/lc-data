{
    "failed": false,
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "2973",
            "title": "Find Number of Coins to Place in Tree Nodes",
            "titleSlug": "find-number-of-coins-to-place-in-tree-nodes",
            "content": "<p>You are given an <strong>undirected</strong> tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, and rooted at node <code>0</code>. You are given a 2D integer array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>\n\n<p>You are also given a <strong>0-indexed</strong> integer array <code>cost</code> of length <code>n</code>, where <code>cost[i]</code> is the <strong>cost</strong> assigned to the <code>i<sup>th</sup></code> node.</p>\n\n<p>You need to place some coins on every node of the tree. The number of coins to be placed at node <code>i</code> can be calculated as:</p>\n\n<ul>\n\t<li>If size of the subtree of node <code>i</code> is less than <code>3</code>, place <code>1</code> coin.</li>\n\t<li>Otherwise, place an amount of coins equal to the <strong>maximum</strong> product of cost values assigned to <code>3</code> distinct nodes in the subtree of node <code>i</code>. If this product is <strong>negative</strong>, place <code>0</code> coins.</li>\n</ul>\n\n<p>Return <em>an array </em><code>coin</code><em> of size </em><code>n</code><em> such that </em><code>coin[i]</code><em> is the number of coins placed at node </em><code>i</code><em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012641.png\" style=\"width: 600px; height: 233px;\" />\n<pre>\n<strong>Input:</strong> edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6]\n<strong>Output:</strong> [120,1,1,1,1,1]\n<strong>Explanation:</strong> For node 0 place 6 * 5 * 4 = 120 coins. All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012614.png\" style=\"width: 800px; height: 374px;\" />\n<pre>\n<strong>Input:</strong> edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2]\n<strong>Output:</strong> [280,140,32,1,1,1,1,1,1]\n<strong>Explanation:</strong> The coins placed on each node are:\n- Place 8 * 7 * 5 = 280 coins on node 0.\n- Place 7 * 5 * 4 = 140 coins on node 1.\n- Place 8 * 2 * 2 = 32 coins on node 2.\n- All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012513.png\" style=\"width: 300px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> edges = [[0,1],[0,2]], cost = [1,2,-2]\n<strong>Output:</strong> [0,1,1]\n<strong>Explanation:</strong> Node 1 and 2 are leaves with subtree of size 1, place 1 coin on each of them. For node 0 the only possible product of cost is 2 * 1 * -2 = -4. Hence place 0 coins on node 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>cost.length == n</code></li>\n\t<li><code>1 &lt;= |cost[i]| &lt;= 10<sup>4</sup></code></li>\n\t<li>The input is generated such that <code>edges</code> represents a valid tree.</li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 163,
            "dislikes": 15,
            "similarQuestions": "[{\"title\": \"Collect Coins in a Tree\", \"titleSlug\": \"collect-coins-in-a-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Find the Maximum Sum of Node Values\", \"titleSlug\": \"find-the-maximum-sum-of-node-values\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Dynamic Programming",
                    "slug": "dynamic-programming"
                },
                {
                    "name": "Tree",
                    "slug": "tree"
                },
                {
                    "name": "Depth-First Search",
                    "slug": "depth-first-search"
                },
                {
                    "name": "Sorting",
                    "slug": "sorting"
                },
                {
                    "name": "Heap (Priority Queue)",
                    "slug": "heap-priority-queue"
                }
            ],
            "stats": "{\"totalAccepted\": \"7.5K\", \"totalSubmission\": \"20.7K\", \"totalAcceptedRaw\": 7522, \"totalSubmissionRaw\": 20712, \"acRate\": \"36.3%\"}",
            "hints": [
                "Use DFS on the whole tree, for each subtree, save the largest three positive costs and the smallest three non-positive costs. This can be done by using two Heaps with the size of at most three.",
                "You need to store at most six values at each subtree.",
                "If there are more than three values in total, we can sort them. Let\u2019s call the resultant array <code>A</code>, the maximum product of three is <code>max(A[0] * A[1] * A[n - 1], A[n - 1] * A[n - 2] * A[n - 3])</code>. Don\u2019t forget to set the result to <code>0</code> if the value is negative.",
                "If there are less than three values for a subtree, set its result to <code>1</code>."
            ],
            "rephrased": {
                "body": "You are given an undirected tree with `n` nodes labeled from `0` to `n - 1`, rooted at node `0`. The tree structure is defined by a 2D integer array `edges` where `edges[i] = [a<sub>i</sub>, b<sub>i</sub>]` represents an edge between nodes `a<sub>i</sub>` and `b<sub>i</sub>`. Each node `i` has an associated cost `cost[i]` provided in the 0-indexed integer array `cost`. \n\nYou need to determine the number of coins to place on each node of the tree.  The rules for coin placement are:\n\n*   If the size of the subtree rooted at node `i` is less than 3, place 1 coin.\n*   Otherwise, place a number of coins equal to the maximum product of the costs of any 3 *distinct* nodes within the subtree rooted at node `i`. If this maximum product is negative, place 0 coins.\n\nReturn an array `coin` of size `n` where `coin[i]` is the number of coins placed on node `i`.",
                "constraints": [
                    "2 <= n <= 2 * 10<sup>4</sup>",
                    "edges.length == n - 1",
                    "edges[i].length == 2",
                    "0 <= a<sub>i</sub>, b<sub>i</sub> < n",
                    "cost.length == n",
                    "1 <= |cost[i]| <= 10<sup>4</sup>",
                    "The input is generated such that `edges` represents a valid tree."
                ],
                "testcases": [
                    {
                        "input": "edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6]",
                        "output": "[120,1,1,1,1,1]",
                        "explanation": "For node 0, the maximum product of costs from its subtree is 6 * 5 * 4 = 120. All other nodes are leaves with subtree size 1, so they each receive 1 coin."
                    },
                    {
                        "input": "edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2]",
                        "output": "[280,140,32,1,1,1,1,1,1]",
                        "explanation": "Node 0: 8 * 7 * 5 = 280 coins.\nNode 1: 7 * 5 * 4 = 140 coins.\nNode 2: 8 * 2 * 2 = 32 coins.\nAll other nodes are leaves and receive 1 coin each."
                    },
                    {
                        "input": "edges = [[0,1],[0,2]], cost = [1,2,-2]",
                        "output": "[0,1,1]",
                        "explanation": "Nodes 1 and 2 are leaves with subtree size 1 and receive 1 coin each. For node 0, the only possible product of 3 costs is 2 * 1 * -2 = -4, so 0 coins are placed."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Hard",
                "titleSlug": "collect-coins-in-a-tree",
                "title": "Collect Coins in a Tree",
                "isPaidOnly": false
            },
            {
                "difficulty": "Hard",
                "titleSlug": "find-the-maximum-sum-of-node-values",
                "title": "Find the Maximum Sum of Node Values",
                "isPaidOnly": false
            }
        ],
        "hints": [
            "Use DFS on the whole tree, for each subtree, save the largest three positive costs and the smallest three non-positive costs. This can be done by using two Heaps with the size of at most three.",
            "You need to store at most six values at each subtree.",
            "If there are more than three values in total, we can sort them. Let\u2019s call the resultant array <code>A</code>, the maximum product of three is <code>max(A[0] * A[1] * A[n - 1], A[n - 1] * A[n - 2] * A[n - 3])</code>. Don\u2019t forget to set the result to <code>0</code> if the value is negative.",
            "If there are less than three values for a subtree, set its result to <code>1</code>."
        ],
        "relatedTopics": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            },
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-First Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Sorting",
                "slug": "sorting"
            },
            {
                "name": "Heap (Priority Queue)",
                "slug": "heap-priority-queue"
            }
        ]
    }
}