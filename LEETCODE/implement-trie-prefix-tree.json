{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "208",
            "title": "Implement Trie (Prefix Tree)",
            "titleSlug": "implement-trie-prefix-tree",
            "content": "<p>A <a href=\"https://en.wikipedia.org/wiki/Trie\" target=\"_blank\"><strong>trie</strong></a> (pronounced as &quot;try&quot;) or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p>\n\n<p>Implement the Trie class:</p>\n\n<ul>\n\t<li><code>Trie()</code> Initializes the trie object.</li>\n\t<li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li>\n\t<li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and <code>false</code> otherwise.</li>\n\t<li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]\n[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]\n<strong>Output</strong>\n[null, null, true, false, true, null, true]\n\n<strong>Explanation</strong>\nTrie trie = new Trie();\ntrie.insert(&quot;apple&quot;);\ntrie.search(&quot;apple&quot;);   // return True\ntrie.search(&quot;app&quot;);     // return False\ntrie.startsWith(&quot;app&quot;); // return True\ntrie.insert(&quot;app&quot;);\ntrie.search(&quot;app&quot;);     // return True\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>\n\t<li><code>word</code> and <code>prefix</code> consist only of lowercase English letters.</li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>insert</code>, <code>search</code>, and <code>startsWith</code>.</li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 11129,
            "dislikes": 126,
            "similarQuestions": "[{\"title\": \"Design Add and Search Words Data Structure\", \"titleSlug\": \"design-add-and-search-words-data-structure\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Design Search Autocomplete System\", \"titleSlug\": \"design-search-autocomplete-system\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Replace Words\", \"titleSlug\": \"replace-words\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Implement Magic Dictionary\", \"titleSlug\": \"implement-magic-dictionary\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Encrypt and Decrypt Strings\", \"titleSlug\": \"encrypt-and-decrypt-strings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Implement Trie II (Prefix Tree)\", \"titleSlug\": \"implement-trie-ii-prefix-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Hash Table",
                    "slug": "hash-table"
                },
                {
                    "name": "String",
                    "slug": "string"
                },
                {
                    "name": "Design",
                    "slug": "design"
                },
                {
                    "name": "Trie",
                    "slug": "trie"
                }
            ],
            "stats": "{\"totalAccepted\": \"945.3K\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 945338, \"totalSubmissionRaw\": 1468999, \"acRate\": \"64.4%\"}",
            "hints": [],
            "rephrased": {
                "body": "Implement a Trie (pronounced \"try\") data structure that efficiently stores and retrieves keys in a dataset of strings.  It supports the following operations:\n\n*   `Trie()`: Initializes the trie object.\n*   `void insert(String word)`: Inserts the string `word` into the trie.\n*   `boolean search(String word)`: Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise.\n*   `boolean startsWith(String prefix)`: Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.",
                "constraints": [
                    "1 <= word.length, prefix.length <= 2000",
                    "word and prefix consist only of lowercase English letters.",
                    "At most 3 * 10<sup>4</sup> calls in total will be made to insert, search, and startsWith."
                ],
                "testcases": [
                    {
                        "input": "[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]",
                        "output": "[null, null, true, false, true, null, true]",
                        "explanation": "Trie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True"
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Medium",
                "titleSlug": "design-add-and-search-words-data-structure",
                "title": "Design Add and Search Words Data Structure",
                "isPaidOnly": false
            },
            {
                "difficulty": "Hard",
                "titleSlug": "design-search-autocomplete-system",
                "title": "Design Search Autocomplete System",
                "isPaidOnly": true
            },
            {
                "difficulty": "Medium",
                "titleSlug": "replace-words",
                "title": "Replace Words",
                "isPaidOnly": false
            },
            {
                "difficulty": "Medium",
                "titleSlug": "implement-magic-dictionary",
                "title": "Implement Magic Dictionary",
                "isPaidOnly": false
            },
            {
                "difficulty": "Hard",
                "titleSlug": "encrypt-and-decrypt-strings",
                "title": "Encrypt and Decrypt Strings",
                "isPaidOnly": false
            },
            {
                "difficulty": "Medium",
                "titleSlug": "implement-trie-ii-prefix-tree",
                "title": "Implement Trie II (Prefix Tree)",
                "isPaidOnly": true
            }
        ],
        "hints": [],
        "relatedTopics": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Design",
                "slug": "design"
            },
            {
                "name": "Trie",
                "slug": "trie"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  bool isWord = false;\n  TrieNode() : children(26) {}\n};\n\nclass Trie {\n public:\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->isWord = true;\n  }\n\n  bool search(const string& word) {\n    shared_ptr<TrieNode> node = find(word);\n    return node && node->isWord;\n  }\n\n  bool startsWith(const string& prefix) {\n    return find(prefix) != nullptr;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  shared_ptr<TrieNode> find(const string& prefix) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : prefix) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        return nullptr;\n      node = node->children[i];\n    }\n    return node;\n  }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class TrieNode {\n  public TrieNode[] children = new TrieNode[26];\n  public boolean isWord = false;\n}\n\nclass Trie {\n  public void insert(String word) {\n    TrieNode node = root;\n    for (final char c : word.toCharArray()) {\n      final int i = c - 'a';\n      if (node.children[i] == null)\n        node.children[i] = new TrieNode();\n      node = node.children[i];\n    }\n    node.isWord = true;\n  }\n\n  public boolean search(String word) {\n    TrieNode node = find(word);\n    return node != null && node.isWord;\n  }\n\n  public boolean startsWith(String prefix) {\n    return find(prefix) != null;\n  }\n\n  private TrieNode root = new TrieNode();\n\n  private TrieNode find(String prefix) {\n    TrieNode node = root;\n    for (final char c : prefix.toCharArray()) {\n      final int i = c - 'a';\n      if (node.children[i] == null)\n        return null;\n      node = node.children[i];\n    }\n    return node;\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> bool:\n    node: TrieNode = self._find(word)\n    return node and node.isWord\n\n  def startsWith(self, prefix: str) -> bool:\n    return self._find(prefix)\n\n  def _find(self, prefix: str) -> Optional[TrieNode]:\n    node: TrieNode = self.root\n    for c in prefix:\n      if c not in node.children:\n        return None\n      node = node.children[c]\n    return node\n",
                "lang_text": "py"
            }
        }
    }
}