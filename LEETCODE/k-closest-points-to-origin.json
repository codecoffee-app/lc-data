{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "973",
            "title": "K Closest Points to Origin",
            "titleSlug": "k-closest-points-to-origin",
            "content": "<p>Given an array of <code>points</code> where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents a point on the <strong>X-Y</strong> plane and an integer <code>k</code>, return the <code>k</code> closest points to the origin <code>(0, 0)</code>.</p>\n\n<p>The distance between two points on the <strong>X-Y</strong> plane is the Euclidean distance (i.e., <code>&radic;(x<sub>1</sub> - x<sub>2</sub>)<sup>2</sup> + (y<sub>1</sub> - y<sub>2</sub>)<sup>2</sup></code>).</p>\n\n<p>You may return the answer in <strong>any order</strong>. The answer is <strong>guaranteed</strong> to be <strong>unique</strong> (except for the order that it is in).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\" style=\"width: 400px; height: 400px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,3],[-2,2]], k = 1\n<strong>Output:</strong> [[-2,2]]\n<strong>Explanation:</strong>\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[3,3],[5,-1],[-2,4]], k = 2\n<strong>Output:</strong> [[3,3],[-2,4]]\n<strong>Explanation:</strong> The answer [[-2,4],[3,3]] would also be accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= points.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 8111,
            "dislikes": 289,
            "similarQuestions": "[{\"title\": \"Kth Largest Element in an Array\", \"titleSlug\": \"kth-largest-element-in-an-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Top K Frequent Elements\", \"titleSlug\": \"top-k-frequent-elements\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Top K Frequent Words\", \"titleSlug\": \"top-k-frequent-words\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Nearest Point That Has the Same X or Y Coordinate\", \"titleSlug\": \"find-nearest-point-that-has-the-same-x-or-y-coordinate\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Array",
                    "slug": "array"
                },
                {
                    "name": "Math",
                    "slug": "math"
                },
                {
                    "name": "Divide and Conquer",
                    "slug": "divide-and-conquer"
                },
                {
                    "name": "Geometry",
                    "slug": "geometry"
                },
                {
                    "name": "Sorting",
                    "slug": "sorting"
                },
                {
                    "name": "Heap (Priority Queue)",
                    "slug": "heap-priority-queue"
                },
                {
                    "name": "Quickselect",
                    "slug": "quickselect"
                }
            ],
            "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 1098352, \"totalSubmissionRaw\": 1663790, \"acRate\": \"66.0%\"}",
            "hints": [],
            "rephrased": {
                "body": "Given an array of points representing coordinates on the X-Y plane, determine the `k` closest points to the origin (0, 0). The distance is calculated using the Euclidean distance formula. The order of the returned points does not matter, and the solution is guaranteed to be unique except for ordering.",
                "constraints": [
                    "1 <= k <= points.length <= 10<sup>4</sup>",
                    "-10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup>"
                ],
                "testcases": [
                    {
                        "input": "points = [[1,3],[-2,2]], k = 1",
                        "output": "[[-2,2]]",
                        "explanation": "The distance from (1, 3) to the origin is approximately 3.16. The distance from (-2, 2) to the origin is approximately 2.83. Since 2.83 < 3.16, (-2, 2) is closer to the origin.  We need the closest k = 1 point, so the answer is [[-2,2]]."
                    },
                    {
                        "input": "points = [[3,3],[5,-1],[-2,4]], k = 2",
                        "output": "[[3,3],[-2,4]]",
                        "explanation": "The answer [[-2,4],[3,3]] would also be accepted because the order of points doesn't matter."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Medium",
                "titleSlug": "kth-largest-element-in-an-array",
                "title": "Kth Largest Element in an Array",
                "isPaidOnly": false
            },
            {
                "difficulty": "Medium",
                "titleSlug": "top-k-frequent-elements",
                "title": "Top K Frequent Elements",
                "isPaidOnly": false
            },
            {
                "difficulty": "Medium",
                "titleSlug": "top-k-frequent-words",
                "title": "Top K Frequent Words",
                "isPaidOnly": false
            },
            {
                "difficulty": "Easy",
                "titleSlug": "find-nearest-point-that-has-the-same-x-or-y-coordinate",
                "title": "Find Nearest Point That Has the Same X or Y Coordinate",
                "isPaidOnly": false
            }
        ],
        "hints": [],
        "relatedTopics": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Math",
                "slug": "math"
            },
            {
                "name": "Divide and Conquer",
                "slug": "divide-and-conquer"
            },
            {
                "name": "Geometry",
                "slug": "geometry"
            },
            {
                "name": "Sorting",
                "slug": "sorting"
            },
            {
                "name": "Heap (Priority Queue)",
                "slug": "heap-priority-queue"
            },
            {
                "name": "Quickselect",
                "slug": "quickselect"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\n public:\n  vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n    vector<vector<int>> ans;\n    auto compare = [&](const vector<int>& a, const vector<int>& b) {\n      return squareDist(a) < squareDist(b);\n    };\n    priority_queue<vector<int>, vector<vector<int>>, decltype(compare)> maxHeap(\n        compare);\n\n    for (const vector<int>& point : points) {\n      maxHeap.push(point);\n      if (maxHeap.size() > k)\n        maxHeap.pop();\n    }\n\n    while (!maxHeap.empty())\n      ans.push_back(maxHeap.top()), maxHeap.pop();\n\n    return ans;\n  };\n\n private:\n  int squareDist(const vector<int>& p) {\n    return p[0] * p[0] + p[1] * p[1];\n  }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n  public int[][] kClosest(int[][] points, int k) {\n    int[][] ans = new int[k][2];\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> squareDist(b) - squareDist(a));\n\n    for (int[] point : points) {\n      maxHeap.offer(point);\n      if (maxHeap.size() > k)\n        maxHeap.poll();\n    }\n\n    int i = k;\n    while (!maxHeap.isEmpty())\n      ans[--i] = maxHeap.poll();\n\n    return ans;\n  }\n\n  private int squareDist(int[] p) {\n    return p[0] * p[0] + p[1] * p[1];\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Solution:\n  def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n    maxHeap = []\n\n    for x, y in points:\n      heapq.heappush(maxHeap, (- x * x - y * y, [x, y]))\n      if len(maxHeap) > k:\n        heapq.heappop(maxHeap)\n\n    return [pair[1] for pair in maxHeap]\n",
                "lang_text": "py"
            }
        }
    }
}