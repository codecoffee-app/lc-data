{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "2002",
            "title": "Maximum Product of the Length of Two Palindromic Subsequences",
            "titleSlug": "maximum-product-of-the-length-of-two-palindromic-subsequences",
            "content": "<p>Given a string <code>s</code>, find two <strong>disjoint palindromic subsequences</strong> of <code>s</code> such that the <strong>product</strong> of their lengths is <strong>maximized</strong>. The two subsequences are <strong>disjoint</strong> if they do not both pick a character at the same index.</p>\n\n<p>Return <em>the <strong>maximum</strong> possible <strong>product</strong> of the lengths of the two palindromic subsequences</em>.</p>\n\n<p>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is <strong>palindromic</strong> if it reads the same forward and backward.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png\" style=\"width: 550px; height: 124px;\" />\n<pre>\n<strong>Input:</strong> s = &quot;leetcodecom&quot;\n<strong>Output:</strong> 9\n<strong>Explanation</strong>: An optimal solution is to choose &quot;ete&quot; for the 1<sup>st</sup> subsequence and &quot;cdc&quot; for the 2<sup>nd</sup> subsequence.\nThe product of their lengths is: 3 * 3 = 9.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bb&quot;\n<strong>Output:</strong> 1\n<strong>Explanation</strong>: An optimal solution is to choose &quot;b&quot; (the first character) for the 1<sup>st</sup> subsequence and &quot;b&quot; (the second character) for the 2<sup>nd</sup> subsequence.\nThe product of their lengths is: 1 * 1 = 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;accbcaxxcxx&quot;\n<strong>Output:</strong> 25\n<strong>Explanation</strong>: An optimal solution is to choose &quot;accca&quot; for the 1<sup>st</sup> subsequence and &quot;xxcxx&quot; for the 2<sup>nd</sup> subsequence.\nThe product of their lengths is: 5 * 5 = 25.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 12</code></li>\n\t<li><code>s</code> consists of lowercase English letters only.</li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 858,
            "dislikes": 64,
            "similarQuestions": "[{\"title\": \"Valid Palindrome\", \"titleSlug\": \"valid-palindrome\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Longest Palindromic Subsequence\", \"titleSlug\": \"longest-palindromic-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Product of the Length of Two Palindromic Substrings\", \"titleSlug\": \"maximum-product-of-the-length-of-two-palindromic-substrings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Points in an Archery Competition\", \"titleSlug\": \"maximum-points-in-an-archery-competition\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "String",
                    "slug": "string"
                },
                {
                    "name": "Dynamic Programming",
                    "slug": "dynamic-programming"
                },
                {
                    "name": "Backtracking",
                    "slug": "backtracking"
                },
                {
                    "name": "Bit Manipulation",
                    "slug": "bit-manipulation"
                },
                {
                    "name": "Bitmask",
                    "slug": "bitmask"
                }
            ],
            "stats": "{\"totalAccepted\": \"23.9K\", \"totalSubmission\": \"41.5K\", \"totalAcceptedRaw\": 23890, \"totalSubmissionRaw\": 41469, \"acRate\": \"57.6%\"}",
            "hints": [
                "Could you generate all possible pairs of disjoint subsequences?",
                "Could you find the maximum length palindrome in each subsequence for a pair of disjoint subsequences?"
            ],
            "rephrased": {
                "body": "Given a string `s`, the task is to identify two disjoint palindromic subsequences within `s`.  These subsequences must not share any indices from the original string. The goal is to maximize the product of the lengths of these two subsequences. Return the maximum possible product.",
                "constraints": [
                    "2 <= s.length <= 12",
                    "s consists of lowercase English letters only."
                ],
                "testcases": [
                    {
                        "input": "leetcodecom",
                        "output": "9",
                        "explanation": "An optimal solution selects \"ete\" as the first subsequence and \"cdc\" as the second. The product of their lengths is 3 * 3 = 9."
                    },
                    {
                        "input": "bb",
                        "output": "1",
                        "explanation": "An optimal solution selects \"b\" (the first character) as the first subsequence and \"b\" (the second character) as the second. The product of their lengths is 1 * 1 = 1."
                    },
                    {
                        "input": "accbcaxxcxx",
                        "output": "25",
                        "explanation": "An optimal solution selects \"accca\" as the first subsequence and \"xxcxx\" as the second. The product of their lengths is 5 * 5 = 25."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Easy",
                "titleSlug": "valid-palindrome",
                "title": "Valid Palindrome",
                "isPaidOnly": false
            },
            {
                "difficulty": "Medium",
                "titleSlug": "longest-palindromic-subsequence",
                "title": "Longest Palindromic Subsequence",
                "isPaidOnly": false
            },
            {
                "difficulty": "Hard",
                "titleSlug": "maximum-product-of-the-length-of-two-palindromic-substrings",
                "title": "Maximum Product of the Length of Two Palindromic Substrings",
                "isPaidOnly": false
            },
            {
                "difficulty": "Medium",
                "titleSlug": "maximum-points-in-an-archery-competition",
                "title": "Maximum Points in an Archery Competition",
                "isPaidOnly": false
            }
        ],
        "hints": [
            "Could you generate all possible pairs of disjoint subsequences?",
            "Could you find the maximum length palindrome in each subsequence for a pair of disjoint subsequences?"
        ],
        "relatedTopics": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            },
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation"
            },
            {
                "name": "Bitmask",
                "slug": "bitmask"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\n public:\n  int maxProduct(string s) {\n    size_t ans = 0;\n    dfs(s, 0, \"\", \"\", ans);\n    return ans;\n  }\n\n private:\n  void dfs(const string& s, int i, string&& s1, string&& s2, size_t& ans) {\n    if (i == s.length()) {\n      if (isPalindrome(s1) && isPalindrome(s2))\n        ans = max(ans, s1.length() * s2.length());\n      return;\n    }\n\n    s1.push_back(s[i]);\n    dfs(s, i + 1, move(s1), move(s2), ans);\n    s1.pop_back();\n\n    s2.push_back(s[i]);\n    dfs(s, i + 1, move(s1), move(s2), ans);\n    s2.pop_back();\n\n    dfs(s, i + 1, move(s1), move(s2), ans);\n  }\n\n  bool isPalindrome(const string& s) {\n    int i = 0;\n    int j = s.length() - 1;\n    while (i < j) {\n      if (s[i] != s[j])\n        return false;\n      ++i;\n      --j;\n    }\n    return true;\n  }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n  public int maxProduct(String s) {\n    dfs(s, 0, new StringBuilder(), new StringBuilder());\n    return ans;\n  }\n\n  private int ans = 0;\n\n  private void dfs(final String s, int i, StringBuilder sb1, StringBuilder sb2) {\n    if (i == s.length()) {\n      if (isPalindrome(sb1) && isPalindrome(sb2))\n        ans = Math.max(ans, sb1.length() * sb2.length());\n      return;\n    }\n\n    final int sb1Length = sb1.length();\n    dfs(s, i + 1, sb1.append(s.charAt(i)), sb2);\n    sb1.setLength(sb1Length);\n\n    final int sb2Length = sb2.length();\n    dfs(s, i + 1, sb1, sb2.append(s.charAt(i)));\n    sb2.setLength(sb2Length);\n\n    dfs(s, i + 1, sb1, sb2);\n  }\n\n  private boolean isPalindrome(StringBuilder sb) {\n    int i = 0;\n    int j = sb.length() - 1;\n    while (i < j) {\n      if (sb.charAt(i) != sb.charAt(j))\n        return false;\n      ++i;\n      --j;\n    }\n    return true;\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Solution:\n  def maxProduct(self, s: str) -> int:\n    ans = 0\n\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n\n    @functools.lru_cache(None)\n    def dfs(i: int, s1: str, s2: str) -> None:\n      nonlocal ans\n      if i == len(s):\n        if isPalindrome(s1) and isPalindrome(s2):\n          ans = max(ans, len(s1) * len(s2))\n        return\n\n      dfs(i + 1, s1 + s[i], s2)\n      dfs(i + 1, s1, s2 + s[i])\n      dfs(i + 1, s1, s2)\n\n    dfs(0, '', '')\n    return ans\n",
                "lang_text": "py"
            }
        }
    }
}