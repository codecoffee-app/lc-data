{
    "failed": false,
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "2932",
            "title": "Maximum Strong Pair XOR I",
            "titleSlug": "maximum-strong-pair-xor-i",
            "content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. A pair of integers <code>x</code> and <code>y</code> is called a <strong>strong</strong> pair if it satisfies the condition:</p>\n\n<ul>\n\t<li><code>|x - y| &lt;= min(x, y)</code></li>\n</ul>\n\n<p>You need to select two integers from <code>nums</code> such that they form a strong pair and their bitwise <code>XOR</code> is the <strong>maximum</strong> among all strong pairs in the array.</p>\n\n<p>Return <em>the <strong>maximum</strong> </em><code>XOR</code><em> value out of all possible strong pairs in the array</em> <code>nums</code>.</p>\n\n<p><strong>Note</strong> that you can pick the same integer twice to form a pair.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> There are 11 strong pairs in the array <code>nums</code>: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).\nThe maximum XOR possible from these pairs is 3 XOR 4 = 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,100]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are 2 strong pairs in the array <code>nums</code>: (10, 10) and (100, 100).\nThe maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,6,25,30]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> There are 6 strong pairs in the array <code>nums</code>: (5, 5), (5, 6), (6, 6), (25, 25), (25, 30) and (30, 30).\nThe maximum XOR possible from these pairs is 25 XOR 30 = 7 since the only other non-zero XOR value is 5 XOR 6 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Easy",
            "likes": 128,
            "dislikes": 16,
            "similarQuestions": "[{\"title\": \"Maximum XOR of Two Numbers in an Array\", \"titleSlug\": \"maximum-xor-of-two-numbers-in-an-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum XOR With an Element From Array\", \"titleSlug\": \"maximum-xor-with-an-element-from-array\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Array",
                    "slug": "array"
                },
                {
                    "name": "Hash Table",
                    "slug": "hash-table"
                },
                {
                    "name": "Bit Manipulation",
                    "slug": "bit-manipulation"
                },
                {
                    "name": "Trie",
                    "slug": "trie"
                },
                {
                    "name": "Sliding Window",
                    "slug": "sliding-window"
                }
            ],
            "stats": "{\"totalAccepted\": \"34.8K\", \"totalSubmission\": \"45.8K\", \"totalAcceptedRaw\": 34798, \"totalSubmissionRaw\": 45776, \"acRate\": \"76.0%\"}",
            "hints": [
                "The constraints are small enough to make brute-force solutions pass."
            ],
            "rephrased": {
                "body": "Given a 0-indexed integer array `nums`, a pair of integers `x` and `y` is considered a strong pair if `|x - y| <= min(x, y)`. The goal is to find two integers from `nums` that form a strong pair such that their bitwise XOR is maximized. Return the maximum XOR value among all possible strong pairs in the array. You can pick the same integer twice to form a pair.",
                "constraints": [
                    "1 <= nums.length <= 50",
                    "1 <= nums[i] <= 100"
                ],
                "testcases": [
                    {
                        "input": "[1,2,3,4,5]",
                        "output": "7",
                        "explanation": "The strong pairs are (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5), and (5, 5). The maximum XOR among these pairs is 3 XOR 4 = 7."
                    },
                    {
                        "input": "[10,100]",
                        "output": "0",
                        "explanation": "The strong pairs are (10, 10) and (100, 100). The maximum XOR among these pairs is 10 XOR 10 = 0."
                    },
                    {
                        "input": "[5,6,25,30]",
                        "output": "7",
                        "explanation": "The strong pairs are (5, 5), (5, 6), (6, 6), (25, 25), (25, 30), and (30, 30). The maximum XOR among these pairs is 25 XOR 30 = 7."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Medium",
                "titleSlug": "maximum-xor-of-two-numbers-in-an-array",
                "title": "Maximum XOR of Two Numbers in an Array",
                "isPaidOnly": false
            },
            {
                "difficulty": "Hard",
                "titleSlug": "maximum-xor-with-an-element-from-array",
                "title": "Maximum XOR With an Element From Array",
                "isPaidOnly": false
            }
        ],
        "hints": [
            "The constraints are small enough to make brute-force solutions pass."
        ],
        "relatedTopics": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation"
            },
            {
                "name": "Trie",
                "slug": "trie"
            },
            {
                "name": "Sliding Window",
                "slug": "sliding-window"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  TrieNode() : children(2) {}\n  int min = INT_MAX;\n  int max = INT_MIN;\n};\n\nclass BitTrie {\n public:\n  BitTrie(int maxBit) : maxBit(maxBit) {}\n\n  void insert(int num) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      const int bit = num >> i & 1;\n      if (node->children[bit] == nullptr)\n        node->children[bit] = make_shared<TrieNode>();\n      node = node->children[bit];\n      node->min = min(node->min, num);\n      node->max = max(node->max, num);\n    }\n  }\n\n  // Returns max(x ^ y), where |x - y| <= min(x, y).\n  //\n  // If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n  // So, y <= 2 * x.\n  int getMaxXor(int x) {\n    int maxXor = 0;\n    shared_ptr<TrieNode> node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      const int bit = x >> i & 1;\n      const int toggleBit = bit ^ 1;\n      // If `node.children[toggleBit].max > x`, it means there's a number in the\n      // node that satisfies the condition to ensure that x <= y among x and y.\n      // If `node.children[toggleBit].min <= 2 * x`, it means there's a number\n      // in the node that satisfies the condition for a valid y.\n      if (node->children[toggleBit] != nullptr &&\n          node->children[toggleBit]->max > x &&\n          node->children[toggleBit]->min <= 2 * x) {\n        maxXor = maxXor | 1 << i;\n        node = node->children[toggleBit];\n      } else if (node->children[bit] != nullptr) {\n        node = node->children[bit];\n      } else {  // There's nothing in the Bit Trie.\n        return 0;\n      }\n    }\n    return maxXor;\n  }\n\n private:\n  const int maxBit;\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n};\n\nclass Solution {\n public:\n  // Similar to 421. Maximum XOR of Two Numbers in an Array\n  int maximumStrongPairXor(vector<int>& nums) {\n    const int maxNum = ranges::max(nums);\n    const int maxBit = static_cast<int>(log2(maxNum));\n    int ans = 0;\n    BitTrie bitTrie(maxBit);\n\n    for (const int num : nums)\n      bitTrie.insert(num);\n\n    for (const int num : nums)\n      ans = max(ans, bitTrie.getMaxXor(num));\n\n    return ans;\n  }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class TrieNode {\n  public TrieNode[] children = new TrieNode[2];\n  public int min = Integer.MAX_VALUE;\n  public int max = Integer.MIN_VALUE;\n}\n\nclass BitTrie {\n  public BitTrie(int maxBit) {\n    this.maxBit = maxBit;\n  }\n\n  public void insert(int num) {\n    TrieNode node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      final int bit = (int) (num >> i & 1);\n      if (node.children[bit] == null)\n        node.children[bit] = new TrieNode();\n      node = node.children[bit];\n      node.min = Math.min(node.min, num);\n      node.max = Math.max(node.max, num);\n    }\n  }\n\n  // Returns max(x ^ y), where |x - y| <= min(x, y).\n  //\n  // If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n  // So, y <= 2 * x.\n  public int getMaxXor(int x) {\n    int maxXor = 0;\n    TrieNode node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      final int bit = (int) (x >> i & 1);\n      final int toggleBit = bit ^ 1;\n      // If `node.children[toggleBit].max > x`, it means there's a number in the\n      // node that satisfies the condition to ensure that x <= y among x and y.\n      // If `node.children[toggleBit].min <= 2 * x`, it means there's a number\n      // in the node that satisfies the condition for a valid y.\n      if (node.children[toggleBit] != null && node.children[toggleBit].max > x &&\n          node.children[toggleBit].min <= 2 * x) {\n        maxXor = maxXor | 1 << i;\n        node = node.children[toggleBit];\n      } else if (node.children[bit] != null) {\n        node = node.children[bit];\n      } else { // There's nothing in the Bit Trie.\n        return 0;\n      }\n    }\n    return maxXor;\n  }\n\n  private int maxBit;\n  private TrieNode root = new TrieNode();\n}\n\nclass Solution {\n  // Similar to 421. Maximum XOR of Two Numbers in an Array\n  public int maximumStrongPairXor(int[] nums) {\n    final int maxNum = Arrays.stream(nums).max().getAsInt();\n    final int maxBit = (int) (Math.log(maxNum) / Math.log(2));\n    int ans = 0;\n    BitTrie bitTrie = new BitTrie(maxBit);\n\n    for (final int num : nums)\n      bitTrie.insert(num);\n\n    for (final int num : nums)\n      ans = Math.max(ans, bitTrie.getMaxXor(num));\n\n    return ans;\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n    self.min = math.inf\n    self.max = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.min = min(node.min, num)\n      node.max = max(node.max, num)\n\n  def getMaxXor(self, x: int) -> int:\n    \"\"\"Returns max(x ^ y) where |x - y| <= min(x, y).\n\n    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n    So, y <= 2 * x.\n    \"\"\"\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      # If `node.children[toggleBit].max > x`, it means there's a number in the\n      # node that satisfies the condition to ensure that x <= y among x and y.\n      # If `node.children[toggleBit].min <= 2 * x`, it means there's a number in\n      # the node that satisfies the condition for a valid y.\n      if node.children[toggleBit] \\\n              and node.children[toggleBit].max > x \\\n              and node.children[toggleBit].min <= 2 * x:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  # Similar to 421. Maximum XOR of Two Numbers in an Array\n  def maximumStrongPairXor(self, nums: List[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n",
                "lang_text": "py"
            }
        }
    }
}