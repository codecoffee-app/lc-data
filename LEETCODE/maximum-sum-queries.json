{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "2736",
            "title": "Maximum Sum Queries",
            "titleSlug": "maximum-sum-queries",
            "content": "<p>You are given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, each of length <code>n</code>, and a <strong>1-indexed 2D array</strong> <code>queries</code> where <code>queries[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>.</p>\n\n<p>For the <code>i<sup>th</sup></code> query, find the <strong>maximum value</strong> of <code>nums1[j] + nums2[j]</code> among all indices <code>j</code> <code>(0 &lt;= j &lt; n)</code>, where <code>nums1[j] &gt;= x<sub>i</sub></code> and <code>nums2[j] &gt;= y<sub>i</sub></code>, or <strong>-1</strong> if there is no <code>j</code> satisfying the constraints.</p>\n\n<p>Return <em>an array </em><code>answer</code><em> where </em><code>answer[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]\n<strong>Output:</strong> [6,10,7]\n<strong>Explanation:</strong> \nFor the 1st query <code node=\"[object Object]\">x<sub>i</sub> = 4</code>&nbsp;and&nbsp;<code node=\"[object Object]\">y<sub>i</sub> = 1</code>, we can select index&nbsp;<code node=\"[object Object]\">j = 0</code>&nbsp;since&nbsp;<code node=\"[object Object]\">nums1[j] &gt;= 4</code>&nbsp;and&nbsp;<code node=\"[object Object]\">nums2[j] &gt;= 1</code>. The sum&nbsp;<code node=\"[object Object]\">nums1[j] + nums2[j]</code>&nbsp;is 6, and we can show that 6 is the maximum we can obtain.\n\nFor the 2nd query <code node=\"[object Object]\">x<sub>i</sub> = 1</code>&nbsp;and&nbsp;<code node=\"[object Object]\">y<sub>i</sub> = 3</code>, we can select index&nbsp;<code node=\"[object Object]\">j = 2</code>&nbsp;since&nbsp;<code node=\"[object Object]\">nums1[j] &gt;= 1</code>&nbsp;and&nbsp;<code node=\"[object Object]\">nums2[j] &gt;= 3</code>. The sum&nbsp;<code node=\"[object Object]\">nums1[j] + nums2[j]</code>&nbsp;is 10, and we can show that 10 is the maximum we can obtain. \n\nFor the 3rd query <code node=\"[object Object]\">x<sub>i</sub> = 2</code>&nbsp;and&nbsp;<code node=\"[object Object]\">y<sub>i</sub> = 5</code>, we can select index&nbsp;<code node=\"[object Object]\">j = 3</code>&nbsp;since&nbsp;<code node=\"[object Object]\">nums1[j] &gt;= 2</code>&nbsp;and&nbsp;<code node=\"[object Object]\">nums2[j] &gt;= 5</code>. The sum&nbsp;<code node=\"[object Object]\">nums1[j] + nums2[j]</code>&nbsp;is 7, and we can show that 7 is the maximum we can obtain.\n\nTherefore, we return&nbsp;<code node=\"[object Object]\">[6,10,7]</code>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]\n<strong>Output:</strong> [9,9,9]\n<strong>Explanation:</strong> For this example, we can use index&nbsp;<code node=\"[object Object]\">j = 2</code>&nbsp;for all the queries since it satisfies the constraints for each query.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]\n<strong>Output:</strong> [-1]\n<strong>Explanation:</strong> There is one query in this example with <code node=\"[object Object]\">x<sub>i</sub></code> = 3 and <code node=\"[object Object]\">y<sub>i</sub></code> = 3. For every index, j, either nums1[j] &lt; <code node=\"[object Object]\">x<sub>i</sub></code> or nums2[j] &lt; <code node=\"[object Object]\">y<sub>i</sub></code>. Hence, there is no solution. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums1.length == nums2.length</code>&nbsp;</li>\n\t<li><code>n ==&nbsp;nums1.length&nbsp;</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup>&nbsp;</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length ==&nbsp;2</code></li>\n\t<li><code>x<sub>i</sub>&nbsp;== queries[i][1]</code></li>\n\t<li><code>y<sub>i</sub> == queries[i][2]</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 298,
            "dislikes": 15,
            "similarQuestions": "[{\"title\": \"Most Beautiful Item for Each Query\", \"titleSlug\": \"most-beautiful-item-for-each-query\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Array",
                    "slug": "array"
                },
                {
                    "name": "Binary Search",
                    "slug": "binary-search"
                },
                {
                    "name": "Stack",
                    "slug": "stack"
                },
                {
                    "name": "Binary Indexed Tree",
                    "slug": "binary-indexed-tree"
                },
                {
                    "name": "Segment Tree",
                    "slug": "segment-tree"
                },
                {
                    "name": "Sorting",
                    "slug": "sorting"
                },
                {
                    "name": "Monotonic Stack",
                    "slug": "monotonic-stack"
                }
            ],
            "stats": "{\"totalAccepted\": \"4.7K\", \"totalSubmission\": \"17.2K\", \"totalAcceptedRaw\": 4711, \"totalSubmissionRaw\": 17159, \"acRate\": \"27.5%\"}",
            "hints": [
                "Sort (x, y) tuples and queries by x-coordinate descending. Don\u2019t forget to index queries before sorting so that you can answer them in the correct order.",
                "Before answering a query (min_x, min_y), add all (x, y) pairs with x >= min_x to some data structure.",
                "Use a monotone descending map to store (y, x + y) pairs. A monotone map has ascending keys and descending values. When inserting a pair (y, x + y), remove all pairs (y', x' + y') with y' < y and x' + y' <= x + y.",
                "To find the insertion position use binary search (built-in in many languages).",
                "When querying for max (x + y) over y >= y', use binary search to find the first pair (y, x + y) with y >= y'. It will have the maximum value of x + y because the map has monotone descending values."
            ],
            "rephrased": {
                "body": "You are given two 0-indexed integer arrays `nums1` and `nums2`, each of length `n`, and a 1-indexed 2D array `queries` where `queries[i] = [x_i, y_i]`.  For the `i`th query, find the maximum value of `nums1[j] + nums2[j]` among all indices `j` (0 <= j < n), where `nums1[j] >= x_i` and `nums2[j] >= y_i`, or -1 if there is no `j` satisfying the constraints.  Return an array `answer` where `answer[i]` is the answer to the `i`th query.",
                "constraints": [
                    "nums1.length == nums2.length",
                    "n == nums1.length",
                    "1 <= n <= 10^5",
                    "1 <= nums1[i], nums2[i] <= 10^9",
                    "1 <= queries.length <= 10^5",
                    "queries[i].length == 2",
                    "x_i == queries[i][0]",
                    "y_i == queries[i][1]",
                    "1 <= x_i, y_i <= 10^9"
                ],
                "testcases": [
                    {
                        "input": "nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]",
                        "output": "[6,10,7]",
                        "explanation": "Query 1 (x=4, y=1): Index 0 satisfies the conditions (4>=4 and 2>=1). The sum is 6. This is the maximum possible sum.\nQuery 2 (x=1, y=3): Index 2 satisfies the conditions (1>=1 and 9>=3). The sum is 10. This is the maximum possible sum.\nQuery 3 (x=2, y=5): Index 3 satisfies the conditions (2>=2 and 5>=5). The sum is 7. This is the maximum possible sum."
                    },
                    {
                        "input": "nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]",
                        "output": "[9,9,9]",
                        "explanation": "For all queries, index 2 always satisfies the constraints, resulting in a sum of 5+4 = 9. It is the maximum possible in each query."
                    },
                    {
                        "input": "nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]",
                        "output": "[-1]",
                        "explanation": "Query 1 (x=3, y=3): There is no index where both `nums1[j] >= 3` and `nums2[j] >= 3`. Therefore, the answer is -1."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Medium",
                "titleSlug": "most-beautiful-item-for-each-query",
                "title": "Most Beautiful Item for Each Query",
                "isPaidOnly": false
            }
        ],
        "hints": [
            "Sort (x, y) tuples and queries by x-coordinate descending. Don\u2019t forget to index queries before sorting so that you can answer them in the correct order.",
            "Before answering a query (min_x, min_y), add all (x, y) pairs with x >= min_x to some data structure.",
            "Use a monotone descending map to store (y, x + y) pairs. A monotone map has ascending keys and descending values. When inserting a pair (y, x + y), remove all pairs (y', x' + y') with y' < y and x' + y' <= x + y.",
            "To find the insertion position use binary search (built-in in many languages).",
            "When querying for max (x + y) over y >= y', use binary search to find the first pair (y, x + y) with y >= y'. It will have the maximum value of x + y because the map has monotone descending values."
        ],
        "relatedTopics": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            },
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Binary Indexed Tree",
                "slug": "binary-indexed-tree"
            },
            {
                "name": "Segment Tree",
                "slug": "segment-tree"
            },
            {
                "name": "Sorting",
                "slug": "sorting"
            },
            {
                "name": "Monotonic Stack",
                "slug": "monotonic-stack"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "struct Pair {\n  int x;\n  int y;\n};\n\nstruct IndexAndQuery {\n  int index;  // the index in `queries`\n  int minX;   // queries[i] := (minX, minY)\n  int minY;\n};\n\nclass Solution {\n public:\n  vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2,\n                                vector<vector<int>>& queries) {\n    const vector<Pair> pairs = getPairs(nums1, nums2);\n    const vector<IndexAndQuery> indexAndQueries = getIndexAndQueries(queries);\n    vector<int> ans(queries.size());\n    vector<pair<int, int>> stack;  // [(y, x + y)]\n\n    int i = 0;\n    for (const auto& [index, minX, minY] : indexAndQueries) {\n      while (i < pairs.size() && pairs[i].x >= minX) {\n        const auto [x, y] = pairs[i++];\n        // x + y is a better candidate. Given that x is decreasing, the\n        // condition \"x + y >= stack.back().second\" suggests that y is\n        // relatively larger, thereby making it a better candidate.\n        while (!stack.empty() && x + y >= stack.back().second)\n          stack.pop_back();\n        if (stack.empty() || y > stack.back().first)\n          stack.emplace_back(y, x + y);\n      }\n      const auto it = lower_bound(stack.begin(), stack.end(),\n                                  pair<int, int>{minY, INT_MIN});\n      ans[index] = it == stack.end() ? -1 : it->second;\n    }\n\n    return ans;\n  }\n\n private:\n  vector<Pair> getPairs(const vector<int>& nums1, const vector<int>& nums2) {\n    vector<Pair> pairs;\n    for (int i = 0; i < nums1.size(); ++i)\n      pairs.push_back({nums1[i], nums2[i]});\n    sort(pairs.begin(), pairs.end(),\n         [](const Pair& a, const Pair& b) { return a.x > b.x; });\n    return pairs;\n  }\n\n  vector<IndexAndQuery> getIndexAndQueries(const vector<vector<int>>& queries) {\n    vector<IndexAndQuery> indexAndQueries;\n    for (int i = 0; i < queries.size(); ++i)\n      indexAndQueries.push_back(IndexAndQuery{\n          .index = i,\n          .minX = queries[i][0],\n          .minY = queries[i][1],\n      });\n    sort(indexAndQueries.begin(), indexAndQueries.end(),\n         [](const IndexAndQuery& a, const IndexAndQuery& b) {\n      return a.minX > b.minX;\n    });\n    return indexAndQueries;\n  }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n  public int[] maximumSumQueries(int[] nums1, int[] nums2, int[][] queries) {\n    List<MyPair> pairs = getPairs(nums1, nums2);\n    List<IndexAndQuery> indexAndQueries = getIndexAndQueries(queries);\n    int[] ans = new int[queries.length];\n    List<Pair<Integer, Integer>> stack = new ArrayList<>(); // [(y, x + y)]\n\n    int i = 0;\n    for (IndexAndQuery indexAndQuery : indexAndQueries) {\n      final int index = indexAndQuery.index;\n      final int minX = indexAndQuery.minX;\n      final int minY = indexAndQuery.minY;\n      while (i < pairs.size() && pairs.get(i).x >= minX) {\n        MyPair pair = pairs.get(i++);\n        // x + y is a better candidate. Given that x is decreasing, the\n        // condition \"x + y >= stack.back().second\" suggests that y is\n        // relatively larger, thereby making it a better candidate.\n        final int x = pair.x;\n        final int y = pair.y;\n        while (!stack.isEmpty() && x + y >= stack.get(stack.size() - 1).getValue())\n          stack.remove(stack.size() - 1);\n        if (stack.isEmpty() || y > stack.get(stack.size() - 1).getKey())\n          stack.add(new Pair<>(y, x + y));\n      }\n\n      final int j = firstGreaterEqual(stack, minY);\n      ans[index] = j == stack.size() ? -1 : stack.get(j).getValue();\n    }\n\n    return ans;\n  }\n\n  private record MyPair(int x, int y){};\n  private record IndexAndQuery(int index, int minX, int minY){};\n\n  private int firstGreaterEqual(List<Pair<Integer, Integer>> A, int target) {\n    int l = 0;\n    int r = A.size();\n    while (l < r) {\n      final int m = (l + r) / 2;\n      if (A.get(m).getKey() >= target)\n        r = m;\n      else\n        l = m + 1;\n    }\n    return l;\n  }\n\n  private List<MyPair> getPairs(int[] nums1, int[] nums2) {\n    List<MyPair> pairs = new ArrayList<>();\n    for (int i = 0; i < nums1.length; ++i)\n      pairs.add(new MyPair(nums1[i], nums2[i]));\n    pairs.sort((a, b) -> b.x - a.x);\n    return pairs;\n  }\n\n  private List<IndexAndQuery> getIndexAndQueries(int[][] queries) {\n    List<IndexAndQuery> indexAndQueries = new ArrayList<>();\n    for (int i = 0; i < queries.length; ++i)\n      indexAndQueries.add(new IndexAndQuery(i, queries[i][0], queries[i][1]));\n    indexAndQueries.sort((a, b) -> b.minX - a.minX);\n    return indexAndQueries;\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Pair:\n  def __init__(self, x: int, y: int):\n    self.x = x\n    self.y = y\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\nclass IndexAndQuery:\n  def __init__(self, index: int, minX: int, minY: int):\n    self.index = index\n    self.minX = minX\n    self.minY = minY\n\n  def __iter__(self):\n    yield self.index\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n    indexAndQueries = sorted([IndexAndQuery(i, query[0], query[1])\n                              for i, query in enumerate(queries)],\n                             key=lambda iq: iq.minX, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    i = 0\n    for index, minX, minY in indexAndQueries:\n      while i < len(pairs) and pairs[i].x >= minX:\n        x, y = pairs[i]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        i += 1\n      j = self._firstGreaterEqual(stack, minY)\n      ans[index] = -1 if j == len(stack) else stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l\n",
                "lang_text": "py"
            }
        }
    }
}