{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "928",
            "title": "Minimize Malware Spread II",
            "titleSlug": "minimize-malware-spread-ii",
            "content": "<p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>\n\n<p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>\n\n<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops.</p>\n\n<p>We will remove <strong>exactly one node</strong> from <code>initial</code>, <strong>completely removing it and any connections from this node to any other node</strong>.</p>\n\n<p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\n<strong>Output:</strong> 0\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]\n<strong>Output:</strong> 1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>n == graph[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 300</code></li>\n\t<li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n\t<li><code>graph[i][j] == graph[j][i]</code></li>\n\t<li><code>graph[i][i] == 1</code></li>\n\t<li><code>1 &lt;= initial.length &lt;&nbsp;n</code></li>\n\t<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>\n\t<li>All the integers in <code>initial</code> are <strong>unique</strong>.</li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 641,
            "dislikes": 88,
            "similarQuestions": "[]",
            "topicTags": [
                {
                    "name": "Hash Table",
                    "slug": "hash-table"
                },
                {
                    "name": "Depth-First Search",
                    "slug": "depth-first-search"
                },
                {
                    "name": "Breadth-First Search",
                    "slug": "breadth-first-search"
                },
                {
                    "name": "Union Find",
                    "slug": "union-find"
                },
                {
                    "name": "Graph",
                    "slug": "graph"
                }
            ],
            "stats": "{\"totalAccepted\": \"20.1K\", \"totalSubmission\": \"46.9K\", \"totalAcceptedRaw\": 20138, \"totalSubmissionRaw\": 46911, \"acRate\": \"42.9%\"}",
            "hints": [],
            "rephrased": {
                "body": "Given a network of `n` nodes represented by an `n x n` adjacency matrix `graph`, where `graph[i][j] == 1` indicates a direct connection between node `i` and node `j`. Initially, a set of nodes `initial` are infected with malware. The malware spreads between directly connected nodes, infecting both if at least one is already infected. This process continues until no further infections occur.  Let `M(initial)` be the total number of infected nodes after the spread stops. The task is to remove exactly one node from the `initial` set, and its connections in the graph, to minimize the final number of infected nodes, `M(initial)`. Return the index of the node to remove. If multiple nodes achieve the minimal `M(initial)`, return the node with the smallest index.",
                "constraints": [
                    "n == graph.length",
                    "n == graph[i].length",
                    "2 <= n <= 300",
                    "graph[i][j] is 0 or 1",
                    "graph[i][j] == graph[j][i]",
                    "graph[i][i] == 1",
                    "1 <= initial.length < n",
                    "0 <= initial[i] <= n - 1",
                    "All the integers in initial are unique"
                ],
                "testcases": [
                    {
                        "input": "graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]",
                        "output": "0",
                        "explanation": null
                    },
                    {
                        "input": "graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]",
                        "output": "1",
                        "explanation": null
                    },
                    {
                        "input": "graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]",
                        "output": "1",
                        "explanation": null
                    }
                ]
            }
        },
        "similar": [],
        "hints": [],
        "relatedTopics": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Depth-First Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Breadth-First Search",
                "slug": "breadth-first-search"
            },
            {
                "name": "Union Find",
                "slug": "union-find"
            },
            {
                "name": "Graph",
                "slug": "graph"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\n public:\n  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {\n    int ans = 0;\n    int minCount = graph.size();\n\n    std::ranges::sort(initial);\n\n    for (const int i : initial) {\n      const int count = bfs(graph, i, initial);\n      if (count < minCount) {\n        minCount = count;\n        ans = i;\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  int bfs(const vector<vector<int>>& graph, int removed, vector<int>& initial) {\n    queue<int> q;\n    vector<bool> seen(graph.size());\n    seen[removed] = true;\n\n    int count = 0;\n\n    for (const int i : initial)\n      if (i != removed) {\n        q.push(i);\n        seen[i] = true;\n      }\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      ++count;\n      for (int i = 0; i < graph.size(); ++i) {\n        if (seen[i])\n          continue;\n        if (i != u && graph[i][u]) {\n          q.push(i);\n          seen[i] = true;\n        }\n      }\n    }\n\n    return count;\n  }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n  public int minMalwareSpread(int[][] graph, int[] initial) {\n    int ans = 0;\n    int minCount = graph.length;\n\n    Arrays.sort(initial);\n\n    for (final int i : initial) {\n      final int count = bfs(graph, i, initial);\n      if (count < minCount) {\n        minCount = count;\n        ans = i;\n      }\n    }\n\n    return ans;\n  }\n\n  private int bfs(int[][] graph, int removed, int[] initial) {\n    Queue<Integer> q = new ArrayDeque<>();\n    boolean[] seen = new boolean[graph.length];\n    seen[removed] = true;\n\n    int count = 0;\n\n    for (final int i : initial)\n      if (i != removed) {\n        q.offer(i);\n        seen[i] = true;\n      }\n\n    while (!q.isEmpty()) {\n      final int u = q.poll();\n      ++count;\n      for (int i = 0; i < graph.length; ++i) {\n        if (seen[i])\n          continue;\n        if (i != u && graph[i][u] == 1) {\n          q.offer(i);\n          seen[i] = true;\n        }\n      }\n    }\n\n    return count;\n  }\n}\n",
                "lang_text": "java"
            }
        }
    }
}