{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "2281",
            "title": "Sum of Total Strength of Wizards",
            "titleSlug": "sum-of-total-strength-of-wizards",
            "content": "<p>As the ruler of a kingdom, you have an army of wizards at your command.</p>\n\n<p>You are given a <strong>0-indexed</strong> integer array <code>strength</code>, where <code>strength[i]</code> denotes the strength of the <code>i<sup>th</sup></code> wizard. For a <strong>contiguous</strong> group of wizards (i.e. the wizards&#39; strengths form a <strong>subarray</strong> of <code>strength</code>), the <strong>total strength</strong> is defined as the <strong>product</strong> of the following two values:</p>\n\n<ul>\n\t<li>The strength of the <strong>weakest</strong> wizard in the group.</li>\n\t<li>The <strong>total</strong> of all the individual strengths of the wizards in the group.</li>\n</ul>\n\n<p>Return <em>the <strong>sum</strong> of the total strengths of <strong>all</strong> contiguous groups of wizards</em>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> strength = [1,3,1,2]\n<strong>Output:</strong> 44\n<strong>Explanation:</strong> The following are all the contiguous groups of wizards:\n- [1] from [<u><strong>1</strong></u>,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [3] from [1,<u><strong>3</strong></u>,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9\n- [1] from [1,3,<u><strong>1</strong></u>,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [2] from [1,3,1,<u><strong>2</strong></u>] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4\n- [1,3] from [<u><strong>1,3</strong></u>,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4\n- [3,1] from [1,<u><strong>3,1</strong></u>,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4\n- [1,2] from [1,3,<u><strong>1,2</strong></u>] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3\n- [1,3,1] from [<u><strong>1,3,1</strong></u>,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n- [3,1,2] from [1,<u><strong>3,1,2</strong></u>] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n- [1,3,1,2] from [<u><strong>1,3,1,2</strong></u>] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\nThe sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> strength = [5,4,6]\n<strong>Output:</strong> 213\n<strong>Explanation:</strong> The following are all the contiguous groups of wizards: \n- [5] from [<u><strong>5</strong></u>,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25\n- [4] from [5,<u><strong>4</strong></u>,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16\n- [6] from [5,4,<u><strong>6</strong></u>] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36\n- [5,4] from [<u><strong>5,4</strong></u>,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36\n- [4,6] from [5,<u><strong>4,6</strong></u>] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40\n- [5,4,6] from [<u><strong>5,4,6</strong></u>] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\nThe sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strength.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= strength[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
            "isPaidOnly": false,
            "difficulty": "Hard",
            "likes": 1115,
            "dislikes": 90,
            "similarQuestions": "[{\"title\": \"Next Greater Element I\", \"titleSlug\": \"next-greater-element-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sum of Subarray Minimums\", \"titleSlug\": \"sum-of-subarray-minimums\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Visible People in a Queue\", \"titleSlug\": \"number-of-visible-people-in-a-queue\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Sum of Subarray Ranges\", \"titleSlug\": \"sum-of-subarray-ranges\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Array",
                    "slug": "array"
                },
                {
                    "name": "Stack",
                    "slug": "stack"
                },
                {
                    "name": "Monotonic Stack",
                    "slug": "monotonic-stack"
                },
                {
                    "name": "Prefix Sum",
                    "slug": "prefix-sum"
                }
            ],
            "stats": "{\"totalAccepted\": \"16.9K\", \"totalSubmission\": \"61.1K\", \"totalAcceptedRaw\": 16907, \"totalSubmissionRaw\": 61142, \"acRate\": \"27.7%\"}",
            "hints": [
                "Consider the contribution of each wizard to the answer.",
                "Can you efficiently calculate the total contribution to the answer for all subarrays that end at each index?",
                "Denote the total contribution of all subarrays ending at index i as solve[i]. Can you express solve[i] in terms of solve[m] for some m < i?"
            ],
            "rephrased": {
                "body": "Given an array `strength` representing the strength of wizards, calculate the sum of the total strengths of all contiguous groups of wizards. The total strength of a group is the product of the weakest wizard's strength and the sum of all wizards' strengths in that group. Return the sum modulo 10^9 + 7.",
                "constraints": [
                    "1 <= strength.length <= 10^5",
                    "1 <= strength[i] <= 10^9"
                ],
                "testcases": [
                    {
                        "input": "[1,3,1,2]",
                        "output": "44",
                        "explanation": "Consider all contiguous subarrays:\n\n- [1]: min([1]) * sum([1]) = 1 * 1 = 1\n- [3]: min([3]) * sum([3]) = 3 * 3 = 9\n- [1]: min([1]) * sum([1]) = 1 * 1 = 1\n- [2]: min([2]) * sum([2]) = 2 * 2 = 4\n- [1,3]: min([1,3]) * sum([1,3]) = 1 * 4 = 4\n- [3,1]: min([3,1]) * sum([3,1]) = 1 * 4 = 4\n- [1,2]: min([1,2]) * sum([1,2]) = 1 * 3 = 3\n- [1,3,1]: min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n- [3,1,2]: min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n- [1,3,1,2]: min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\n\nThe total sum is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44."
                    },
                    {
                        "input": "[5,4,6]",
                        "output": "213",
                        "explanation": "Consider all contiguous subarrays:\n\n- [5]: min([5]) * sum([5]) = 5 * 5 = 25\n- [4]: min([4]) * sum([4]) = 4 * 4 = 16\n- [6]: min([6]) * sum([6]) = 6 * 6 = 36\n- [5,4]: min([5,4]) * sum([5,4]) = 4 * 9 = 36\n- [4,6]: min([4,6]) * sum([4,6]) = 4 * 10 = 40\n- [5,4,6]: min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\n\nThe total sum is 25 + 16 + 36 + 36 + 40 + 60 = 213."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Easy",
                "titleSlug": "next-greater-element-i",
                "title": "Next Greater Element I",
                "isPaidOnly": false
            },
            {
                "difficulty": "Medium",
                "titleSlug": "sum-of-subarray-minimums",
                "title": "Sum of Subarray Minimums",
                "isPaidOnly": false
            },
            {
                "difficulty": "Hard",
                "titleSlug": "number-of-visible-people-in-a-queue",
                "title": "Number of Visible People in a Queue",
                "isPaidOnly": false
            },
            {
                "difficulty": "Medium",
                "titleSlug": "sum-of-subarray-ranges",
                "title": "Sum of Subarray Ranges",
                "isPaidOnly": false
            }
        ],
        "hints": [
            "Consider the contribution of each wizard to the answer.",
            "Can you efficiently calculate the total contribution to the answer for all subarrays that end at each index?",
            "Denote the total contribution of all subarrays ending at index i as solve[i]. Can you express solve[i] in terms of solve[m] for some m < i?"
        ],
        "relatedTopics": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Monotonic Stack",
                "slug": "monotonic-stack"
            },
            {
                "name": "Prefix Sum",
                "slug": "prefix-sum"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\n public:\n  int totalStrength(vector<int>& strength) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = strength.size();\n    vector<long> prefix(n);\n    vector<long> prefixOfPrefix(n + 1);\n    // left[i] := next index on the left (if any)\n    //            s.t. nums[left[i]] <= nums[i]\n    vector<int> left(n, -1);\n    // right[i] := next index on the right (if any)\n    //             s.t. nums[right[i]] < nums[i]\n    vector<int> right(n, n);\n    stack<int> stack;\n\n    for (int i = 0; i < n; ++i)\n      prefix[i] = i == 0 ? strength[0] : (strength[i] + prefix[i - 1]) % kMod;\n\n    for (int i = 0; i < n; ++i)\n      prefixOfPrefix[i + 1] = (prefixOfPrefix[i] + prefix[i]) % kMod;\n\n    for (int i = n - 1; i >= 0; --i) {\n      while (!stack.empty() && strength[stack.top()] >= strength[i])\n        left[stack.top()] = i, stack.pop();\n      stack.push(i);\n    }\n\n    stack = std::stack<int>();\n\n    for (int i = 0; i < n; ++i) {\n      while (!stack.empty() && strength[stack.top()] > strength[i])\n        right[stack.top()] = i, stack.pop();\n      stack.push(i);\n    }\n\n    long ans = 0;\n\n    // For each strength[i] as minimum, calculate sum.\n    for (int i = 0; i < n; ++i) {\n      const int l = left[i];\n      const int r = right[i];\n      const long leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)];\n      const long rightSum = prefixOfPrefix[r] - prefixOfPrefix[i];\n      const int leftLen = i - l;\n      const int rightLen = r - i;\n      ans += strength[i] *\n             (rightSum * leftLen % kMod - leftSum * rightLen % kMod + kMod) %\n             kMod;\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n  public int totalStrength(int[] strength) {\n    final int kMod = 1_000_000_007;\n    final int n = strength.length;\n    long[] prefix = new long[n];\n    long[] prefixOfPrefix = new long[n + 1];\n    // left[i] := next index on the left (if any)\n    //            s.t. nums[left[i]] <= nums[i]\n    int[] left = new int[n];\n    Arrays.fill(left, -1);\n    // right[i] := next index on the right (if any)\n    //             s.t. nums[right[i]] < nums[i]\n    int[] right = new int[n];\n    Arrays.fill(right, n);\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    for (int i = 0; i < n; ++i)\n      prefix[i] = i == 0 ? strength[0] : (strength[i] + prefix[i - 1]) % kMod;\n\n    for (int i = 0; i < n; ++i)\n      prefixOfPrefix[i + 1] = (prefixOfPrefix[i] + prefix[i]) % kMod;\n\n    for (int i = n - 1; i >= 0; --i) {\n      while (!stack.isEmpty() && strength[stack.peek()] >= strength[i])\n        left[stack.pop()] = i;\n      stack.push(i);\n    }\n\n    stack.clear();\n\n    for (int i = 0; i < n; ++i) {\n      while (!stack.isEmpty() && strength[stack.peek()] > strength[i])\n        right[stack.pop()] = i;\n      stack.push(i);\n    }\n\n    long ans = 0;\n\n    // For each strength[i] as minimum, calculate sum.\n    for (int i = 0; i < n; ++i) {\n      final int l = left[i];\n      final int r = right[i];\n      final long leftSum = prefixOfPrefix[i] - prefixOfPrefix[Math.max(0, l)];\n      final long rightSum = prefixOfPrefix[r] - prefixOfPrefix[i];\n      final int leftLen = i - l;\n      final int rightLen = r - i;\n      ans += strength[i] * (rightSum * leftLen % kMod - leftSum * rightLen % kMod + kMod) % kMod;\n      ans %= kMod;\n    }\n\n    return (int) ans;\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Solution:\n  def totalStrength(self, strength: List[int]) -> int:\n    kMod = 1_000_000_007\n    n = len(strength)\n    # left[i] := next index on the left (if any)\n    #            s.t. nums[left[i]] <= nums[i]\n    left = [-1] * n\n    # right[i] := next index on the right (if any)\n    #             s.t. nums[right[i]] < nums[i]\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and strength[stack[-1]] >= strength[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and strength[stack[-1]] > strength[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    ans = 0\n    prefixOfPrefix = list(itertools.accumulate(\n        itertools.accumulate(strength), initial=0))\n\n    # For each strength[i] as the minimum, calculate sum.\n    for i, (l, r) in enumerate(zip(left, right)):\n      leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)]\n      rightSum = prefixOfPrefix[r] - prefixOfPrefix[i]\n      leftLen = i - l\n      rightLen = r - i\n      ans += strength[i] * (rightSum * leftLen - leftSum * rightLen) % kMod\n\n    return ans % kMod\n",
                "lang_text": "py"
            }
        }
    }
}