{
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "692",
            "title": "Top K Frequent Words",
            "titleSlug": "top-k-frequent-words",
            "content": "<p>Given an array of strings <code>words</code> and an integer <code>k</code>, return <em>the </em><code>k</code><em> most frequent strings</em>.</p>\n\n<p>Return the answer <strong>sorted</strong> by <strong>the frequency</strong> from highest to lowest. Sort the words with the same frequency by their <strong>lexicographical order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;i&quot;,&quot;love&quot;,&quot;coding&quot;], k = 2\n<strong>Output:</strong> [&quot;i&quot;,&quot;love&quot;]\n<strong>Explanation:</strong> &quot;i&quot; and &quot;love&quot; are the two most frequent words.\nNote that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;the&quot;,&quot;day&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;the&quot;,&quot;the&quot;,&quot;the&quot;,&quot;sunny&quot;,&quot;is&quot;,&quot;is&quot;], k = 4\n<strong>Output:</strong> [&quot;the&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;day&quot;]\n<strong>Explanation:</strong> &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n\t<li><code>k</code> is in the range <code>[1, The number of <strong>unique</strong> words[i]]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Could you solve it in <code>O(n log(k))</code> time and <code>O(n)</code> extra space?</p>\n",
            "isPaidOnly": false,
            "difficulty": "Medium",
            "likes": 7464,
            "dislikes": 340,
            "similarQuestions": "[{\"title\": \"Top K Frequent Elements\", \"titleSlug\": \"top-k-frequent-elements\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"K Closest Points to Origin\", \"titleSlug\": \"k-closest-points-to-origin\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sort Features by Popularity\", \"titleSlug\": \"sort-features-by-popularity\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sender With Largest Word Count\", \"titleSlug\": \"sender-with-largest-word-count\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Pairs in Array\", \"titleSlug\": \"maximum-number-of-pairs-in-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
            "topicTags": [
                {
                    "name": "Hash Table",
                    "slug": "hash-table"
                },
                {
                    "name": "String",
                    "slug": "string"
                },
                {
                    "name": "Trie",
                    "slug": "trie"
                },
                {
                    "name": "Sorting",
                    "slug": "sorting"
                },
                {
                    "name": "Heap (Priority Queue)",
                    "slug": "heap-priority-queue"
                },
                {
                    "name": "Bucket Sort",
                    "slug": "bucket-sort"
                },
                {
                    "name": "Counting",
                    "slug": "counting"
                }
            ],
            "stats": "{\"totalAccepted\": \"587.4K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 587359, \"totalSubmissionRaw\": 1018297, \"acRate\": \"57.7%\"}",
            "hints": [],
            "rephrased": {
                "body": "Given an array of strings `words`, find the `k` most frequent strings. The result should be sorted by frequency from highest to lowest. In case of a tie in frequency, sort the words lexicographically (alphabetical order).",
                "constraints": [
                    "1 <= words.length <= 500",
                    "1 <= words[i].length <= 10",
                    "words[i] consists of lowercase English letters.",
                    "k is in the range [1, The number of unique words[i]]"
                ],
                "testcases": [
                    {
                        "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
                        "output": "[\"i\",\"love\"]",
                        "explanation": "\"i\" and \"love\" are the two most frequent words. \"i\" comes before \"love\" due to a lower alphabetical order."
                    },
                    {
                        "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
                        "output": "[\"the\",\"is\",\"sunny\",\"day\"]",
                        "explanation": "\"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words, with frequencies 4, 3, 2 and 1 respectively."
                    }
                ]
            }
        },
        "similar": [
            {
                "difficulty": "Medium",
                "titleSlug": "top-k-frequent-elements",
                "title": "Top K Frequent Elements",
                "isPaidOnly": false
            },
            {
                "difficulty": "Medium",
                "titleSlug": "k-closest-points-to-origin",
                "title": "K Closest Points to Origin",
                "isPaidOnly": false
            },
            {
                "difficulty": "Medium",
                "titleSlug": "sort-features-by-popularity",
                "title": "Sort Features by Popularity",
                "isPaidOnly": true
            },
            {
                "difficulty": "Medium",
                "titleSlug": "sender-with-largest-word-count",
                "title": "Sender With Largest Word Count",
                "isPaidOnly": false
            },
            {
                "difficulty": "Easy",
                "titleSlug": "maximum-number-of-pairs-in-array",
                "title": "Maximum Number of Pairs in Array",
                "isPaidOnly": false
            }
        ],
        "hints": [],
        "relatedTopics": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Trie",
                "slug": "trie"
            },
            {
                "name": "Sorting",
                "slug": "sorting"
            },
            {
                "name": "Heap (Priority Queue)",
                "slug": "heap-priority-queue"
            },
            {
                "name": "Bucket Sort",
                "slug": "bucket-sort"
            },
            {
                "name": "Counting",
                "slug": "counting"
            }
        ],
        "solutions": {
            "cpp": {
                "lang": "C++",
                "full_func": "class Solution {\n public:\n  vector<string> topKFrequent(vector<string>& words, int k) {\n    const int n = words.size();\n    vector<string> ans;\n    vector<vector<string>> bucket(n + 1);\n    unordered_map<string, int> count;\n\n    for (const string& word : words)\n      ++count[word];\n\n    for (const auto& [word, freq] : count)\n      bucket[freq].push_back(word);\n\n    for (int freq = n; freq > 0; --freq) {\n      std::ranges::sort(bucket[freq]);\n      for (const string& word : bucket[freq]) {\n        ans.push_back(word);\n        if (ans.size() == k)\n          return ans;\n      }\n    }\n\n    throw;\n  }\n};\n",
                "lang_text": "cpp"
            },
            "java": {
                "lang": "Java",
                "full_func": "class Solution {\n  public List<String> topKFrequent(String[] words, int k) {\n    final int n = words.length;\n    List<String> ans = new ArrayList<>();\n    List<String>[] bucket = new List[n + 1];\n    Map<String, Integer> count = new HashMap<>();\n\n    for (final String word : words)\n      count.merge(word, 1, Integer::sum);\n\n    for (final String word : count.keySet()) {\n      final int freq = count.get(word);\n      if (bucket[freq] == null)\n        bucket[freq] = new ArrayList<>();\n      bucket[freq].add(word);\n    }\n\n    for (int freq = n; freq > 0; --freq)\n      if (bucket[freq] != null) {\n        Collections.sort(bucket[freq]);\n        for (final String word : bucket[freq]) {\n          ans.add(word);\n          if (ans.size() == k)\n            return ans;\n        }\n      }\n\n    throw new IllegalArgumentException();\n  }\n}\n",
                "lang_text": "java"
            },
            "py": {
                "lang": "Python",
                "full_func": "class Solution:\n  def topKFrequent(self, words: List[str], k: int) -> List[str]:\n    ans = []\n    bucket = [[] for _ in range(len(words) + 1)]\n\n    for word, freq in collections.Counter(words).items():\n      bucket[freq].append(word)\n\n    for b in reversed(bucket):\n      for word in sorted(b):\n        ans.append(word)\n        if len(ans) == k:\n          return ans\n",
                "lang_text": "py"
            }
        }
    }
}